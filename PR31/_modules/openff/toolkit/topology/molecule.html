
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  
  <link rel="icon" type="image/svg" href="../../../../_static/images/favicon.svg" />
  <link rel="apple-touch-icon" type="image/svg" href="../../../../_static/images/favicon.svg" />
  

  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="../../../../_static/site.css"/>
  
  <meta name="theme-color" content="#015480;">
  
  
    <title>openff.toolkit.topology.molecule &#8212; OpenFF Sphinx theme</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/openff.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/autodoc_pydantic.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   

  </head>
  <body dir=ltr
        data-md-color-accent=openff-toolkit-blue
        class="has-navbar-fixed-top">
  <header data-md-component="header">
  <nav class="navbar is-primary is-fixed-top is-flex-touch has-shadow" role="navigation" aria-label="main navigation">
    <div class="navbar-brand">
      <a href="../../../../index.html" title="OpenFF Sphinx theme" class="navbar-item is-hidden-mobile">
        
          <img src="../../../../_static/images/logos/openforcefield_v1_white.png" alt="OpenFF Sphinx theme logo">
        
      </a>
    </div>

    <div class="has-text-light is-hidden-mobile nav-title">
      <div class="breadcrumb">
  <ul>
        <li><a href="../../../../index.html">OpenFF Sphinx theme</a></li>
      <li><a href="../../../index.html">Module code</a></li>
      <li class="is-active"><a href="#">openff.toolkit.topology.molecule</a></li>
  </ul>
</div>
    </div>
    <div class="has-text-light is-hidden-tablet nav-title">
      <span> openff.toolkit.topology.molecule </span>
    </div>

    <div class="navbar-end">
      <span class="navbar-item nav-search is-hidden-mobile">
        
<form action="../../../../search.html" method="GET" name="search">
  <div class="control has-icons-right">
    <span class="icon is-small is-right">
      <i class="fas fa-search"></i>
    </span>
    <input class="input is-primary" type="text"  name="q" placeholder="Search"
         autocapitalize="off" autocomplete="off" spellcheck="false">
  </div>
</form>

      </span>
      
        <a href="https://github.com/openforcefield/openff-sphinx-theme/" class="is-family-monospace navbar-item is-hidden-touch has-text-light">
          
          <span class="icon-text">
            <span class="icon">
              <i class="fab fa-github"></i>
            </span>
            <span>
          
            openff-sphinx-theme
          
            </span>
          </span>
          
        </a>
      
      <a href="https://openforcefield.org/" class="navbar-item is-hidden-touch">
        <img
          src="../../../../_static/images/logos/openforcefield_v2_white.png"
          alt="Open Force Field Initiative logo"
        >
      </a>
    </div>
    <span class="navbar-burger-spacer is-hidden-desktop"></span>
  </nav>

  

  <div class="level is-hidden-mobile nav-tabs">
      
      <div class="level-item has-text-centered"><a href="https://squidfunk.github.io/mkdocs-material/">Material for MkDocs</a></div>
      
      <div class="level-item has-text-centered"><a href="https://bashtage.github.io/sphinx-material/">Material for Sphinx</a></div>
      
      <div class="level-item has-text-centered"><a href="https://openforcefield.org">The OpenFF Initiative</a></div>
      
      <div class="level-item has-text-centered"><a href="https://github.com/openforcefield/openff-sphinx-theme/">openff-sphinx-theme on GitHub</a></div>
  </div>

</header>

  
  <main class="mb-6">
      <div class="columns">
        <input type="checkbox" id="drawer-toggle" class="is-hidden">
        <label for="drawer-toggle" role="button" class="navbar-burger burger is-light">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </label>

        <aside class="column is-2" id="drawer">
          <div class="is-hidden-tablet">
            <a href="../../../../index.html" title="OpenFF Sphinx theme">
              <h1>
                OpenFF Sphinx theme
              </h1>
            </a>
            <div class="py-3">
              
<form action="../../../../search.html" method="GET" name="search">
  <div class="control has-icons-right">
    <span class="icon is-small is-right">
      <i class="fas fa-search"></i>
    </span>
    <input class="input is-primary" type="text"  name="q" placeholder="Search"
         autocapitalize="off" autocomplete="off" spellcheck="false">
  </div>
</form>

            </div>
          </div>
          

<nav class="menu ff-globaltoc">
  
    
      
      <p class="menu-label"><span class="caption-text">Basic Use</span></p>
      <ul class="menu-list">
    
    
      
      <li>
        <a href="../../../../customization.html" class="">Customization</a>
      </li>
      
    
    
      
      <li>
        <a href="../../../../specimen.html" class="">Specimen</a>
      </li>
      
    
    
      
      <li>
        <a href="../../../../additional_samples.html" class=""><code class="docutils literal notranslate"><span class="pre">additional_samples_with_very_long_name</span></code></a>
      </li>
      
    
    
      
        </ul>
      
      <p class="menu-label"><span class="caption-text">Other Examples and Uses</span></p>
      <ul class="menu-list">
    
    
      
      <li>
        <a href="../../../../pymethod.html" class="">Python Methods</a>
      </li>
      
    
    
      
      <li>
        <a href="../../../../numpydoc_example.html" class="">NumPy Docstrings</a>
      </li>
      
    
    
      
      <li>
        <a href="../../../../autodoc_pydantic_example.html" class="">autodoc_pydantic API Docs</a>
      </li>
      
    
    
      
      <li>
        <a href="../../../../numpydoc.html" class="">Openff-toolkit example</a>
      </li>
      
    
    
      
      <li>
        <a href="../../../../pydantic.html" class="">Pydantic API docs</a>
      </li>
      
    
    
      
      <li>
        <a href="../../../../notebook.html" class="">Jupyter Notebooks</a>
      </li>
      
    
    
      
      <li>
        <a href="../../../../markdown.html" class="">Markdown</a>
      </li>
      
    
    
      
      <li>
        <a href="../../../../rst-cheatsheet/rst-cheatsheet.html" class="">rst Cheatsheet</a>
      </li>
      
    
    
      
      <li>
        <a href="../../../../primer.html" class="">reStructuredText Primer</a>
      </li>
      
    
    
      
        </ul>
      
      <p class="menu-label"><span class="caption-text">Changes and License</span></p>
      <ul class="menu-list">
    
    
      
      <li>
        <a href="../../../../change-log.html" class="">Change Log</a>
      </li>
      
    
    
      
      <li>
        <a href="../../../../license.html" class="">License</a>
      </li>
      
        </ul>
      
    
  </ul>
</nav>

        </aside>

        <div class="column is-8-desktop is-9-tablet">
          <article class="content">
            
  <h1>Source code for openff.toolkit.topology.molecule</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="c1"># =============================================================================================</span>
<span class="c1"># MODULE DOCSTRING</span>
<span class="c1"># =============================================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Molecular chemical entity representation and routines to interface with cheminformatics toolkits</span>

<span class="sd">.. todo::</span>

<span class="sd">   * Our main philosophy here is to keep the object contents of topology objects easily serializable/deserializable</span>

<span class="sd">   * Have ``Molecule`` raise an exception if loading/creating molecules with unspecified stereochemistry?</span>
<span class="sd">   * Create ``FrozenMolecule`` to represent immutable molecule</span>
<span class="sd">   * Make ``Atom`` and ``Bond`` an inner class of Molecule?</span>
<span class="sd">   * Add ``Molecule.from_smarts()`` or ``.from_tagged_smiles()`` to allow a tagged SMARTS string</span>
<span class="sd">     (where tags are zero-indexed atom indices) to be used to create a molecule with the given atom numbering.</span>
<span class="sd">   * How can we make the ``Molecule`` API more useful to codes like perses that modify molecules on the fly?</span>
<span class="sd">   * Use `attrs &lt;http://www.attrs.org/&gt;`_ for convenient class initialization?</span>
<span class="sd">   * JSON/BSON representations of objects?</span>
<span class="sd">   * Generalize Molecule infrastructure to provide &quot;plug-in&quot; support for cheminformatics toolkits</span>
<span class="sd">   * Do we need a way to write a bunch of molecules to a file, or serialize a set of molecules to a file?</span>
<span class="sd">     We currently don&#39;t have a way to do that through the ``Molecule`` API, even though there is a way to</span>
<span class="sd">     read multiple molecules via ``Molecules.from_file()``.</span>
<span class="sd">   * Should we allow the removal of atoms too?</span>
<span class="sd">   * Should invalidation of cached properties be handled via something like a tracked list?</span>
<span class="sd">   * Refactor toolkit encapsulation to generalize and provide only a few major toolkit methods and toolkit objects that can be queried for features</span>
<span class="sd">   * Speed up overall import time by putting non-global imports only where they are needed</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

    <span class="kn">from</span> <span class="nn">openff.toolkit.topology</span> <span class="kn">import</span> <span class="n">TopologyMolecule</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">openmm</span> <span class="kn">import</span> <span class="n">LocalCoordinatesSite</span><span class="p">,</span> <span class="n">unit</span>
    <span class="kn">from</span> <span class="nn">openmm.app</span> <span class="kn">import</span> <span class="n">Element</span><span class="p">,</span> <span class="n">element</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">simtk</span> <span class="kn">import</span> <span class="n">unit</span>
    <span class="kn">from</span> <span class="nn">simtk.openmm</span> <span class="kn">import</span> <span class="n">LocalCoordinatesSite</span>
    <span class="kn">from</span> <span class="nn">simtk.openmm.app</span> <span class="kn">import</span> <span class="n">Element</span><span class="p">,</span> <span class="n">element</span>

<span class="kn">import</span> <span class="nn">openff.toolkit</span>
<span class="kn">from</span> <span class="nn">openff.toolkit.utils</span> <span class="kn">import</span> <span class="n">quantity_to_string</span><span class="p">,</span> <span class="n">string_to_quantity</span>
<span class="kn">from</span> <span class="nn">openff.toolkit.utils.exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">InvalidConformerError</span><span class="p">,</span>
    <span class="n">NotAttachedToMoleculeError</span><span class="p">,</span>
    <span class="n">SmilesParsingError</span><span class="p">,</span>
    <span class="n">UnsupportedFileTypeError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">openff.toolkit.utils.serialization</span> <span class="kn">import</span> <span class="n">Serializable</span>
<span class="kn">from</span> <span class="nn">openff.toolkit.utils.toolkits</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DEFAULT_AROMATICITY_MODEL</span><span class="p">,</span>
    <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="n">InvalidToolkitRegistryError</span><span class="p">,</span>
    <span class="n">OpenEyeToolkitWrapper</span><span class="p">,</span>
    <span class="n">RDKitToolkitWrapper</span><span class="p">,</span>
    <span class="n">ToolkitRegistry</span><span class="p">,</span>
    <span class="n">ToolkitWrapper</span><span class="p">,</span>
    <span class="n">UndefinedStereochemistryError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">openff.toolkit.utils.utils</span> <span class="kn">import</span> <span class="n">MissingDependencyError</span><span class="p">,</span> <span class="n">requires_package</span>

<span class="c1"># =============================================================================================</span>
<span class="c1"># GLOBAL PARAMETERS</span>
<span class="c1"># =============================================================================================</span>

<span class="c1"># TODO: Can we have the `ALLOWED_*_MODELS` list automatically appear in the docstrings below?</span>
<span class="c1"># TODO: Should `ALLOWED_*_MODELS` be objects instead of strings?</span>
<span class="c1"># TODO: Should these be imported from `openff.toolkit.cheminformatics.aromaticity_models` and `.bondorder_models`?</span>

<span class="c1"># TODO: Allow all OpenEye aromaticity models to be used with OpenEye names?</span>
<span class="c1">#       Only support OEAroModel_MDL in RDKit version?</span>

<span class="c1"># =============================================================================================</span>
<span class="c1"># PRIVATE SUBROUTINES</span>
<span class="c1"># =============================================================================================</span>

<span class="c1"># =============================================================================================</span>
<span class="c1"># Particle</span>
<span class="c1"># =============================================================================================</span>


<span class="k">class</span> <span class="nc">Particle</span><span class="p">(</span><span class="n">Serializable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all particles in a molecule.</span>

<span class="sd">    A particle object could be an ``Atom`` or a ``VirtualSite``.</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ``Molecule`` this particle is part of.</span>

<span class="sd">        .. todo::</span>

<span class="sd">            * Should we have a single unique ``Molecule`` for each molecule</span>
<span class="sd">              type in the system, or if we have multiple copies of the same</span>
<span class="sd">              molecule, should we have multiple ``Molecule``\ s?</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span>

    <span class="nd">@molecule</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the particle&#39;s molecule pointer. Note that this will only work if the particle currently</span>
<span class="sd">        doesn&#39;t have a molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> already has an associated molecule&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="n">err</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="o">=</span> <span class="n">molecule</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecule_particle_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of this particle in its molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of the particle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert to dictionary representation.&quot;&quot;&quot;</span>
        <span class="c1"># Implement abstract method Serializable.to_dict()</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>  <span class="c1"># TODO</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Static constructor from dictionary representation.&quot;&quot;&quot;</span>
        <span class="c1"># Implement abstract method Serializable.to_dict()</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>  <span class="c1"># TODO</span>


<span class="c1"># =============================================================================================</span>
<span class="c1"># Atom</span>
<span class="c1"># =============================================================================================</span>


<span class="k">class</span> <span class="nc">Atom</span><span class="p">(</span><span class="n">Particle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A particle representing a chemical atom.</span>

<span class="sd">    Note that non-chemical virtual sites are represented by the ``VirtualSite`` object.</span>

<span class="sd">    .. todo::</span>

<span class="sd">       * Should ``Atom`` objects be immutable or mutable?</span>
<span class="sd">       * Do we want to support the addition of arbitrary additional properties,</span>
<span class="sd">         such as floating point quantities (e.g. ``charge``), integral quantities (such as ``id`` or ``serial`` index in a PDB file),</span>
<span class="sd">         or string labels (such as Lennard-Jones types)?</span>

<span class="sd">    .. todo :: Allow atoms to have associated properties.</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atomic_number</span><span class="p">,</span>
        <span class="n">formal_charge</span><span class="p">,</span>
        <span class="n">is_aromatic</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">molecule</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">stereochemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an immutable Atom object.</span>

<span class="sd">        Object is serializable and immutable.</span>

<span class="sd">        .. todo :: Use attrs to validate?</span>

<span class="sd">        .. todo :: We can add setters if we need to.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atomic_number : int</span>
<span class="sd">            Atomic number of the atom</span>
<span class="sd">        formal_charge : int or openmm.unit.Quantity-wrapped int with dimension &quot;charge&quot;</span>
<span class="sd">            Formal charge of the atom</span>
<span class="sd">        is_aromatic : bool</span>
<span class="sd">            If True, atom is aromatic; if False, not aromatic</span>
<span class="sd">        stereochemistry : str, optional, default=None</span>
<span class="sd">            Either &#39;R&#39; or &#39;S&#39; for specified stereochemistry, or None for ambiguous stereochemistry</span>
<span class="sd">        name : str, optional, default=None</span>
<span class="sd">            An optional name to be associated with the atom</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a non-aromatic carbon atom</span>

<span class="sd">        &gt;&gt;&gt; atom = Atom(6, 0, False)</span>

<span class="sd">        Create a chiral carbon atom</span>

<span class="sd">        &gt;&gt;&gt; atom = Atom(6, 0, False, stereochemistry=&#39;R&#39;, name=&#39;CT&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atomic_number</span> <span class="o">=</span> <span class="n">atomic_number</span>
        <span class="c1"># Use the setter here, since it will handle either ints or Quantities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">=</span> <span class="n">formal_charge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_aromatic</span> <span class="o">=</span> <span class="n">is_aromatic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span> <span class="o">=</span> <span class="n">stereochemistry</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="o">=</span> <span class="n">molecule</span>
        <span class="c1">## From Jeff: I&#39;m going to assume that this is implicit in the parent Molecule&#39;s ordering of atoms</span>
        <span class="c1"># self._molecule_atom_index = molecule_atom_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="c1"># TODO: We can probably avoid an explicit call and determine this dynamically</span>
    <span class="c1">#   from self._molecule (maybe caching the result) to get rid of some bookkeeping.</span>
    <span class="k">def</span> <span class="nf">add_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a bond that this atom is involved in</span>
<span class="sd">        .. todo :: Is this how we want to keep records?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bond: an openff.toolkit.topology.molecule.Bond</span>
<span class="sd">            A bond involving this atom</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>
        <span class="c1"># self._stereochemistry = None</span>

    <span class="k">def</span> <span class="nf">add_virtual_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vsite</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a bond that this atom is involved in</span>
<span class="sd">        .. todo :: Is this how we want to keep records?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bond: an openff.toolkit.topology.molecule.Bond</span>
<span class="sd">            A bond involving this atom</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vsite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dict representation of the atom.&quot;&quot;&quot;</span>
        <span class="c1"># TODO</span>
        <span class="n">atom_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">atom_dict</span><span class="p">[</span><span class="s2">&quot;atomic_number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atomic_number</span>
        <span class="n">atom_dict</span><span class="p">[</span><span class="s2">&quot;formal_charge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formal_charge</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span>
            <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span>
        <span class="p">)</span>
        <span class="n">atom_dict</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_aromatic</span>
        <span class="n">atom_dict</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span>
        <span class="c1"># TODO: Should we let atoms have names?</span>
        <span class="n">atom_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
        <span class="c1"># TODO: Should this be implicit in the atom ordering when saved?</span>
        <span class="c1"># atom_dict[&#39;molecule_atom_index&#39;] = self._molecule_atom_index</span>
        <span class="k">return</span> <span class="n">atom_dict</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">atom_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an Atom from a dict representation.&quot;&quot;&quot;</span>
        <span class="c1">## TODO: classmethod or static method? Classmethod is needed for Bond, so it have</span>
        <span class="c1">## its _molecule set and then look up the Atom on each side of it by ID</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">atom_dict</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">formal_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The atom&#39;s formal charge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formal_charge</span>

    <span class="nd">@formal_charge</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">formal_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">openff.toolkit.utils.utils</span> <span class="kn">import</span> <span class="n">check_units_are_compatible</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the atom&#39;s formal charge. Accepts either ints or openmm.unit.Quantity-wrapped ints with units of charge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_formal_charge</span> <span class="o">=</span> <span class="n">other</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">check_units_are_compatible</span><span class="p">(</span><span class="s2">&quot;formal charge&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_formal_charge</span> <span class="o">=</span> <span class="n">other</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">partial_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The partial charge of the atom, if any.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        openmm.unit.Quantity with dimension of atomic charge, or None if no charge has been specified</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule_atom_index</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">_partial_charges</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_aromatic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The atom&#39;s is_aromatic flag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_aromatic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stereochemistry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The atom&#39;s stereochemistry (if defined, otherwise None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span>

    <span class="nd">@stereochemistry</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">stereochemistry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the atoms stereochemistry</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            The stereochemistry around this atom, allowed values are &quot;CW&quot;, &quot;CCW&quot;, or None,</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if (value != &#39;CW&#39;) and (value != &#39;CCW&#39;) and not(value is None):</span>
        <span class="c1">#    raise Exception(&quot;Atom stereochemistry setter expected &#39;CW&#39;, &#39;CCW&#39;, or None. Received {} (type {})&quot;.format(value, type(value)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The element of this atom.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        openmm.openmm.app.element.Element</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">Element</span><span class="o">.</span><span class="n">getByAtomicNumber</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atomic_number</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atomic_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The integer atomic number of the atom.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atomic_number</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The standard atomic weight (abundance-weighted isotopic mass) of the atomic site.</span>

<span class="sd">        .. todo :: Should we discriminate between standard atomic weight and most abundant isotopic mass?</span>

<span class="sd">        TODO (from jeff): Are there atoms that have different chemical properties based on their isotopes?</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">mass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of this atom, if any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : string</span>
<span class="sd">            The new name for this atom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;In setting atom name. Expected str, received </span><span class="si">{}</span><span class="s2"> (type </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">other</span>

    <span class="c1"># TODO: How are we keeping track of bonds, angles, etc?</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The list of ``Bond`` objects this atom is involved in.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span>
        <span class="c1"># for bond in self._bonds:</span>
        <span class="c1">#    yield bond</span>

    <span class="nd">@property</span>
    <span class="c1"># def bonded_to(self):</span>
    <span class="k">def</span> <span class="nf">bonded_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The list of ``Atom`` objects this atom is involved in bonds with</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">bond</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">atom</span> <span class="o">==</span> <span class="bp">self</span><span class="p">):</span>
                    <span class="c1"># TODO: This seems dangerous. Ask John for a better way</span>
                    <span class="k">yield</span> <span class="n">atom</span>

    <span class="k">def</span> <span class="nf">is_bonded_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether this atom is bound to another atom</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom2: openff.toolkit.topology.molecule.Atom</span>
<span class="sd">            a different atom in the same molecule</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether this atom is bound to atom2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Sanity check (check for same molecule?)</span>
        <span class="k">assert</span> <span class="bp">self</span> <span class="o">!=</span> <span class="n">atom2</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">bonded_atom</span> <span class="ow">in</span> <span class="n">bond</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom2</span> <span class="o">==</span> <span class="n">bonded_atom</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_in_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether or not this atom is in a ring(s) (of any size)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotAttachedToMoleculeError</span><span class="p">(</span>
                <span class="s2">&quot;This Atom does not belong to a Molecule object&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">molecule_atom_index</span> <span class="ow">in</span> <span class="n">ring</span> <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">rings</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">virtual_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The list of ``VirtualSite`` objects this atom is involved in.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span>
        <span class="c1"># for vsite in self._vsites:</span>
        <span class="c1">#    yield vsite</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecule_atom_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index of this Atom within the the list of atoms in ``Molecules``.</span>
<span class="sd">        Note that this can be different from ``molecule_particle_index``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This Atom does not belong to a Molecule object&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecule_particle_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index of this Atom within the the list of particles in the parent ``Molecule``.</span>
<span class="sd">        Note that this can be different from ``molecule_atom_index``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This Atom does not belong to a Molecule object&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ## From Jeff: Not sure if we actually need this</span>
    <span class="c1"># @property</span>
    <span class="c1"># def topology_atom_index(self):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     The index of this Atom within the the list of atoms in ``Topology``.</span>
    <span class="c1">#     Note that this can be different from ``particle_index``.</span>
    <span class="c1">#</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     if self._topology is None:</span>
    <span class="c1">#         raise ValueError(&#39;This Atom does not belong to a Topology object&#39;)</span>
    <span class="c1">#     # TODO: This will be slow; can we cache this and update it only when needed?</span>
    <span class="c1">#     #       Deleting atoms/molecules in the Topology would have to invalidate the cached index.</span>
    <span class="c1">#     return self._topology.atoms.index(self)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Also include particle_index and which molecule this atom belongs to?</span>
        <span class="k">return</span> <span class="s2">&quot;Atom(name=</span><span class="si">{}</span><span class="s2">, atomic number=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atomic_number</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Also include particle_index and which molecule this atom belongs to?</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;Atom name=&#39;</span><span class="si">{}</span><span class="s2">&#39; atomic number=&#39;</span><span class="si">{}</span><span class="s2">&#39;&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atomic_number</span>
        <span class="p">)</span>


<span class="c1"># =============================================================================================</span>
<span class="c1"># VirtualParticle</span>
<span class="c1"># =============================================================================================</span>


<span class="k">class</span> <span class="nc">VirtualParticle</span><span class="p">(</span><span class="n">Particle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single particle owned by a VirtualSite</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vsite</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A single particle owned by a VirtualSite</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vsite : openff.toolkit.topology.VirtualSite</span>
<span class="sd">            The parent VirtualSite of this VirtualParticle</span>
<span class="sd">        orientation : tuple of int</span>
<span class="sd">            Molecule atom indices of parent atoms</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            The name of the particle</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_site</span> <span class="o">=</span> <span class="n">vsite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="o">=</span> <span class="n">vsite</span><span class="o">.</span><span class="n">molecule</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orientation</span> <span class="o">=</span> <span class="n">orientation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">virtual_site</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_site</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orientation</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">virtual_site_particle_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index of the particle relative to its owning virtual site. Normally</span>
<span class="sd">        this should either be 0 or 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_site</span><span class="o">.</span><span class="n">orientations</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_positions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculations the position of a virtual particle, as defined by the OpenMM</span>
<span class="sd">        :class:`openmm.openmm.openmm.LocalCoordinatesSite` definition.</span>

<span class="sd">        The frame is first constructed using the input atoms, where the weights defined</span>
<span class="sd">        by each virtual site are used. The virtual particle positions are then</span>
<span class="sd">        determined by setting the displacements, also determined uniquely by each</span>
<span class="sd">        virtual site definition.</span>

<span class="sd">        Note that, following the definition of the OpenMM LocalCoordinatesSite, the</span>
<span class="sd">        frame is forced to be orthogonal. This is first enforced by only allowing the</span>
<span class="sd">        x- and y-axis to be defined, since the z-axis must be normal to this plane.</span>
<span class="sd">        Then, y is then reset to be normal to the zx plane. This should ensure that the</span>
<span class="sd">        frame is orthonormal (after normalization).</span>

<span class="sd">        Note that this returns a 1D flat list as it is meant to be appended into a</span>
<span class="sd">        (M, 3) array via the public interface.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom_positions: iterable of int</span>
<span class="sd">            The indices of the atoms, relative to the indices defined by the owning</span>
<span class="sd">            molecule. This is necessary since this particle has a certain orientation,</span>
<span class="sd">            so the input atoms must be in the original input ordering which was used to</span>
<span class="sd">            define the orientation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.unit.Quantity` of dimension [Length] in unit Angstrom wrapping an</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Although the above docstring claims that we fully implement</span>
        <span class="c1"># the OpenMM behavior, it has not been compared to OpenMM</span>
        <span class="c1"># at the source code level. If positions seem to be inconsistent,</span>
        <span class="c1"># please submit a bug report! We have tests to make sure our</span>
        <span class="c1"># implemented types are correct, so we are interested in cases</span>
        <span class="c1"># where custom virtual sites cause breakage.</span>

        <span class="n">atom_positions_unit</span> <span class="o">=</span> <span class="n">atom_positions</span><span class="o">.</span><span class="n">unit</span>

        <span class="n">originwt</span><span class="p">,</span> <span class="n">xdir</span><span class="p">,</span> <span class="n">ydir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_site</span><span class="o">.</span><span class="n">local_frame_weights</span>
        <span class="n">disp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_site</span><span class="o">.</span><span class="n">local_frame_position</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">disp</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">disp</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="c1"># this pulls the correct ordering of the atoms</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orientation</span><span class="p">:</span>
            <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_positions</span><span class="p">[</span><span class="n">atom</span><span class="p">])</span>

        <span class="n">atom_positions</span> <span class="o">=</span> <span class="n">pos</span>

        <span class="n">originwt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">originwt</span><span class="p">)</span>
        <span class="n">atom_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">atom_positions</span><span class="p">)</span>

        <span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">originwt</span><span class="p">,</span> <span class="n">atom_positions</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">xdir</span><span class="p">,</span> <span class="n">ydir</span><span class="p">)),</span> <span class="n">atom_positions</span><span class="p">)</span>

        <span class="n">zaxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">)</span>
        <span class="n">yaxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">zaxis</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_normalize</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">/=</span> <span class="n">L</span>
            <span class="k">return</span> <span class="n">axis</span>

        <span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="n">zaxis</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">_normalize</span><span class="p">,</span> <span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">))</span>

        <span class="n">position</span> <span class="o">=</span> <span class="n">origin</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">xaxis</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">yaxis</span> <span class="o">+</span> <span class="n">z</span> <span class="o">*</span> <span class="n">zaxis</span>

        <span class="k">return</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">atom_positions_unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_position_from_conformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformation</span><span class="p">):</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">molecule_atom_index</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_site</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>

        <span class="n">atom_positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">conformation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">atom_positions</span>

    <span class="k">def</span> <span class="nf">_get_conformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer_idx</span><span class="p">):</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">conformers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">conformer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">conformers</span><span class="p">[</span><span class="n">conformer_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">conformer</span>

    <span class="k">def</span> <span class="nf">compute_position_from_conformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the position of this virtual particle given an existing</span>
<span class="sd">        conformer owned by the parent molecule/virtual site.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer_idx : int</span>
<span class="sd">            The index of the conformer in the owning molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.unit.Quantity` of dimension [Length] in unit Angstroms wrapping a</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The positions of the virtual particles belonging to this virtual site.</span>
<span class="sd">            The array is the size (M, 3) where M is the number of virtual particles</span>
<span class="sd">            belonging to this virtual site.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">atom_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_conformer</span><span class="p">(</span><span class="n">conformer_idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_position_from_atom_positions</span><span class="p">(</span><span class="n">atom_positions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_position_from_atom_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_positions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the position of this virtual site particle given a set of coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom_positions : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The positions of all atoms in the molecule. The array is the size (N, 3)</span>
<span class="sd">            where N is the number of atoms in the molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.unit.Quantity` of dimension [Length] in unit Angstroms wrapping a</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The positions of the virtual particles belonging to this virtual site.</span>
<span class="sd">            The array is the size (M, 3) where M is the number of virtual particles</span>
<span class="sd">            belonging to this virtual site.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="p">(</span><span class="n">atom_positions</span><span class="p">)</span>


<span class="c1"># =============================================================================================</span>
<span class="c1"># VirtualSite</span>
<span class="c1"># =============================================================================================</span>


<span class="k">class</span> <span class="nc">VirtualSite</span><span class="p">(</span><span class="n">Particle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A container representing one or more virtual particles whose positions are</span>
<span class="sd">    defined in terms of ``Atom`` positions. This container enables the coupling</span>
<span class="sd">    of particles that are symmetric about some axis/plane of the underlying</span>
<span class="sd">    atoms. For example, a single virtual site can represent two lone pairs of a</span>
<span class="sd">    water molecule, where the angle and distance parameters are expected to stay</span>
<span class="sd">    coupled, and are reflections across the plane of symmetry.</span>

<span class="sd">    Note that chemical atoms are represented by the ``Atom``.</span>


<span class="sd">    .. warning :: This API is experimental and subject to change.</span>

<span class="sd">    .. todo::</span>

<span class="sd">       * Should a virtual site be able to belong to more than one Topology?</span>
<span class="sd">       * Should virtual sites be immutable or mutable?</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">,</span>
        <span class="n">charge_increments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rmin_half</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orientations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Base class for VirtualSites</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * change sigma/epsilon/rmin_half to have units</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : list of Atom of shape [N]</span>
<span class="sd">            atoms[index] is the corresponding Atom</span>
<span class="sd">        charge_increments : list of floats of shape [N], optional, default=None</span>
<span class="sd">            The amount of charge to remove from the VirtualSite&#39;s atoms and put in the VirtualSite. Indexing in this list should match the ordering in the atoms list. Default is None.</span>
<span class="sd">        sigma : float, default=None</span>
<span class="sd">            Sigma term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        rmin_half : float</span>
<span class="sd">            Rmin_half term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        name : string or None, default=None</span>
<span class="sd">            The name of this virtual site. Default is None.</span>

<span class="sd">        virtual_site_type : str</span>
<span class="sd">            Virtual site type.</span>
<span class="sd">        name : str or None, default=None</span>
<span class="sd">            The name of this virtual site. Default is None</span>
<span class="sd">        orientation : list of int tuples or None, default=None</span>
<span class="sd">            The ordering of the atoms used to define the frame of the virtual site.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure we have as many charge_increments as we do atoms</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">charge_increments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">charge_increments</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;VirtualSite definition must have same number of charge_increments (</span><span class="si">{}</span><span class="s2">) and atoms(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">charge_increments</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">charge_increments</span> <span class="o">=</span> <span class="p">([</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span>

        <span class="c1"># set sane defaults for OpenMM</span>
        <span class="k">if</span> <span class="n">epsilon</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rmin_half</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">kilocalorie_per_mole</span>
        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rmin_half</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span>

        <span class="c1"># VdW parameters can either be epsilon+rmin_half or epsilon+sigma, but not both</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">epsilon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rmin_half</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;VirtualSite constructor given epsilon (value : </span><span class="si">{}</span><span class="s2">), rmin_half (value : </span><span class="si">{}</span><span class="s2">), and sigma (value : </span><span class="si">{}</span><span class="s2">). If epsilon is nonzero, it should receive either rmin_half OR sigma&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">epsilon</span><span class="p">,</span> <span class="n">rmin_half</span><span class="p">,</span> <span class="n">sigma</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rmin_half</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;VirtualSite constructor given epsilon (value : </span><span class="si">{}</span><span class="s2">) but not given rmin_half (value : </span><span class="si">{}</span><span class="s2">) or sigma (value : </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">epsilon</span><span class="p">,</span> <span class="n">rmin_half</span><span class="p">,</span> <span class="n">sigma</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># TODO: Save the 6th root of 2 if this starts being slow.</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">rmin_half</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">6</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">epsilon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rmin_half</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;VirtualSite constructor given rmin_half (value : </span><span class="si">{}</span><span class="s2">) or sigma (value : </span><span class="si">{}</span><span class="s2">), but not epsilon (value : </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">rmin_half</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># Perform type-checking</span>
        <span class="c1"># for atom in atoms:</span>
        <span class="c1">#     assert isinstance(atom, Atom)</span>
        <span class="c1"># for atom_index in range(len(atoms) - 1):</span>
        <span class="c1">#     assert atoms[atom_index].molecule is atoms[atom_index + 1].molecule</span>
        <span class="c1"># assert isinstance(atoms[1].molecule, FrozenMolecule)</span>

        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sigma</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">epsilon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_epsilon</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">epsilon</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">kilojoule_per_mole</span><span class="p">)</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">epsilon</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_epsilon</span> <span class="o">=</span> <span class="n">epsilon</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">kilojoule_per_mole</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">charge_increments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_charge_increments</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">charge_increments</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charges</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">ci</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_charge_increments</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">ci</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">elementary_charges</span><span class="p">)</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">charge_increments</span>
            <span class="p">]</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charges</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">add_virtual_site</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">molecule</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">if</span> <span class="n">orientations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ornt</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">molecule_atom_index</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orientations</span> <span class="o">=</span> <span class="n">ornt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_particles</span> <span class="o">=</span> <span class="p">{</span><span class="n">ornt</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">VirtualParticle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ornt</span><span class="p">[</span><span class="mi">0</span><span class="p">])}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ornt</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">orientations</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">ornt</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">orientations</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ornt</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">orientations</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orientations</span> <span class="o">=</span> <span class="n">ornt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_particles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="p">{</span><span class="n">order</span><span class="p">:</span> <span class="n">VirtualParticle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">ornt</span><span class="p">}</span>
            <span class="p">)</span>

        <span class="c1"># Subclassing makes _type unnecessary</span>
        <span class="c1"># self._type = None</span>
        <span class="c1"># TODO: Validate site types against allowed values</span>

        <span class="c1"># self._weights = np.array(weights) # make a copy and convert to array internally</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">VirtualSite</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">same_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
        <span class="n">same_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">same_mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">molecule</span>
        <span class="n">same_vsite</span> <span class="o">=</span> <span class="n">same_name</span> <span class="ow">and</span> <span class="n">same_indices</span> <span class="ow">and</span> <span class="n">same_mol</span>
        <span class="k">return</span> <span class="n">same_vsite</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dict representation of the virtual site.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Each subclass should have its own to_dict</span>
        <span class="n">vsite_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">molecule_atom_index</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;charge_increments&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantity_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_charge_increments</span><span class="p">)</span>

        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;epsilon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantity_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_epsilon</span><span class="p">)</span>

        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantity_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sigma</span><span class="p">)</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;orientations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orientations</span>

        <span class="c1"># skip packing the particles; they are created dynamically</span>

        <span class="k">return</span> <span class="n">vsite_dict</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">vsite_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a virtual site from a dict representation.&quot;&quot;&quot;</span>
        <span class="c1"># Each subclass needs to have its own from_dict</span>

        <span class="c1"># Make a copy of the vsite_dict, where we&#39;ll unit-wrap the appropriate values</span>
        <span class="n">vsite_dict_units</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">)</span>

        <span class="c1"># Attach units to epsilon term</span>
        <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;epsilon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;epsilon&quot;</span><span class="p">])</span>
        <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">])</span>
        <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;charge_increments&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span>
            <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;charge_increments&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_orientation</span>

        <span class="k">return</span> <span class="n">VirtualSite</span><span class="p">(</span><span class="o">**</span><span class="n">vsite_dict_units</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">index_of_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">virtual_particle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the orientation used by the given virtual particle.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        virtual_particle : VirtualParticle</span>
<span class="sd">            The virtual particle contained in this virual site</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A tuple of atom indices</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">vp</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="n">virtual_particle</span><span class="o">.</span><span class="n">orientation</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
        <span class="k">assert</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The given virtual particle was not found in this Virtual Site&quot;</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">orientations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The orientations used by the virtual site particles.</span>

<span class="sd">        Orientations are an implementation to allow generation and coupling of multiple</span>
<span class="sd">        particles using the same physical definition. We can do this by allowing each</span>
<span class="sd">        particle to use a specific ordering of bases when calculating the positions.</span>
<span class="sd">        This is similar to improper torsion angles: the angle you find depends on the</span>
<span class="sd">        atom ordering used in the calculation.</span>

<span class="sd">        Before the positions are constructed, the parent atoms are reordered according</span>
<span class="sd">        to the particle&#39;s orientation. Each virtual particle has exactly one</span>
<span class="sd">        orientation. Since the frame of the virtual site is defined by a static list of</span>
<span class="sd">        weights and masks, we are able to influence how the local frame is constructed</span>
<span class="sd">        by crafting specific ordering the parent atoms.</span>

<span class="sd">        As a concrete example, we could define a TIP5 water by using one virtual site,</span>
<span class="sd">        and the particles have orientations (0, 1, 2) and (2, 1, 0). This means that,</span>
<span class="sd">        given that we are using a right-handed coordinate system, the z-axis will</span>
<span class="sd">        point in opposite directions for each particle. Using the same</span>
<span class="sd">        ``out_of_plane_angle`` and ``distance`` will therefore result in two unique</span>
<span class="sd">        particle positions.</span>

<span class="sd">        Using the toolkit API allows arbitrary selection of orientations. The SMIRNOFF</span>
<span class="sd">        specification, via the offxml file format, the orientations are controlled</span>
<span class="sd">        bondtype the &quot;match&quot; attribute. In this case, only the keywords &quot;once&quot; and</span>
<span class="sd">        &quot;all_permuations&quot; are allowed, meaning only the first orientation or all</span>
<span class="sd">        possible orientations are generated.</span>

<span class="sd">        The virtual site adders via :class:`Molecule` simplify this by optionally using</span>
<span class="sd">        a ``symmetric`` kwarg, which is the equivalent to the XML ``match`` keyword</span>
<span class="sd">        described above. However, the symmetric kwarg is not available for sites</span>
<span class="sd">        which symmetry is not possible, e.g. :class:`TrivalentLonePairVirtualSite`,</span>
<span class="sd">        provided a layer of sanity checking.  For the TIP5 example above, setting</span>
<span class="sd">        ``symmetric=True`` (the default) should automatically produce both particles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List of tuples of ints specifying the ordering of the parent atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orientations</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">particles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Particles owned by this VirtualSite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">vp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_particles</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">vp</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_particles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of particles that the virtual site represents</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Virtual sites can represent multiple particles in a system</span>
        <span class="c1"># Assume a 1 to 1 mapping of orientations to particles for now</span>
        <span class="c1"># This means a virtualsite can only represent a single physical set</span>
        <span class="c1"># of parameters (distance, angle, etc)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_particles</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecule_virtual_site_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index of this VirtualSite within the list of virtual sites within ``Molecule``</span>
<span class="sd">        Note that this can be different from ``particle_index``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if self._topology is None:</span>
        <span class="c1">#    raise ValueError(&#39;This VirtualSite does not belong to a Topology object&#39;)</span>
        <span class="c1"># TODO: This will be slow; can we cache this and update it only when needed?</span>
        <span class="c1">#       Deleting atoms/molecules in the Topology would have to invalidate the cached index.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">virtual_sites</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># @property</span>
    <span class="c1"># def molecule_particle_index(self):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     The index of this VirtualSite within the the list of particles in the parent ``Molecule``.</span>
    <span class="c1">#     Note that this can be different from ``molecule_virtual_site_index``.</span>

    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     if self._molecule is None:</span>
    <span class="c1">#         raise ValueError(</span>
    <span class="c1">#             &#39;This VirtualSite does not belong to a Molecule object&#39;)</span>
    <span class="c1">#     return self._molecule.particles.index(self)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Atoms on whose position this VirtualSite depends.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span>
        <span class="c1"># for atom in self._atoms:</span>
        <span class="c1">#    yield atom</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">charge_increments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Charges taken from this VirtualSite&#39;s atoms and given to the VirtualSite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_charge_increments</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">epsilon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The VdW epsilon term of this VirtualSite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epsilon</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The VdW sigma term of this VirtualSite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigma</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rmin_half</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The VdW rmin_half term of this VirtualSite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rmin</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigma</span>
        <span class="n">rmin_half</span> <span class="o">=</span> <span class="n">rmin</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">rmin_half</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of this VirtualSite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The type of this VirtualSite (returns the class name as string)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">local_frame_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The per-atom weights used to define the virtual site frame.</span>

<span class="sd">        The SMIRNOFF virtual sites use the definition of</span>
<span class="sd">        :class:`openmm.LocalCoordinatesSite` implemented by OpenMM.</span>
<span class="sd">        As such, the weights are used to determine the origin and the x and y axes of</span>
<span class="sd">        the local frame. Since the frame is an orthogonal bases, the z axis is not</span>
<span class="sd">        specified as it is assumed to be the cross of the x and y axes (using a</span>
<span class="sd">        right-handed coordinates).</span>

<span class="sd">        The weights defined refer to the weights of each atom&#39;s positions. For the</span>
<span class="sd">        origin, the weights must sum to 1. For the x and y axes, the weights much each</span>
<span class="sd">        sum to 0. For example, for a custom bond charge virtual site with two atoms:</span>

<span class="sd">        - Origin: [.5, .5] The origin of the frame is always in between atom 1 and</span>
<span class="sd">          atom 2. The calculation is 0.5 * atom1.xyz + 0.5 * atom2.xyz</span>
<span class="sd">        - X-Axis: [-1, 1] The x-axis points from atom 1 to atom 2. Positive</span>
<span class="sd">          displacements of this axis are closer to atom 2.</span>
<span class="sd">        - Y-Axis: [0, 0] This axis must be defined, so here we set it to the null</span>
<span class="sd">          space. Any displacements along y are sent to 0. Because of this, the z-axis</span>
<span class="sd">          will also be 0.</span>

<span class="sd">        The displacements along the axes defined here are defined/returned by</span>
<span class="sd">        :attr:`VirtualSite.local_frame_position`.</span>

<span class="sd">        To implement a new virtual site type (using a LocalCoordinatesSite</span>
<span class="sd">        definition), override this function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple of list of weights used to define the origin, x-axis, and y-axis</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">local_frame_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The displacements of the virtual site relative to the local frame.</span>

<span class="sd">        The SMIRNOFF virtual sites use the definition of</span>
<span class="sd">        :class:`openmm.LocalCoordinatesSite` as implemented by OpenMM.</span>
<span class="sd">        As such, the frame positions refer to positions as defined by the frame, or the</span>
<span class="sd">        local axes defined by the owning atoms (see</span>
<span class="sd">        :attr:`VirtualSite.local_frame_weights`).</span>

<span class="sd">        To implement a new virtual site type (using a LocalCoordinatesSite</span>
<span class="sd">        definition), override this function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.unit.Quantity` of dimension [Length] wrapping a list of</span>
<span class="sd">        displacements in the local frame for the x, y, and z directions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Also include particle_index, which molecule this atom belongs to?</span>
        <span class="k">return</span> <span class="s2">&quot;VirtualSite(name=</span><span class="si">{}</span><span class="s2">, type=</span><span class="si">{}</span><span class="s2">, atoms=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Also include particle_index, which molecule this atom belongs to?</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;VirtualSite name=</span><span class="si">{}</span><span class="s2"> type=</span><span class="si">{}</span><span class="s2"> atoms=</span><span class="si">{}</span><span class="s2"> particles=</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_particles</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_openmm_virtual_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="n">originwt</span><span class="p">,</span> <span class="n">xdir</span><span class="p">,</span> <span class="n">ydir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_frame_weights</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_frame_position</span>

        <span class="k">return</span> <span class="n">LocalCoordinatesSite</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">originwt</span><span class="p">,</span> <span class="n">xdir</span><span class="p">,</span> <span class="n">ydir</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_positions_from_conformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the position of the virtual site particles given an existing conformer</span>
<span class="sd">        owned by the parent molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer_idx : int</span>
<span class="sd">            The index of the conformer in the owning molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.unit.Quantity` of dimension [Length] in unit Angstroms wrapping a</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The positions of the virtual particles belonging to this virtual site.</span>
<span class="sd">            The array is the size (M, 3) where M is the number of virtual particles</span>
<span class="sd">            belonging to this virtual site.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">:</span>
            <span class="n">vp_pos</span> <span class="o">=</span> <span class="n">vp</span><span class="o">.</span><span class="n">compute_position_from_conformer</span><span class="p">(</span><span class="n">conformer_idx</span><span class="p">)</span>
            <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vp_pos</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_positions_from_atom_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_positions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the positions of the virtual site particles given a set of coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom_positions : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The positions of all atoms in the molecule. The array is the size (N, 3)</span>
<span class="sd">            where N is the number of atoms in the molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.unit.Quantity` of dimension [Length] in unit Angstroms wrapping a</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The positions of the virtual particles belonging to this virtual site.</span>
<span class="sd">            The array is the size (M, 3) where M is the number of virtual particles</span>
<span class="sd">            belonging to this virtual site.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">:</span>
            <span class="n">vp_pos</span> <span class="o">=</span> <span class="n">vp</span><span class="o">.</span><span class="n">compute_position_from_atom_positions</span><span class="p">(</span><span class="n">atom_positions</span><span class="p">)</span>
            <span class="n">positions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vp_pos</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BondChargeVirtualSite</span><span class="p">(</span><span class="n">VirtualSite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A particle representing a &quot;Bond Charge&quot;-type virtual site, in which the location of the charge is specified by the positions of two atoms. This supports placement of a virtual site S along a vector between two specified atoms, e.g. to allow for a sigma hole for halogens or similar contexts. With positive values of the distance, the virtual site lies outside the first indexed atom.</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">,</span>
        <span class="n">charge_increments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rmin_half</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orientations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a bond charge-type virtual site, in which the location of the charge is specified by the position of two atoms. This supports placement of a virtual site S along a vector between two specified atoms, e.g. to allow for a sigma hole for halogens or similar contexts. With positive values of the distance, the virtual site lies outside the first indexed atom.</span>

<span class="sd">        TODO: One of the examples in the SMIRNOFF spec has a BondCharge defined with three atoms -- How does that work?</span>
<span class="sd">        https://openforcefield.github.io/standards/standards/smirnoff/#virtualsites-virtual-sites-for-off-atom-charges</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : list of openff.toolkit.topology.molecule.Atom objects of shape [N]</span>
<span class="sd">            The atoms defining the virtual site&#39;s position</span>

<span class="sd">        distance : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a scalar</span>

<span class="sd">        weights : list of floats of shape [N] or None, optional, default=None</span>
<span class="sd">            weights[index] is the weight of particles[index] contributing to the position of the virtual site. Default is None</span>
<span class="sd">        charge_increments : list of floats of shape [N], optional, default=None</span>
<span class="sd">            The amount of charge to remove from the VirtualSite&#39;s atoms and put in the VirtualSite. Indexing in this list should match the ordering in the atoms list. Default is None.</span>
<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        sigma : float, default=None</span>
<span class="sd">            Sigma term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        rmin_half : float</span>
<span class="sd">            Rmin_half term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        name : string or None, default=None</span>
<span class="sd">            The name of this virtual site. Default is None.</span>
<span class="sd">        orientations : list of tuples of 3 Atoms or ints</span>
<span class="sd">            The permutations of the matched atoms that should be used to define</span>
<span class="sd">            the orientation of each virtual site particle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">atoms</span><span class="p">,</span>
            <span class="n">charge_increments</span><span class="o">=</span><span class="n">charge_increments</span><span class="p">,</span>
            <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
            <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
            <span class="n">rmin_half</span><span class="o">=</span><span class="n">rmin_half</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">orientations</span><span class="o">=</span><span class="n">orientations</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">vsite_dict</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantity_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="p">)</span>

        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;orientations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orientations</span>

        <span class="k">return</span> <span class="n">vsite_dict</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">vsite_dict</span><span class="p">):</span>
        <span class="n">base_dict</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">)</span>
        <span class="c1"># Make sure it&#39;s the right type of virtual site</span>
        <span class="k">assert</span> <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;BondChargeVirtualSite&quot;</span>
        <span class="n">base_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">)</span>
        <span class="n">base_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
        <span class="n">vsite</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="o">**</span><span class="n">base_dict</span><span class="p">)</span>
        <span class="n">vsite</span><span class="o">.</span><span class="n">_distance</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">vsite</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The distance parameter of the virtual site&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">local_frame_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local frame weights used to calculate the particle positions.</span>
<span class="sd">        See :attr:`VirtualSite.local_frame_weights` for a general description.</span>

<span class="sd">        Bond charge virtual sites are defined by the axis defined by the two</span>
<span class="sd">        atoms that define the bond. Since the virtual site position is defined</span>
<span class="sd">        solely by this axis, the other y-axis is defined but not used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple of list of weights used to define the origin, x-axis, and y-axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">originwt</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>  <span class="c1"># first atom is origin</span>

        <span class="n">xdir</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>

        <span class="n">ydir</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">originwt</span><span class="p">,</span> <span class="n">xdir</span><span class="p">,</span> <span class="n">ydir</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">local_frame_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The displacements of the virtual site relative to the local frame.</span>
<span class="sd">        See :attr:`VirtualSite.local_frame_position` for a general description.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.unit.Quantity` of dimension [Length] wrapping a list of</span>
<span class="sd">        displacements in the local frame for the x, y, and z directions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># since the origin is atom 1, and xdir is a unit vector pointing</span>
        <span class="c1"># towards the center of the other atoms, we want the</span>
        <span class="c1"># vsite to point away from the unit vector to achieve the desired</span>
        <span class="c1"># distance</span>
        <span class="n">distance_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">unit</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">distance_unit</span> <span class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">distance_unit</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">get_openmm_virtual_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the OpenMM virtual site corresponding to this BondChargeVirtualSite.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : iterable of int</span>
<span class="sd">            The indices of the atoms involved in this virtual site.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.LocalCoordinatesSite`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_openmm_virtual_site</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MonovalentLonePairVirtualSite</span><span class="p">(</span><span class="n">VirtualSite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A particle representing a &quot;Monovalent Lone Pair&quot;-type virtual site, in which the location of the charge is specified by the positions of three atoms. This is originally intended for situations like a carbonyl, and allows placement of a virtual site S at a specified distance d, in_plane_angle, and out_of_plane_angle relative to a central atom and two connected atoms.</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">,</span>
        <span class="n">out_of_plane_angle</span><span class="p">,</span>
        <span class="n">in_plane_angle</span><span class="p">,</span>
        <span class="n">charge_increments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rmin_half</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orientations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a bond charge-type virtual site, in which the location of the charge is specified by the position of three atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : list of three openff.toolkit.topology.molecule.Atom objects</span>
<span class="sd">            The three atoms defining the virtual site&#39;s position</span>

<span class="sd">        distance : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a scalar</span>

<span class="sd">        out_of_plane_angle : :class:`openmm.unit.Quantity` of dimension [Angle] wrapping</span>
<span class="sd">        a scalar</span>

<span class="sd">        in_plane_angle : :class:`openmm.unit.Quantity` of dimension [Angle] wrapping a</span>
<span class="sd">        scalar</span>

<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        sigma : float, default=None</span>
<span class="sd">            Sigma term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        rmin_half : float</span>
<span class="sd">            Rmin_half term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        name : string or None, default=None</span>
<span class="sd">            The name of this virtual site. Default is None.</span>
<span class="sd">        orientations : list of tuples of 3 Atoms or ints</span>
<span class="sd">            The permutations of the matched atoms that should be used to define</span>
<span class="sd">            the orientation of each virtual site particle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># assert isinstance(distance, unit.Quantity)</span>
        <span class="c1"># TODO: Check for proper number of atoms</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">in_plane_angle</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">unit</span><span class="o">.</span><span class="n">degree</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">in_plane_angle</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">out_of_plane_angle</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">unit</span><span class="o">.</span><span class="n">degree</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">out_of_plane_angle</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">atoms</span><span class="p">,</span>
            <span class="n">charge_increments</span><span class="o">=</span><span class="n">charge_increments</span><span class="p">,</span>
            <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
            <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
            <span class="n">rmin_half</span><span class="o">=</span><span class="n">rmin_half</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">orientations</span><span class="o">=</span><span class="n">orientations</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_out_of_plane_angle</span> <span class="o">=</span> <span class="n">out_of_plane_angle</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_plane_angle</span> <span class="o">=</span> <span class="n">in_plane_angle</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">vsite_dict</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantity_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="p">)</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;out_of_plane_angle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantity_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_of_plane_angle</span><span class="p">)</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;in_plane_angle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantity_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_in_plane_angle</span><span class="p">)</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
        <span class="k">return</span> <span class="n">vsite_dict</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">vsite_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new MonovalentLonePairVirtualSite from an serialized dictionary representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vsite_dict : dict</span>
<span class="sd">            The VirtualSite to deserialize.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The newly created MonovalentLonePairVirtualSite</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The function is overridden only to have a custom docstring.</span>
        <span class="n">vsite</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">)</span>
        <span class="n">vsite</span><span class="o">.</span><span class="n">_out_of_plane_angle</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;out_of_plane_angle&quot;</span><span class="p">])</span>
        <span class="n">vsite</span><span class="o">.</span><span class="n">_in_plane_angle</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;in_plane_angle&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">vsite</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The distance parameter of the virtual site&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">in_plane_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The in_plane_angle parameter of the virtual site&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_plane_angle</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_of_plane_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The out_of_plane_angle parameter of the virtual site&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_of_plane_angle</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">local_frame_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local frame weights used to calculate the particle positions.</span>
<span class="sd">        See :attr:`VirtualSite.local_frame_weights` for a general description.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple of list of weights used to define the origin, x-axis, and y-axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">originwt</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

        <span class="n">xdir</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="n">ydir</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">originwt</span><span class="p">,</span> <span class="n">xdir</span><span class="p">,</span> <span class="n">ydir</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">local_frame_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The displacements of the virtual site relative to the local frame.</span>
<span class="sd">        See :attr:`VirtualSite.local_frame_position` for a general description.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.unit.Quantity` of dimension [Length] wrapping a list of displacements</span>
<span class="sd">        in the local frame for the x, y, and z directions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_plane_angle</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">radians</span><span class="p">)</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_of_plane_angle</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">radians</span><span class="p">)</span>

        <span class="n">distance_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">unit</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">distance_unit</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">distance_unit</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">distance_unit</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span>
            <span class="p">],</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">distance_unit</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">get_openmm_virtual_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the OpenMM virtual site corresponding to this</span>
<span class="sd">        MonovalentLonePairVirtualSite.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : iterable of int</span>
<span class="sd">            The indices of the atoms involved in this virtual site.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.LocalCoordinatesSite`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_openmm_virtual_site</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DivalentLonePairVirtualSite</span><span class="p">(</span><span class="n">VirtualSite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A particle representing a &quot;Divalent Lone Pair&quot;-type virtual site, in which the location of the charge is specified by the positions of three atoms. This is suitable for cases like four-point and five-point water models as well as pyrimidine; a charge site S lies a specified distance d from the central atom among three atoms along the bisector of the angle between the atoms (if out_of_plane_angle is zero) or out of the plane by the specified angle (if out_of_plane_angle is nonzero) with its projection along the bisector. For positive values of the distance d the virtual site lies outside the 2-1-3 angle and for negative values it lies inside.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">,</span>
        <span class="n">out_of_plane_angle</span><span class="p">,</span>
        <span class="n">charge_increments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rmin_half</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orientations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a divalent lone pair-type virtual site, in which the location of the charge is specified by the position of three atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : list of 3 openff.toolkit.topology.molecule.Atom objects</span>
<span class="sd">            The three atoms defining the virtual site&#39;s position</span>

<span class="sd">        distance : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a scalar</span>

<span class="sd">        out_of_plane_angle : :class:`openmm.unit.Quantity` of dimension [Angle] wrapping</span>
<span class="sd">        a scalar</span>

<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        sigma : float, default=None</span>
<span class="sd">            Sigma term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        rmin_half : float</span>
<span class="sd">            Rmin_half term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        name : string or None, default=None</span>
<span class="sd">            The name of this virtual site. Default is None.</span>
<span class="sd">        orientations : list of tuples of 3 Atoms or ints</span>
<span class="sd">            The permutations of the matched atoms that should be used to define</span>
<span class="sd">            the orientation of each virtual site particle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">out_of_plane_angle</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">unit</span><span class="o">.</span><span class="n">degree</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">out_of_plane_angle</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">atoms</span><span class="p">,</span>
            <span class="n">charge_increments</span><span class="o">=</span><span class="n">charge_increments</span><span class="p">,</span>
            <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
            <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
            <span class="n">rmin_half</span><span class="o">=</span><span class="n">rmin_half</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">orientations</span><span class="o">=</span><span class="n">orientations</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_out_of_plane_angle</span> <span class="o">=</span> <span class="n">out_of_plane_angle</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">vsite_dict</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantity_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="p">)</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;out_of_plane_angle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantity_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_of_plane_angle</span><span class="p">)</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
        <span class="k">return</span> <span class="n">vsite_dict</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">vsite_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new DivalentLonePairVirtualSite from an serialized dictionary representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vsite_dict : dict</span>
<span class="sd">            The VirtualSite to deserialize.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The newly created DivalentLonePairVirtualSite</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The function is overridden only to have a custom docstring.</span>
        <span class="n">vsite</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">)</span>
        <span class="n">vsite</span><span class="o">.</span><span class="n">_out_of_plane_angle</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;out_of_plane_angle&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">vsite</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The distance parameter of the virtual site&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_of_plane_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The out_of_plane_angle parameter of the virtual site&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_of_plane_angle</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">local_frame_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local frame weights used to calculate the particle positions.</span>
<span class="sd">        See :attr:`VirtualSite.local_frame_weights` for a general description.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple of list of weights used to define the origin, x-axis, and y-axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">originwt</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

        <span class="n">xdir</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
        <span class="n">ydir</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">originwt</span><span class="p">,</span> <span class="n">xdir</span><span class="p">,</span> <span class="n">ydir</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">local_frame_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The displacements of the virtual site relative to the local frame.</span>
<span class="sd">        See :attr:`VirtualSite.local_frame_position` for a general description.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.unit.Quantity` of dimension [Length] wrapping a list of</span>
<span class="sd">        displacements in the local frame for the x, y, and z directions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_of_plane_angle</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">radians</span><span class="p">)</span>

        <span class="n">distance_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">unit</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">distance_unit</span> <span class="o">*</span> <span class="p">[</span>
            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">distance_unit</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span>
            <span class="mf">0.0</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">distance_unit</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span>
        <span class="p">]</span>  <span class="c1"># pos of the vsite in local crds</span>
        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">get_openmm_virtual_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the OpenMM virtual site corresponding to this</span>
<span class="sd">        DivalentLonePairVirtualSite.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : iterable of int</span>
<span class="sd">            The indices of the atoms involved in this virtual site.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.LocalCoordinatesSite`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_openmm_virtual_site</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TrivalentLonePairVirtualSite</span><span class="p">(</span><span class="n">VirtualSite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A particle representing a &quot;Trivalent Lone Pair&quot;-type virtual site, in which the location of the charge is specified by the positions of four atoms. This is suitable for planar or tetrahedral nitrogen lone pairs; a charge site S lies above the central atom (e.g. nitrogen a distance d along the vector perpendicular to the plane of the three connected atoms (2,3,4). With positive values of d the site lies above the nitrogen and with negative values it lies below the nitrogen.</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">,</span>
        <span class="n">charge_increments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rmin_half</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orientations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a trivalent lone pair-type virtual site, in which the location of the charge is specified by the position of four atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : list of 4 openff.toolkit.topology.molecule.Atom objects</span>
<span class="sd">            The three atoms defining the virtual site&#39;s position</span>

<span class="sd">        distance : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a scalar</span>

<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        sigma : float, default=None</span>
<span class="sd">            Sigma term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        rmin_half : float</span>
<span class="sd">            Rmin_half term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        name : string or None, default=None</span>
<span class="sd">            The name of this virtual site. Default is None.</span>
<span class="sd">        orientations : list of tuples of 3 Atoms or ints</span>
<span class="sd">            The permutations of the matched atoms that should be used to define</span>
<span class="sd">            the orientation of each virtual site particle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">atoms</span><span class="p">,</span>
            <span class="n">charge_increments</span><span class="o">=</span><span class="n">charge_increments</span><span class="p">,</span>
            <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
            <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
            <span class="n">rmin_half</span><span class="o">=</span><span class="n">rmin_half</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">orientations</span><span class="o">=</span><span class="n">orientations</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">vsite_dict</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantity_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="p">)</span>
        <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
        <span class="k">return</span> <span class="n">vsite_dict</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">vsite_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new TrivalentPairVirtualSite from an serialized dictionary representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vsite_dict : dict</span>
<span class="sd">            The VirtualSite to deserialize.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The newly created TrivalentLonePairVirtualSite</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The function is overridden only to have a custom docstring.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The distance parameter of the virtual site&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">local_frame_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local frame weights used to calculate the particle positions.</span>
<span class="sd">        See :attr:`VirtualSite.local_frame_weights` for a general description.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple of list of weights used to define the origin, x-axis, and y-axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">originwt</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

        <span class="n">xdir</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">]</span>

        <span class="c1"># ydir does not matter</span>
        <span class="n">ydir</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">originwt</span><span class="p">,</span> <span class="n">xdir</span><span class="p">,</span> <span class="n">ydir</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">local_frame_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The displacements of the virtual site relative to the local frame.</span>
<span class="sd">        See :attr:`VirtualSite.local_frame_position` for a general description.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.unit.Quantity` of dimension [Length] wrapping a list of</span>
<span class="sd">        displacements in the local frame for the x, y, and z directions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">distance_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">unit</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span>
            <span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">distance_unit</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="n">distance_unit</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">get_openmm_virtual_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the OpenMM virtual site corresponding to this</span>
<span class="sd">        TrivalentLonePairVirtualSite.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : iterable of int</span>
<span class="sd">            The indices of the atoms involved in this virtual site.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.LocalCoordinatesSite`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_openmm_virtual_site</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>


<span class="c1"># =============================================================================================</span>
<span class="c1"># Bond Stereochemistry</span>
<span class="c1"># =============================================================================================</span>

<span class="c1"># class BondStereochemistry(Serializable):</span>
<span class="c1"># &quot;&quot;&quot;</span>
<span class="c1"># Bond stereochemistry representation</span>
<span class="c1"># &quot;&quot;&quot;</span>
<span class="c1"># def __init__(self, stereo_type, neighbor1, neighbor2):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#    Parameters</span>
<span class="c1">#    ----------</span>
<span class="c1">#    stereo_type</span>
<span class="c1">#    neighbor1</span>
<span class="c1">#    neighbor2</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    assert isinstance(neighbor1, Atom)</span>
<span class="c1">#    assert isinstance(neighbor2, Atom)</span>
<span class="c1">#    # Use stereo_type @setter to check stereo type is a permitted value</span>
<span class="c1">#    self.stereo_type = stereo_type</span>
<span class="c1">#    self._neighbor1 = neighbor1</span>
<span class="c1">#    self._neighbor2 = neighbor2</span>

<span class="c1"># def to_dict(self):</span>
<span class="c1">#    bs_dict = OrderedDict()</span>
<span class="c1">#    bs_dict[&#39;stereo_type&#39;] = self._stereo_type</span>
<span class="c1">#    bs_dict[&#39;neighbor1_index&#39;] = self._neighbor1.molecule_atom_index</span>
<span class="c1">#    bs_dict[&#39;neighbor2_index&#39;] = self._neighbor2.molecule_atom_index</span>
<span class="c1">#    return bs_dict</span>

<span class="c1"># classmethod</span>
<span class="c1"># def from_dict(cls, molecule, bs_dict):</span>
<span class="c1">#    neighbor1 = molecule.atoms[bs_dict[&#39;neighbor1_index&#39;]]</span>
<span class="c1">#    neighbor2 = molecule.atoms[bs_dict[&#39;neighbor2_index&#39;]]</span>
<span class="c1">#    return cls.__init__(bs_dict[&#39;stereo_type&#39;], neighbor1, neighbor2)</span>

<span class="c1"># @property</span>
<span class="c1"># def stereo_type(self):</span>
<span class="c1">#    return self._stereo_type</span>

<span class="c1"># @stereo_type.setter</span>
<span class="c1"># def stereo_type(self, value):</span>
<span class="c1">#    assert (value == &#39;CIS&#39;) or (value == &#39;TRANS&#39;) or (value is None)</span>
<span class="c1">#    self._stereo_type = value</span>

<span class="c1"># @property</span>
<span class="c1"># def neighbor1(self):</span>
<span class="c1">#    return self._neighbor1</span>

<span class="c1"># @property</span>
<span class="c1"># def neighbor2(self):</span>
<span class="c1">#    return self._neighbor2</span>

<span class="c1"># @property</span>
<span class="c1"># def neighbors(self):</span>
<span class="c1">#    return (self._neighbor1, self._neighbor2)</span>

<span class="c1"># =============================================================================================</span>
<span class="c1"># Bond</span>
<span class="c1"># =============================================================================================</span>


<span class="k">class</span> <span class="nc">Bond</span><span class="p">(</span><span class="n">Serializable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Chemical bond representation.</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>

<span class="sd">    .. todo :: Allow bonds to have associated properties.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    atom1, atom2 : openff.toolkit.topology.Atom</span>
<span class="sd">        Atoms involved in the bond</span>
<span class="sd">    bondtype : int</span>
<span class="sd">        Discrete bond type representation for the Open Forcefield aromaticity model</span>
<span class="sd">        TODO: Do we want to pin ourselves to a single standard aromaticity model?</span>
<span class="sd">    type : str</span>
<span class="sd">        String based bond type</span>
<span class="sd">    order : int</span>
<span class="sd">        Integral bond order</span>
<span class="sd">    fractional_bond_order : float, optional</span>
<span class="sd">        Fractional bond order, or None.</span>


<span class="sd">    .. warning :: This API is experimental and subject to change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atom1</span><span class="p">,</span>
        <span class="n">atom2</span><span class="p">,</span>
        <span class="n">bond_order</span><span class="p">,</span>
        <span class="n">is_aromatic</span><span class="p">,</span>
        <span class="n">fractional_bond_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">stereochemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new chemical bond.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span> <span class="o">==</span> <span class="n">Atom</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span> <span class="o">==</span> <span class="n">Atom</span>
        <span class="k">assert</span> <span class="n">atom1</span><span class="o">.</span><span class="n">molecule</span> <span class="ow">is</span> <span class="n">atom2</span><span class="o">.</span><span class="n">molecule</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">molecule</span><span class="p">,</span> <span class="n">FrozenMolecule</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">molecule</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_atom1</span> <span class="o">=</span> <span class="n">atom1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atom2</span> <span class="o">=</span> <span class="n">atom2</span>

        <span class="n">atom1</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">atom2</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># TODO: Check bondtype and fractional_bond_order are valid?</span>
        <span class="c1"># TODO: Dative bonds</span>
        <span class="c1"># self._type = bondtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fractional_bond_order</span> <span class="o">=</span> <span class="n">fractional_bond_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bond_order</span> <span class="o">=</span> <span class="n">bond_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_aromatic</span> <span class="o">=</span> <span class="n">is_aromatic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span> <span class="o">=</span> <span class="n">stereochemistry</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dict representation of the bond.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bond_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">molecule_atom_index</span>
        <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">molecule_atom_index</span>
        <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;bond_order&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bond_order</span>
        <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_aromatic</span>
        <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span>
        <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;fractional_bond_order&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractional_bond_order</span>
        <span class="k">return</span> <span class="n">bond_dict</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">molecule</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a Bond from a dict representation.&quot;&quot;&quot;</span>
        <span class="c1"># TODO</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">molecule</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;atom1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;atom1&quot;</span><span class="p">]]</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;atom2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;atom2&quot;</span><span class="p">]]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atom1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atom2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom1_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atom1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom2_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atom2</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atom1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atom2</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bond_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bond_order</span>

    <span class="nd">@bond_order</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bond_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bond_order</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fractional_bond_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractional_bond_order</span>

    <span class="nd">@fractional_bond_order</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fractional_bond_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fractional_bond_order</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stereochemistry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_aromatic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_aromatic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span>

    <span class="nd">@molecule</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the Bond&#39;s parent molecule. Can not be changed after assignment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecule_bond_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index of this Bond within the the list of bonds in ``Molecules``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This Atom does not belong to a Molecule object&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_in_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether or not this bond is in a ring(s) (of any size)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotAttachedToMoleculeError</span><span class="p">(</span>
                <span class="s2">&quot;This Bond does not belong to a Molecule object&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">rings</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">molecule_atom_index</span> <span class="ow">in</span> <span class="n">ring</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">molecule_atom_index</span> <span class="ow">in</span> <span class="n">ring</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Bond(atom1 index=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1_index</span><span class="si">}</span><span class="s2">, atom2 index=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atom2_index</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&lt;Bond atom1 index=&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1_index</span><span class="si">}</span><span class="s2">&#39;, atom2 index=&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atom2_index</span><span class="si">}</span><span class="s2">&#39;&gt;&quot;</span>
        <span class="p">)</span>


<span class="c1"># =============================================================================================</span>
<span class="c1"># Molecule</span>
<span class="c1"># =============================================================================================</span>

<span class="c1"># TODO: How do we automatically trigger invalidation of cached properties if an ``Atom``, ``Bond``, or ``VirtualSite`` is modified,</span>
<span class="c1">#       rather than added/deleted via the API? The simplest resolution is simply to make them immutable.</span>


<span class="k">class</span> <span class="nc">FrozenMolecule</span><span class="p">(</span><span class="n">Serializable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Immutable chemical representation of a molecule, such as a small molecule or biopolymer.</span>

<span class="sd">    .. todo :: What other API calls would be useful for supporting biopolymers</span>
<span class="sd">               as small molecules? Perhaps iterating over chains and residues?</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Create a molecule from a sdf file</span>

<span class="sd">    &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">    &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">    &gt;&gt;&gt; molecule = FrozenMolecule.from_file(sdf_filepath)</span>

<span class="sd">    Convert to OpenEye OEMol object</span>

<span class="sd">    &gt;&gt;&gt; oemol = molecule.to_openeye()</span>

<span class="sd">    Create a molecule from an OpenEye molecule</span>

<span class="sd">    &gt;&gt;&gt; molecule = FrozenMolecule.from_openeye(oemol)</span>

<span class="sd">    Convert to RDKit Mol object</span>

<span class="sd">    &gt;&gt;&gt; rdmol = molecule.to_rdkit()</span>

<span class="sd">    Create a molecule from an RDKit molecule</span>

<span class="sd">    &gt;&gt;&gt; molecule = FrozenMolecule.from_rdkit(rdmol)</span>

<span class="sd">    Create a molecule from IUPAC name (requires the OpenEye toolkit)</span>

<span class="sd">    &gt;&gt;&gt; molecule = FrozenMolecule.from_iupac(&#39;imatinib&#39;)</span>

<span class="sd">    Create a molecule from SMILES</span>

<span class="sd">    &gt;&gt;&gt; molecule = FrozenMolecule.from_smiles(&#39;Cc1ccccc1&#39;)</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">file_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new FrozenMolecule object</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * If a filename or file-like object is specified but the file</span>
<span class="sd">             contains more than one molecule, what is the proper behavior?</span>
<span class="sd">             Read just the first molecule, or raise an exception if more</span>
<span class="sd">             than one molecule is found?</span>

<span class="sd">           * Should we also support SMILES strings or IUPAC names for</span>
<span class="sd">             ``other``\ ?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : optional, default=None</span>
<span class="sd">            If specified, attempt to construct a copy of the Molecule from</span>
<span class="sd">            the specified object. This can be any one of the following:</span>

<span class="sd">            * a :class:`Molecule` object</span>
<span class="sd">            * a file that can be used to construct a :class:`Molecule` object</span>
<span class="sd">            * an ``openeye.oechem.OEMol``</span>
<span class="sd">            * an ``rdkit.Chem.rdchem.Mol``</span>
<span class="sd">            * a serialized :class:`Molecule` object</span>

<span class="sd">        file_format : str, optional, default=None</span>
<span class="sd">            If providing a file-like object, you must specify the format</span>
<span class="sd">            of the data. If providing a file, the file format will attempt</span>
<span class="sd">            to be guessed from the suffix.</span>
<span class="sd">        toolkit_registry : a :class:`ToolkitRegistry` or</span>
<span class="sd">            :class:`ToolkitWrapper` object, optional,</span>
<span class="sd">            default=GLOBAL_TOOLKIT_REGISTRY :class:`ToolkitRegistry`</span>
<span class="sd">            or :class:`ToolkitWrapper` to use for I/O operations</span>
<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If loaded from a file and ``False``, raises an exception if</span>
<span class="sd">            undefined stereochemistry is detected during the molecule&#39;s</span>
<span class="sd">            construction.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create an empty molecule:</span>

<span class="sd">        &gt;&gt;&gt; empty_molecule = FrozenMolecule()</span>

<span class="sd">        Create a molecule from a file that can be used to construct a molecule,</span>
<span class="sd">        using either a filename or file-like object:</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = FrozenMolecule(sdf_filepath)</span>
<span class="sd">        &gt;&gt;&gt; molecule = FrozenMolecule(open(sdf_filepath, &#39;r&#39;), file_format=&#39;sdf&#39;)</span>

<span class="sd">        &gt;&gt;&gt; import gzip</span>
<span class="sd">        &gt;&gt;&gt; mol2_gz_filepath = get_data_file_path(&#39;molecules/toluene.mol2.gz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = FrozenMolecule(gzip.GzipFile(mol2_gz_filepath, &#39;r&#39;), file_format=&#39;mol2&#39;)</span>

<span class="sd">        Create a molecule from another molecule:</span>

<span class="sd">        &gt;&gt;&gt; molecule_copy = FrozenMolecule(molecule)</span>

<span class="sd">        Convert to OpenEye OEMol object</span>

<span class="sd">        &gt;&gt;&gt; oemol = molecule.to_openeye()</span>

<span class="sd">        Create a molecule from an OpenEye molecule:</span>

<span class="sd">        &gt;&gt;&gt; molecule = FrozenMolecule(oemol)</span>

<span class="sd">        Convert to RDKit Mol object</span>

<span class="sd">        &gt;&gt;&gt; rdmol = molecule.to_rdkit()</span>

<span class="sd">        Create a molecule from an RDKit molecule:</span>

<span class="sd">        &gt;&gt;&gt; molecule = FrozenMolecule(rdmol)</span>

<span class="sd">        Create a molecule from a serialized molecule object:</span>

<span class="sd">        &gt;&gt;&gt; serialized_molecule = molecule.__getstate__()</span>
<span class="sd">        &gt;&gt;&gt; molecule_copy = Molecule(serialized_molecule)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_smiles</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Figure out if toolkit_registry is a whole registry, or just a single wrapper</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">toolkit_registry</span> <span class="o">=</span> <span class="n">ToolkitRegistry</span><span class="p">(</span><span class="n">toolkit_precedence</span><span class="o">=</span><span class="p">[])</span>
            <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">add_toolkit</span><span class="p">(</span><span class="n">toolkit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;toolkit_registry&#39; must be either a ToolkitRegistry or a ToolkitWrapper&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loaded</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Start a list of the ValueErrors the following logic encounters, so we can print it out</span>
            <span class="c1"># if there turned out to be no way to load this input</span>
            <span class="n">value_errors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">openff</span><span class="o">.</span><span class="n">toolkit</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">FrozenMolecule</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="n">loaded</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_copy_initializer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">openff</span><span class="o">.</span><span class="n">toolkit</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">Molecule</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">loaded</span><span class="p">):</span>
                <span class="c1"># TODO: This will need to be updated once FrozenMolecules and Molecules are significantly different</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_copy_initializer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">loaded</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Check through the toolkit registry to find a compatible wrapper for loading</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">loaded</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Each ToolkitWrapper may provide a from_object method, which turns some particular type(s)</span>
                    <span class="c1"># of object into OFFMols. For example, RDKitToolkitWrapper&#39;s from_object method will</span>
                    <span class="c1"># return an OFFMol if provided with an RDMol, or raise a ValueError if it is provided</span>
                    <span class="c1"># an OEMol (or anything else). This makes the assumption that any non-ValueError errors raised</span>
                    <span class="c1"># by the toolkit _really are_ bad and should be raised immediately, which may be a bad assumption.</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                        <span class="s2">&quot;from_object&quot;</span><span class="p">,</span>
                        <span class="n">other</span><span class="p">,</span>
                        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                        <span class="n">raise_exception_types</span><span class="o">=</span><span class="p">[</span><span class="n">UndefinedStereochemistryError</span><span class="p">],</span>
                        <span class="n">_cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="c1"># NotImplementedError should never be raised... Only from_file and from_file_obj are provided</span>
                <span class="c1"># in the base ToolkitWrapper class and require overwriting, so from_object should be excluded</span>
                <span class="c1"># except NotImplementedError as e:</span>
                <span class="c1">#    raise e</span>
                <span class="c1"># The toolkit registry will aggregate all errors except UndefinedStereochemistryErrors into a single</span>
                <span class="c1"># ValueError, which we should catch and and store that here.</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">value_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_copy_initializer</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                    <span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># TODO: Make this compatible with file-like objects (I couldn&#39;t figure out how to make an oemolistream</span>
            <span class="c1"># from a fileIO object)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;read&quot;</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">loaded</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mol</span> <span class="o">=</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span>
                        <span class="n">other</span><span class="p">,</span>
                        <span class="n">file_format</span><span class="o">=</span><span class="n">file_format</span><span class="p">,</span>
                        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span><span class="p">,</span>
                        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                    <span class="p">)</span>  <span class="c1"># returns a list only if multiple molecules are found</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Specified file or file-like object must contain exactly one molecule&quot;</span>
                        <span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">value_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_copy_initializer</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
                    <span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># If none of the above methods worked, raise a ValueError summarizing the</span>
            <span class="c1"># errors from the different loading attempts</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">loaded</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot construct openff.toolkit.topology.Molecule from </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">other</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">value_error</span> <span class="ow">in</span> <span class="n">value_errors</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value_error</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_unique_atom_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the molecule has unique atom names, False otherwise.&quot;&quot;&quot;</span>
        <span class="n">unique_atom_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_atom_names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">generate_unique_atom_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate unique atom names using element name and number of times that element has occurred</span>
<span class="sd">        e.g. &#39;C1x&#39;, &#39;H1x&#39;, &#39;O1x&#39;, &#39;C2x&#39;, ...</span>

<span class="sd">        The character &#39;x&#39; is appended to these generated names to reduce the odds that they clash with an atom name or</span>
<span class="sd">        type imported from another source.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

        <span class="n">element_counts</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">symbol</span>
            <span class="n">element_counts</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># TODO: It may be worth exposing this as a user option, i.e. to avoid multiple ligands</span>
            <span class="c1"># parameterized with OpenFF clashing because they have atom names like O1x, H3x, etc.</span>
            <span class="c1"># i.e. an optional argument could enable a user to `generate_unique_atom_names(blah=&quot;y&quot;)</span>
            <span class="c1"># to have one ligand be O1y, etc.</span>
            <span class="c1"># https://github.com/openforcefield/openff-toolkit/pull/1096#pullrequestreview-767227391</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">symbol</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">element_counts</span><span class="p">[</span><span class="n">symbol</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;x&quot;</span>

    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate the molecule, ensuring it has unique atom names</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_unique_atom_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generate_unique_atom_names</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">strip_atom_stereochemistry</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">smarts</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete stereochemistry information for certain atoms, if it is present.</span>
<span class="sd">        This method can be used to &quot;normalize&quot; molecules imported from different cheminformatics</span>
<span class="sd">        toolkits, which differ in which atom centers are considered stereogenic.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        smarts: str or ChemicalEnvironment</span>
<span class="sd">            Tagged SMARTS with a single atom with index 1. Any matches for this atom will have any assigned</span>
<span class="sd">            stereocheistry information removed.</span>
<span class="sd">        toolkit_registry : a :class:`ToolkitRegistry` or :class:`ToolkitWrapper` object, optional, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for I/O operations</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openff.toolkit.typing.chemistry.environment</span> <span class="kn">import</span> <span class="n">AtomChemicalEnvironment</span>

        <span class="n">chem_env</span> <span class="o">=</span> <span class="n">AtomChemicalEnvironment</span><span class="p">(</span><span class="n">smarts</span><span class="p">)</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_environment_matches</span><span class="p">(</span>
            <span class="n">chem_env</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">matches</span><span class="p">):</span>
            <span class="n">atom_idx</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom_idx</span><span class="p">]</span><span class="o">.</span><span class="n">stereochemistry</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">####################################################################################################</span>
    <span class="c1"># Safe serialization</span>
    <span class="c1">####################################################################################################</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary representation of the molecule.</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * Document the representation standard.</span>
<span class="sd">           * How do we do version control with this standard?</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule_dict : OrderedDict</span>
<span class="sd">            A dictionary representation of the molecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openff.toolkit.utils.utils</span> <span class="kn">import</span> <span class="n">serialize_numpy</span>

        <span class="n">molecule_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
        <span class="c1">## From Jeff: If we go the properties-as-dict route, then _properties should, at</span>
        <span class="c1">## the top level, be a dict. Should we go through recursively and ensure all values are dicts too?</span>
        <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">]</span>
        <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;virtual_sites&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">vsite</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">vsite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span>
        <span class="p">]</span>
        <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;bonds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="p">]</span>
        <span class="c1"># TODO: Charges</span>
        <span class="c1"># TODO: Properties</span>
        <span class="c1"># From Jeff: We could have the onerous requirement that all &quot;properties&quot; have to_dict() functions.</span>
        <span class="c1"># Or we could restrict properties to simple stuff (ints, strings, floats, and the like)</span>
        <span class="c1"># Or pickle anything unusual</span>
        <span class="c1"># Or not allow user-defined properties at all (just use our internal _cached_properties)</span>
        <span class="c1"># molecule_dict[&#39;properties&#39;] = dict([(key, value._to_dict()) for key.value in self._properties])</span>
        <span class="c1"># TODO: Assuming &quot;simple stuff&quot; properties right now, figure out a better standard</span>
        <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_cached_properties&quot;</span><span class="p">):</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;cached_properties&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_properties</span>
        <span class="c1"># TODO: Conformers</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;conformers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;conformers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">molecule_dict</span><span class="p">[</span>
                <span class="s2">&quot;conformers_unit&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;angstrom&quot;</span>  <span class="c1"># Have this defined as a class variable?</span>
            <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span><span class="p">:</span>
                <span class="n">conf_unitless</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>
                <span class="n">conf_serialized</span><span class="p">,</span> <span class="n">conf_shape</span> <span class="o">=</span> <span class="n">serialize_numpy</span><span class="p">((</span><span class="n">conf_unitless</span><span class="p">))</span>
                <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;conformers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conf_serialized</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charges_unit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">charges_unitless</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span>
                <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span>
            <span class="p">)</span>
            <span class="n">charges_serialized</span><span class="p">,</span> <span class="n">charges_shape</span> <span class="o">=</span> <span class="n">serialize_numpy</span><span class="p">(</span><span class="n">charges_unitless</span><span class="p">)</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">charges_serialized</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charges_unit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;elementary_charge&quot;</span>

        <span class="k">return</span> <span class="n">molecule_dict</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a hash of this molecule. Used when checking molecule uniqueness in Topology creation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_smiles</span><span class="p">())</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">molecule_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Molecule from a dictionary representation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule_dict : OrderedDict</span>
<span class="sd">            A dictionary representation of the molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : Molecule</span>
<span class="sd">            A Molecule created from the dictionary representation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This implementation is a compromise to let this remain as a classmethod</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">_initialize_from_dict</span><span class="p">(</span><span class="n">molecule_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span>

    <span class="k">def</span> <span class="nf">_initialize_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize this Molecule from a dictionary representation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule_dict : OrderedDict</span>
<span class="sd">            A dictionary representation of the molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Provide useful exception messages if there are any failures</span>
        <span class="kn">from</span> <span class="nn">openff.toolkit.utils.utils</span> <span class="kn">import</span> <span class="n">deserialize_numpy</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">atom_dict</span> <span class="ow">in</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_atom</span><span class="p">(</span><span class="o">**</span><span class="n">atom_dict</span><span class="p">)</span>

        <span class="c1"># Handle virtual site unit reattachment and molecule tagging</span>
        <span class="k">for</span> <span class="n">vsite_dict</span> <span class="ow">in</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;virtual_sites&quot;</span><span class="p">]:</span>
            <span class="n">vsite_dict_units</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">)</span>

            <span class="c1"># Attach units to epsilon term</span>
            <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;epsilon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;epsilon&quot;</span><span class="p">])</span>
            <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">])</span>
            <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;charge_increments&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span>
                <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;charge_increments&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;orientations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;orientations&quot;</span><span class="p">]</span>

            <span class="c1"># Call the correct molecule._add_X_virtual_site function, based on the stated type</span>
            <span class="c1"># Also generate the Atom objects from the atom indices</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]]</span>
            <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span>
            <span class="k">if</span> <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;BondChargeVirtualSite&quot;</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">]</span>
                <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span>
                    <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_bond_charge_virtual_site</span><span class="p">(</span><span class="o">**</span><span class="n">vsite_dict_units</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;MonovalentLonePairVirtualSite&quot;</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">]</span>
                <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span>
                    <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;in_plane_angle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span>
                    <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;in_plane_angle&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;out_of_plane_angle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span>
                    <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;out_of_plane_angle&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_monovalent_lone_pair_virtual_site</span><span class="p">(</span><span class="o">**</span><span class="n">vsite_dict_units</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;DivalentLonePairVirtualSite&quot;</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">]</span>
                <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span>
                    <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;out_of_plane_angle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span>
                    <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;out_of_plane_angle&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_divalent_lone_pair_virtual_site</span><span class="p">(</span><span class="o">**</span><span class="n">vsite_dict_units</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;TrivalentLonePairVirtualSite&quot;</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">]</span>
                <span class="n">vsite_dict_units</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_to_quantity</span><span class="p">(</span>
                    <span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_trivalent_lone_pair_virtual_site</span><span class="p">(</span><span class="o">**</span><span class="n">vsite_dict_units</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;Vsite type </span><span class="si">{}</span><span class="s2"> not recognized&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vsite_dict</span><span class="p">[</span><span class="s2">&quot;vsite_type&quot;</span><span class="p">])</span>
                <span class="p">)</span>

        <span class="k">for</span> <span class="n">bond_dict</span> <span class="ow">in</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;bonds&quot;</span><span class="p">]:</span>
            <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom1&quot;</span><span class="p">])</span>
            <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom2&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_bond</span><span class="p">(</span><span class="o">**</span><span class="n">bond_dict</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charges&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">charges_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,)</span>
            <span class="n">partial_charges_unitless</span> <span class="o">=</span> <span class="n">deserialize_numpy</span><span class="p">(</span>
                <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charges&quot;</span><span class="p">],</span> <span class="n">charges_shape</span>
            <span class="p">)</span>
            <span class="n">pc_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charges_unit&quot;</span><span class="p">])</span>
            <span class="n">partial_charges</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">partial_charges_unitless</span><span class="p">,</span> <span class="n">pc_unit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="o">=</span> <span class="n">partial_charges</span>

        <span class="k">if</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;conformers&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ser_conf</span> <span class="ow">in</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;conformers&quot;</span><span class="p">]:</span>
                <span class="c1"># TODO: Update to use string_to_quantity</span>
                <span class="n">conformers_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">conformer_unitless</span> <span class="o">=</span> <span class="n">deserialize_numpy</span><span class="p">(</span><span class="n">ser_conf</span><span class="p">,</span> <span class="n">conformers_shape</span><span class="p">)</span>
                <span class="n">c_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;conformers_unit&quot;</span><span class="p">])</span>
                <span class="n">conformer</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">conformer_unitless</span><span class="p">,</span> <span class="n">c_unit</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a summary of this molecule; SMILES if valid, Hill formula if not.&quot;&quot;&quot;</span>
        <span class="n">description</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Molecule with name &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_smiles</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">hill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_hill_formula</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">description</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; with bad SMILES and Hill formula &#39;</span><span class="si">{</span><span class="n">hill</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="k">return</span> <span class="n">description</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; and SMILES &#39;</span><span class="si">{</span><span class="n">smiles</span><span class="si">}</span><span class="s2">&#39;&quot;</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_from_dict</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear the contents of the current molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># List of bonds between Atom objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Attached properties to be preserved</span>
        <span class="c1"># self._cached_properties = None # Cached properties (such as partial charges) can be recomputed as needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Optional conformers</span>

    <span class="k">def</span> <span class="nf">_copy_initializer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy contents of the specified molecule</span>

<span class="sd">        .. todo :: Should this be a ``@staticmethod`` where we have an explicit copy constructor?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : optional</span>
<span class="sd">            Overwrite the state of this FrozenMolecule with the specified FrozenMolecule object.</span>
<span class="sd">            A deep copy is made.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># assert isinstance(other, type(self)), &quot;can only copy instances of {}&quot;.format(type(self))</span>

        <span class="c1"># Run a deepcopy here so that items that were _always_ dict (like other.properties) will</span>
        <span class="c1"># not have any references to the old molecule</span>
        <span class="n">other_dict</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_from_dict</span><span class="p">(</span><span class="n">other_dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test two molecules for equality to see if they are the chemical species, but do not check other annotated properties.</span>

<span class="sd">        .. note ::</span>

<span class="sd">           Note that this method simply tests whether two molecules are identical chemical species using equivalence of their canonical isomeric SMILES.</span>
<span class="sd">           No effort is made to ensure that the atoms are in the same order or that any annotated properties are preserved.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># updated to use the new isomorphic checking method, with full matching</span>
        <span class="c1"># TODO the doc string did not match the previous function what matching should this method do?</span>
        <span class="k">return</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">are_isomorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">return_atom_map</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">to_smiles</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">isomeric</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">explicit_hydrogens</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">mapped</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a canonical isomeric SMILES representation of the current molecule.</span>
<span class="sd">        A partially mapped smiles can also be generated for atoms of interest by supplying an `atom_map` to the</span>
<span class="sd">        properties dictionary.</span>

<span class="sd">        .. note :: RDKit and OpenEye versions will not necessarily return the same representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        isomeric: bool optional, default= True</span>
<span class="sd">            return an isomeric smiles</span>
<span class="sd">        explicit_hydrogens: bool optional, default=True</span>
<span class="sd">            return a smiles string containing all hydrogens explicitly</span>
<span class="sd">        mapped: bool optional, default=False</span>
<span class="sd">            return a explicit hydrogen mapped smiles, the atoms to be mapped can be controlled by supplying an</span>
<span class="sd">            atom map into the properties dictionary. If no mapping is passed all atoms will be mapped in order, else</span>
<span class="sd">            an atom map dictionary from the current atom index to the map id should be supplied with no duplicates.</span>
<span class="sd">            The map ids (values) should start from 0 or 1.</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMILES conversion</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smiles : str</span>
<span class="sd">            Canonical isomeric explicit-hydrogen SMILES</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule(sdf_filepath)</span>
<span class="sd">        &gt;&gt;&gt; smiles = molecule.to_smiles()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize cached_smiles dict for this molecule if none exists</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cached_smiles</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Figure out which toolkit should be used to create the SMILES</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">to_smiles_method</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="s2">&quot;to_smiles&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">to_smiles_method</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">to_smiles</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to to_smiles. Expected ToolkitRegistry or ToolkitWrapper. Got  </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Get a string representation of the function containing the toolkit name so we can check</span>
        <span class="c1"># if a SMILES was already cached for this molecule. This will return, for example</span>
        <span class="c1"># &quot;RDKitToolkitWrapper.to_smiles&quot;</span>
        <span class="n">smiles_hash</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">to_smiles_method</span><span class="o">.</span><span class="vm">__qualname__</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">isomeric</span><span class="p">)</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">explicit_hydrogens</span><span class="p">)</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mapped</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">smiles_hash</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;atom_map&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="c1"># Check to see if a SMILES for this molecule was already cached using this method</span>
        <span class="k">if</span> <span class="n">smiles_hash</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_smiles</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_smiles</span><span class="p">[</span><span class="n">smiles_hash</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">to_smiles_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isomeric</span><span class="p">,</span> <span class="n">explicit_hydrogens</span><span class="p">,</span> <span class="n">mapped</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cached_smiles</span><span class="p">[</span><span class="n">smiles_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">smiles</span>
            <span class="k">return</span> <span class="n">smiles</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_inchi</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">inchi</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a Molecule from a InChI representation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inchi : str</span>
<span class="sd">            The InChI representation of the molecule.</span>

<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            Whether to accept InChI with undefined stereochemistry. If False,</span>
<span class="sd">            an exception will be raised if a InChI with undefined stereochemistry</span>
<span class="sd">            is passed into this function.</span>

<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for InChI-to-molecule conversion</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Make cis-1,2-Dichloroethene:</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_inchi(&#39;InChI=1S/C2H2Cl2/c3-1-2-4/h1-2H/b2-1-&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;from_inchi&quot;</span><span class="p">,</span>
                <span class="n">inchi</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_inchi</span><span class="p">(</span>
                <span class="n">inchi</span><span class="p">,</span> <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to from_inchi. Expected ToolkitRegistry or ToolkitWrapper. Got  </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">molecule</span>

    <span class="k">def</span> <span class="nf">to_inchi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_hydrogens</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an InChI string for the molecule using the requested toolkit backend.</span>
<span class="sd">        InChI is a standardised representation that does not capture tautomers unless specified using the fixed hydrogen</span>
<span class="sd">        layer.</span>

<span class="sd">        For information on InChi see here https://iupac.org/who-we-are/divisions/division-details/inchi/</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fixed_hydrogens: bool, default=False</span>
<span class="sd">            If a fixed hydrogen layer should be added to the InChI, if `True` this will produce a non standard specific</span>
<span class="sd">            InChI string of the molecule.</span>

<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for molecule-to-InChI conversion</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        inchi: str</span>
<span class="sd">            The InChI string of the molecule.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        InvalidToolkitRegistryError</span>
<span class="sd">             If an invalid object is passed as the toolkit_registry parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">inchi</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;to_inchi&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">fixed_hydrogens</span><span class="o">=</span><span class="n">fixed_hydrogens</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">inchi</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">to_inchi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_hydrogens</span><span class="o">=</span><span class="n">fixed_hydrogens</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to to_inchi. Expected ToolkitRegistry or ToolkitWrapper. Got  </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">inchi</span>

    <span class="k">def</span> <span class="nf">to_inchikey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fixed_hydrogens</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an InChIKey for the molecule using the requested toolkit backend.</span>
<span class="sd">        InChIKey is a standardised representation that does not capture tautomers unless specified using the fixed hydrogen</span>
<span class="sd">        layer.</span>

<span class="sd">        For information on InChi see here https://iupac.org/who-we-are/divisions/division-details/inchi/</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fixed_hydrogens: bool, default=False</span>
<span class="sd">            If a fixed hydrogen layer should be added to the InChI, if `True` this will produce a non standard specific</span>
<span class="sd">            InChI string of the molecule.</span>

<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for molecule-to-InChIKey conversion</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        inchi_key: str</span>
<span class="sd">            The InChIKey representation of the molecule.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        InvalidToolkitRegistryError</span>
<span class="sd">             If an invalid object is passed as the toolkit_registry parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">inchi_key</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;to_inchikey&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">fixed_hydrogens</span><span class="o">=</span><span class="n">fixed_hydrogens</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">inchi_key</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">to_inchikey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_hydrogens</span><span class="o">=</span><span class="n">fixed_hydrogens</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to to_inchikey. Expected ToolkitRegistry or ToolkitWrapper. Got  </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">inchi_key</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_smiles</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">smiles</span><span class="p">,</span>
        <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a Molecule from a SMILES representation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        smiles : str</span>
<span class="sd">            The SMILES representation of the molecule.</span>
<span class="sd">        hydrogens_are_explicit : bool, default = False</span>
<span class="sd">            If False, the cheminformatics toolkit will perform hydrogen addition</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMILES-to-molecule conversion</span>
<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            Whether to accept SMILES with undefined stereochemistry. If False,</span>
<span class="sd">            an exception will be raised if a SMILES with undefined stereochemistry</span>
<span class="sd">            is passed into this function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;Cc1ccccc1&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;from_smiles&quot;</span><span class="p">,</span>
                <span class="n">smiles</span><span class="p">,</span>
                <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="n">hydrogens_are_explicit</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_smiles</span><span class="p">(</span>
                <span class="n">smiles</span><span class="p">,</span>
                <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="n">hydrogens_are_explicit</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to from_smiles. Expected ToolkitRegistry or ToolkitWrapper. Got  </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">molecule</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">are_isomorphic</span><span class="p">(</span>
        <span class="n">mol1</span><span class="p">,</span>
        <span class="n">mol2</span><span class="p">,</span>
        <span class="n">return_atom_map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">aromatic_matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">formal_charge_matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">bond_order_matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">atom_stereochemistry_matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">bond_stereochemistry_matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">strip_pyrimidal_n_atom_stereo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines whether the two molecules are isomorphic by comparing their graph representations and the chosen</span>
<span class="sd">        node/edge attributes. Minimally connections and atomic_number are checked.</span>

<span class="sd">        If nx.Graphs() are given they must at least have atomic_number attributes on nodes.</span>
<span class="sd">        other optional attributes for nodes are: is_aromatic, formal_charge and stereochemistry.</span>
<span class="sd">        optional attributes for edges are: is_aromatic, bond_order and stereochemistry.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mol1 : an openff.toolkit.topology.molecule.FrozenMolecule or TopologyMolecule or nx.Graph()</span>
<span class="sd">        mol2 : an openff.toolkit.topology.molecule.FrozenMolecule or TopologyMolecule or nx.Graph()</span>
<span class="sd">            The molecule to test for isomorphism.</span>

<span class="sd">        return_atom_map: bool, default=False, optional</span>
<span class="sd">            will return an optional dict containing the atomic mapping.</span>

<span class="sd">        aromatic_matching: bool, default=True, optional</span>
<span class="sd">            compare the aromatic attributes of bonds and atoms.</span>

<span class="sd">        formal_charge_matching: bool, default=True, optional</span>
<span class="sd">            compare the formal charges attributes of the atoms.</span>

<span class="sd">        bond_order_matching: bool, deafult=True, optional</span>
<span class="sd">            compare the bond order on attributes of the bonds.</span>

<span class="sd">        atom_stereochemistry_matching : bool, default=True, optional</span>
<span class="sd">            If ``False``, atoms&#39; stereochemistry is ignored for the</span>
<span class="sd">            purpose of determining equality.</span>

<span class="sd">        bond_stereochemistry_matching : bool, default=True, optional</span>
<span class="sd">            If ``False``, bonds&#39; stereochemistry is ignored for the</span>
<span class="sd">            purpose of determining equality.</span>

<span class="sd">        strip_pyrimidal_n_atom_stereo: bool, default=True, optional</span>
<span class="sd">            If ``True``, any stereochemistry defined around pyrimidal</span>
<span class="sd">            nitrogen stereocenters will be disregarded in the isomorphism</span>
<span class="sd">            check.</span>

<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for</span>
<span class="sd">            removing stereochemistry from pyrimidal nitrogens.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecules_are_isomorphic : bool</span>

<span class="sd">        atom_map : default=None, Optional,</span>
<span class="sd">            [Dict[int,int]] ordered by mol1 indexing {mol1_index: mol2_index}</span>
<span class="sd">            If molecules are not isomorphic given input arguments, will return None instead of dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Do a quick hill formula check first</span>
        <span class="k">if</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">_object_to_hill_formula</span><span class="p">(</span><span class="n">mol1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">_object_to_hill_formula</span><span class="p">(</span>
            <span class="n">mol2</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># Build the user defined matching functions</span>
        <span class="k">def</span> <span class="nf">node_match_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="c1"># always match by atleast atomic number</span>
            <span class="n">is_equal</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;atomic_number&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;atomic_number&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">aromatic_matching</span><span class="p">:</span>
                <span class="n">is_equal</span> <span class="o">&amp;=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">formal_charge_matching</span><span class="p">:</span>
                <span class="n">is_equal</span> <span class="o">&amp;=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;formal_charge&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;formal_charge&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">atom_stereochemistry_matching</span><span class="p">:</span>
                <span class="n">is_equal</span> <span class="o">&amp;=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">is_equal</span>

        <span class="c1"># check if we want to do any bond matching if not the function is None</span>
        <span class="k">if</span> <span class="n">aromatic_matching</span> <span class="ow">or</span> <span class="n">bond_order_matching</span> <span class="ow">or</span> <span class="n">bond_stereochemistry_matching</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">edge_match_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="c1"># We don&#39;t need to check the exact bond order (which is 1 or 2)</span>
                <span class="c1"># if the bond is aromatic. This way we avoid missing a match only</span>
                <span class="c1"># if the alternate bond orders 1 and 2 are assigned differently.</span>
                <span class="k">if</span> <span class="n">aromatic_matching</span> <span class="ow">and</span> <span class="n">bond_order_matching</span><span class="p">:</span>
                    <span class="n">is_equal</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span>
                        <span class="n">x</span><span class="p">[</span><span class="s2">&quot;bond_order&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;bond_order&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">aromatic_matching</span><span class="p">:</span>
                    <span class="n">is_equal</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">bond_order_matching</span><span class="p">:</span>
                    <span class="n">is_equal</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;bond_order&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;bond_order&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">is_equal</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">bond_stereochemistry_matching</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_equal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">is_equal</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">is_equal</span> <span class="o">&amp;=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">is_equal</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_match_func</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Here we should work out what data type we have, also deal with lists?</span>
        <span class="k">def</span> <span class="nf">to_networkx</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;For the given data type, return the networkx graph&quot;&quot;&quot;</span>
            <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

            <span class="kn">from</span> <span class="nn">openff.toolkit.topology</span> <span class="kn">import</span> <span class="n">TopologyMolecule</span>

            <span class="k">if</span> <span class="n">strip_pyrimidal_n_atom_stereo</span><span class="p">:</span>
                <span class="n">SMARTS</span> <span class="o">=</span> <span class="s2">&quot;[N+0X3:1](-[*])(-[*])(-[*])&quot;</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">FrozenMolecule</span><span class="p">):</span>
                <span class="c1"># Molecule class instance</span>
                <span class="k">if</span> <span class="n">strip_pyrimidal_n_atom_stereo</span><span class="p">:</span>
                    <span class="c1"># Make a copy of the molecule so we don&#39;t modify the original</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">strip_atom_stereochemistry</span><span class="p">(</span>
                        <span class="n">SMARTS</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">TopologyMolecule</span><span class="p">):</span>
                <span class="c1"># TopologyMolecule class instance</span>
                <span class="k">if</span> <span class="n">strip_pyrimidal_n_atom_stereo</span><span class="p">:</span>
                    <span class="c1"># Make a copy of the molecule so we don&#39;t modify the original</span>
                    <span class="n">ref_mol</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">reference_molecule</span><span class="p">)</span>
                    <span class="n">ref_mol</span><span class="o">.</span><span class="n">strip_atom_stereochemistry</span><span class="p">(</span>
                        <span class="n">SMARTS</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">ref_mol</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">data</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The input type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not supported,&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;please supply an openff.toolkit.topology.molecule.Molecule,&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;openff.toolkit.topology.topology.TopologyMolecule or networkx.Graph &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;representation of the molecule.&quot;</span>
                <span class="p">)</span>

        <span class="n">mol1_netx</span> <span class="o">=</span> <span class="n">to_networkx</span><span class="p">(</span><span class="n">mol1</span><span class="p">)</span>
        <span class="n">mol2_netx</span> <span class="o">=</span> <span class="n">to_networkx</span><span class="p">(</span><span class="n">mol2</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">networkx.algorithms.isomorphism</span> <span class="kn">import</span> <span class="n">GraphMatcher</span>  <span class="c1"># type: ignore</span>

        <span class="n">GM</span> <span class="o">=</span> <span class="n">GraphMatcher</span><span class="p">(</span>
            <span class="n">mol1_netx</span><span class="p">,</span> <span class="n">mol2_netx</span><span class="p">,</span> <span class="n">node_match</span><span class="o">=</span><span class="n">node_match_func</span><span class="p">,</span> <span class="n">edge_match</span><span class="o">=</span><span class="n">edge_match_func</span>
        <span class="p">)</span>
        <span class="n">isomorphic</span> <span class="o">=</span> <span class="n">GM</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">isomorphic</span> <span class="ow">and</span> <span class="n">return_atom_map</span><span class="p">:</span>
            <span class="n">topology_atom_map</span> <span class="o">=</span> <span class="n">GM</span><span class="o">.</span><span class="n">mapping</span>

            <span class="c1"># reorder the mapping by keys</span>
            <span class="n">sorted_mapping</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">topology_atom_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">sorted_mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">topology_atom_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">isomorphic</span><span class="p">,</span> <span class="n">sorted_mapping</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">isomorphic</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">is_isomorphic_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the molecule is isomorphic with the other molecule which can be an openff.toolkit.topology.Molecule,</span>
<span class="sd">        or TopologyMolecule or nx.Graph(). Full matching is done using the options described bellow.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: openff.toolkit.topology.Molecule or TopologyMolecule or nx.Graph()</span>

<span class="sd">        return_atom_map: bool, default=False, optional</span>
<span class="sd">            will return an optional dict containing the atomic mapping.</span>

<span class="sd">        aromatic_matching: bool, default=True, optional</span>
<span class="sd">        compare the aromatic attributes of bonds and atoms.</span>

<span class="sd">        formal_charge_matching: bool, default=True, optional</span>
<span class="sd">        compare the formal charges attributes of the atoms.</span>

<span class="sd">        bond_order_matching: bool, deafult=True, optional</span>
<span class="sd">        compare the bond order on attributes of the bonds.</span>

<span class="sd">        atom_stereochemistry_matching : bool, default=True, optional</span>
<span class="sd">            If ``False``, atoms&#39; stereochemistry is ignored for the</span>
<span class="sd">            purpose of determining equality.</span>

<span class="sd">        bond_stereochemistry_matching : bool, default=True, optional</span>
<span class="sd">            If ``False``, bonds&#39; stereochemistry is ignored for the</span>
<span class="sd">            purpose of determining equality.</span>

<span class="sd">        strip_pyrimidal_n_atom_stereo: bool, default=True, optional</span>
<span class="sd">            If ``True``, any stereochemistry defined around pyrimidal</span>
<span class="sd">            nitrogen stereocenters will be disregarded in the isomorphism</span>
<span class="sd">            check.</span>

<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for</span>
<span class="sd">            removing stereochemistry from pyrimidal nitrogens.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        isomorphic : bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">are_isomorphic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">return_atom_map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">aromatic_matching</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;aromatic_matching&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
            <span class="n">formal_charge_matching</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;formal_charge_matching&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
            <span class="n">bond_order_matching</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bond_order_matching&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
            <span class="n">atom_stereochemistry_matching</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;atom_stereochemistry_matching&quot;</span><span class="p">,</span> <span class="kc">True</span>
            <span class="p">),</span>
            <span class="n">bond_stereochemistry_matching</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;bond_stereochemistry_matching&quot;</span><span class="p">,</span> <span class="kc">True</span>
            <span class="p">),</span>
            <span class="n">strip_pyrimidal_n_atom_stereo</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;strip_pyrimidal_n_atom_stereo&quot;</span><span class="p">,</span> <span class="kc">True</span>
            <span class="p">),</span>
            <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;toolkit_registry&quot;</span><span class="p">,</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">),</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">generate_conformers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">n_conformers</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">rms_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">clear_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate conformers for this molecule using an underlying toolkit.</span>

<span class="sd">        If ``n_conformers=0``, no toolkit wrapper will be called. If ``n_conformers=0``</span>
<span class="sd">        and ``clear_existing=True``, ``molecule.conformers`` will be set to ``None``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMILES-to-molecule conversion</span>
<span class="sd">        n_conformers : int, default=1</span>
<span class="sd">            The maximum number of conformers to produce</span>
<span class="sd">        rms_cutoff : openmm.unit.Quantity-wrapped float, in units of distance, optional, default=None</span>
<span class="sd">            The minimum RMS value at which two conformers are considered redundant and one is deleted. Precise</span>
<span class="sd">            implementation of this cutoff may be toolkit-dependent. If ``None``, the cutoff is set to be the default value</span>
<span class="sd">            for each ``ToolkitWrapper`` (generally 1 Angstrom).</span>
<span class="sd">        clear_existing : bool, default=True</span>
<span class="sd">            Whether to overwrite existing conformers for the molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;CCCCCC&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule.generate_conformers()</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        InvalidToolkitRegistryError</span>
<span class="sd">            If an invalid object is passed as the toolkit_registry parameter</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no conformers are requested, do not call to a ToolkitWrapper at all</span>
        <span class="k">if</span> <span class="n">n_conformers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">clear_existing</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;generate_conformers&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">n_conformers</span><span class="o">=</span><span class="n">n_conformers</span><span class="p">,</span>
                <span class="n">rms_cutoff</span><span class="o">=</span><span class="n">rms_cutoff</span><span class="p">,</span>
                <span class="n">clear_existing</span><span class="o">=</span><span class="n">clear_existing</span><span class="p">,</span>
                <span class="n">raise_exception_types</span><span class="o">=</span><span class="p">[],</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="k">return</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">generate_conformers</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">n_conformers</span><span class="o">=</span><span class="n">n_conformers</span><span class="p">,</span>
                <span class="n">rms_cutoff</span><span class="o">=</span><span class="n">rms_cutoff</span><span class="p">,</span>
                <span class="n">clear_existing</span><span class="o">=</span><span class="n">clear_existing</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to generate_conformers. Expected ToolkitRegistry or ToolkitWrapper. Got  </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_virtual_site_positions_from_conformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the position of all virtual sites given an existing</span>
<span class="sd">        conformer specified by its index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer_idx : int</span>
<span class="sd">            The index of the conformer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.unit.Quantity` of dimension [Length] in unit Angstroms wrapping a</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The positions of the virtual particles belonging to this virtual site.</span>
<span class="sd">            The array is the size (M, 3) where M is the number of virtual particles</span>
<span class="sd">            belonging to this virtual site.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">atom_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span><span class="p">[</span><span class="n">conformer_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_virtual_site_positions_from_atom_positions</span><span class="p">(</span><span class="n">atom_positions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_virtual_site_positions_from_atom_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_positions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the positions of the virtual sites in this molecule given a set of</span>
<span class="sd">        external coordinates. The coordinates do not need come from an internal</span>
<span class="sd">        conformer, but are assumed to have the same shape and be in the same order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom_positions : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The positions of all atoms in the molecule. The array is the size (N, 3)</span>
<span class="sd">            where N is the number of atoms in the molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`openmm.unit.Quantity` of dimension [Length] in unit Angstroms wrapping a</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The positions of the virtual particles belonging to this virtual site.</span>
<span class="sd">            The array is the size (M, 3) where M is the number of virtual particles</span>
<span class="sd">            belonging to this virtual site.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">vsite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_sites</span><span class="p">:</span>
            <span class="n">vsite_pos</span> <span class="o">=</span> <span class="n">vsite</span><span class="o">.</span><span class="n">compute_positions_from_atom_positions</span><span class="p">(</span><span class="n">atom_positions</span><span class="p">)</span>
            <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vsite_pos</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply_elf_conformer_selection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">percentage</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span><span class="n">ToolkitRegistry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies the `ELF method</span>
<span class="sd">        &lt;https://docs.eyesopen.com/toolkits/python/quacpactk/molchargetheory.html#elf-conformer-selection&gt;`_</span>
<span class="sd">        to select a set of diverse conformers which have minimal</span>
<span class="sd">        electrostatically strongly interacting functional groups from a</span>
<span class="sd">        molecules conformers.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * The input molecule should have a large set of conformers already</span>
<span class="sd">          generated to select the ELF conformers from.</span>
<span class="sd">        * The selected conformers will be retained in the `conformers` list</span>
<span class="sd">          while unselected conformers will be discarded.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        OpenEyeToolkitWrapper.apply_elf_conformer_selection</span>
<span class="sd">        RDKitToolkitWrapper.apply_elf_conformer_selection</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        toolkit_registry</span>
<span class="sd">            The underlying toolkit to use to select the ELF conformers.</span>
<span class="sd">        percentage</span>
<span class="sd">            The percentage of conformers with the lowest electrostatic</span>
<span class="sd">            interaction energies to greedily select from.</span>
<span class="sd">        limit</span>
<span class="sd">            The maximum number of conformers to select.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;apply_elf_conformer_selection&quot;</span><span class="p">,</span>
                <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">percentage</span><span class="o">=</span><span class="n">percentage</span><span class="p">,</span>
                <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">toolkit</span><span class="o">.</span><span class="n">apply_elf_conformer_selection</span><span class="p">(</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentage</span><span class="o">=</span><span class="n">percentage</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid toolkit_registry passed to apply_elf_conformer_selection.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Expected ToolkitRegistry or ToolkitWrapper. Got &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_partial_charges_am1bcc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">use_conformers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">strict_n_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate partial atomic charges for this molecule using AM1-BCC run by an underlying toolkit</span>
<span class="sd">        and assign them to this molecule&#39;s ``partial_charges`` attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strict_n_conformers : bool, default=False</span>
<span class="sd">            Whether to raise an exception if an invalid number of conformers is provided for the given charge method.</span>
<span class="sd">            If this is False and an invalid number of conformers is found, a warning will be raised.</span>
<span class="sd">        use_conformers : iterable of openmm.unit.Quantity-wrapped numpy arrays, each with shape (n_atoms, 3) and dimension of distance. Optional, default=None</span>
<span class="sd">            Coordinates to use for partial charge calculation.</span>
<span class="sd">            If None, an appropriate number of conformers for the given charge method will be generated.</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for the calculation</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;CCCCCC&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule.generate_conformers()</span>
<span class="sd">        &gt;&gt;&gt; molecule.compute_partial_charges_am1bcc()</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        InvalidToolkitRegistryError</span>
<span class="sd">            If an invalid object is passed as the toolkit_registry parameter</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assign_partial_charges</span><span class="p">(</span>
            <span class="n">partial_charge_method</span><span class="o">=</span><span class="s2">&quot;am1bcc&quot;</span><span class="p">,</span>
            <span class="n">use_conformers</span><span class="o">=</span><span class="n">use_conformers</span><span class="p">,</span>
            <span class="n">strict_n_conformers</span><span class="o">=</span><span class="n">strict_n_conformers</span><span class="p">,</span>
            <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">assign_partial_charges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">partial_charge_method</span><span class="p">,</span>
        <span class="n">strict_n_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_conformers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">normalize_partial_charges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate partial atomic charges for this molecule using an underlying toolkit, and assign</span>
<span class="sd">        the new values to the partial_charges attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        partial_charge_method : string</span>
<span class="sd">            The partial charge calculation method to use for partial charge calculation.</span>
<span class="sd">        strict_n_conformers : bool, default=False</span>
<span class="sd">            Whether to raise an exception if an invalid number of conformers is provided for the given charge method.</span>
<span class="sd">            If this is False and an invalid number of conformers is found, a warning will be raised.</span>
<span class="sd">        use_conformers : iterable of openmm.unit.Quantity-wrapped numpy arrays, each with shape (n_atoms, 3) and dimension of distance. Optional, default=None</span>
<span class="sd">            Coordinates to use for partial charge calculation. If None, an appropriate number of conformers will be generated.</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for the calculation.</span>
<span class="sd">        normalize_partial_charges : bool, default=True</span>
<span class="sd">            Whether to offset partial charges so that they sum to the total formal charge of the molecule.</span>
<span class="sd">            This is used to prevent accumulation of rounding errors when the partial charge assignment method</span>
<span class="sd">            returns values at limited precision.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;CCCCCC&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule.assign_partial_charges(&#39;am1-mulliken&#39;)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        InvalidToolkitRegistryError</span>
<span class="sd">            If an invalid object is passed as the toolkit_registry parameter</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="c1"># We may need to try several toolkitwrappers to find one</span>
            <span class="c1"># that supports the desired partial charge method, so we</span>
            <span class="c1"># tell the ToolkitRegistry to continue trying ToolkitWrappers</span>
            <span class="c1"># if one raises an error (raise_exception_types=[])</span>
            <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;assign_partial_charges&quot;</span><span class="p">,</span>
                <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">partial_charge_method</span><span class="o">=</span><span class="n">partial_charge_method</span><span class="p">,</span>
                <span class="n">use_conformers</span><span class="o">=</span><span class="n">use_conformers</span><span class="p">,</span>
                <span class="n">strict_n_conformers</span><span class="o">=</span><span class="n">strict_n_conformers</span><span class="p">,</span>
                <span class="n">normalize_partial_charges</span><span class="o">=</span><span class="n">normalize_partial_charges</span><span class="p">,</span>
                <span class="n">raise_exception_types</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">toolkit</span><span class="o">.</span><span class="n">assign_partial_charges</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">partial_charge_method</span><span class="o">=</span><span class="n">partial_charge_method</span><span class="p">,</span>
                <span class="n">use_conformers</span><span class="o">=</span><span class="n">use_conformers</span><span class="p">,</span>
                <span class="n">strict_n_conformers</span><span class="o">=</span><span class="n">strict_n_conformers</span><span class="p">,</span>
                <span class="n">normalize_partial_charges</span><span class="o">=</span><span class="n">normalize_partial_charges</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid toolkit_registry passed to assign_partial_charges.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Expected ToolkitRegistry or ToolkitWrapper. Got  </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_normalize_partial_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add offsets to each partial charge to ensure that they sum to the formal charge of the molecule,</span>
<span class="sd">        to the limit of a python float&#39;s precision. Modifies the partial charges in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expected_charge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_charge</span>

        <span class="n">current_charge</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span>
        <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_charges</span><span class="p">:</span>
            <span class="n">current_charge</span> <span class="o">+=</span> <span class="n">pc</span>

        <span class="n">charge_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">expected_charge</span> <span class="o">-</span> <span class="n">current_charge</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">partial_charges</span> <span class="o">+=</span> <span class="n">charge_offset</span>

    <span class="k">def</span> <span class="nf">assign_fractional_bond_orders</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bond_order_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">use_conformers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update and store list of bond orders this molecule. Bond orders are stored on each</span>
<span class="sd">        bond, in the ``bond.fractional_bond_order`` attribute.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMILES-to-molecule conversion</span>
<span class="sd">        bond_order_model : string, optional. Default=None</span>
<span class="sd">            The bond order model to use for fractional bond order calculation. If ``None``, &quot;am1-wiberg&quot; will be used.</span>
<span class="sd">        use_conformers : iterable of openmm.unit.Quantity(np.array) with shape (n_atoms, 3) and dimension of distance, optional, default=None</span>
<span class="sd">            The conformers to use for fractional bond order calculation. If ``None``, an appropriate number</span>
<span class="sd">            of conformers will be generated by an available ToolkitWrapper.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;CCCCCC&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule.assign_fractional_bond_orders()</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        InvalidToolkitRegistryError</span>
<span class="sd">            If an invalid object is passed as the toolkit_registry parameter</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;assign_fractional_bond_orders&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">bond_order_model</span><span class="o">=</span><span class="n">bond_order_model</span><span class="p">,</span>
                <span class="n">use_conformers</span><span class="o">=</span><span class="n">use_conformers</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="k">return</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">assign_fractional_bond_orders</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">bond_order_model</span><span class="o">=</span><span class="n">bond_order_model</span><span class="p">,</span> <span class="n">use_conformers</span><span class="o">=</span><span class="n">use_conformers</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid toolkit_registry passed to assign_fractional_bond_orders. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Expected ToolkitRegistry or ToolkitWrapper. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_invalidate_cached_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicate that the chemical entity has been altered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if hasattr(self, &#39;_cached_properties&#39;):</span>
        <span class="c1">#    delattr(self, &#39;_cached_properties&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_propers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_smiles</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># TODO: Clear fractional bond orders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rings</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">to_networkx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a NetworkX undirected graph from the Molecule.</span>

<span class="sd">        Nodes are Atoms labeled with particle indices and atomic elements (via the ``element`` node atrribute).</span>
<span class="sd">        Edges denote chemical bonds between Atoms.</span>
<span class="sd">        Virtual sites are not included, since they lack a concept of chemical connectivity.</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * Do we need a ``from_networkx()`` method? If so, what would the Graph be required to provide?</span>
<span class="sd">           * Should edges be labeled with discrete bond types in some aromaticity model?</span>
<span class="sd">           * Should edges be labeled with fractional bond order if a method is specified?</span>
<span class="sd">           * Should we add other per-atom and per-bond properties (e.g. partial charges) if present?</span>
<span class="sd">           * Can this encode bond/atom chirality?</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        graph : networkx.Graph</span>
<span class="sd">            The resulting graph, with nodes (atoms) labeled with atom indices, elements, stereochemistry and aromaticity</span>
<span class="sd">            flags and bonds with two atom indices, bond order, stereochemistry, and aromaticity flags</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Retrieve the bond graph for imatinib (OpenEye toolkit required)</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;imatinib&#39;)</span>
<span class="sd">        &gt;&gt;&gt; nxgraph = molecule.to_networkx()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">,</span>
                <span class="n">atomic_number</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">,</span>
                <span class="n">is_aromatic</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">is_aromatic</span><span class="p">,</span>
                <span class="n">stereochemistry</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">stereochemistry</span><span class="p">,</span>
                <span class="n">formal_charge</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">formal_charge</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># G.add_node(atom.molecule_atom_index, attr_dict={&#39;atomic_number&#39;: atom.atomic_number})</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span>
                <span class="n">bond</span><span class="o">.</span><span class="n">atom1_index</span><span class="p">,</span>
                <span class="n">bond</span><span class="o">.</span><span class="n">atom2_index</span><span class="p">,</span>
                <span class="n">bond_order</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">bond_order</span><span class="p">,</span>
                <span class="n">is_aromatic</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">is_aromatic</span><span class="p">,</span>
                <span class="n">stereochemistry</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">stereochemistry</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># G.add_edge(bond.atom1_index, bond.atom2_index, attr_dict={&#39;order&#39;:bond.bond_order})</span>

        <span class="k">return</span> <span class="n">G</span>

    <span class="k">def</span> <span class="nf">find_rotatable_bonds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ignore_functional_groups</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all bonds classed as rotatable ignoring any matched to the ``ignore_functional_groups`` list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignore_functional_groups: optional, List[str], default=None,</span>
<span class="sd">            A list of bond SMARTS patterns to be ignored when finding rotatable bonds.</span>

<span class="sd">        toolkit_registry: openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMARTS matching</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bonds: List[openff.toolkit.topology.molecule.Bond]</span>
<span class="sd">            The list of openff.toolkit.topology.molecule.Bond instances which are rotatable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># general rotatable bond smarts taken from RDKit</span>
        <span class="c1"># https://github.com/rdkit/rdkit/blob/1bf6ef3d65f5c7b06b56862b3fb9116a3839b229/rdkit/Chem/Lipinski.py#L47%3E</span>
        <span class="n">rotatable_bond_smarts</span> <span class="o">=</span> <span class="s2">&quot;[!$(*#*)&amp;!D1:1]-&amp;!@[!$(*#*)&amp;!D1:2]&quot;</span>

        <span class="c1"># get all of the general matches</span>
        <span class="n">general_matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_environment_matches</span><span class="p">(</span>
            <span class="n">query</span><span class="o">=</span><span class="n">rotatable_bond_smarts</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span>
        <span class="p">)</span>

        <span class="c1"># this will give all forwards and backwards matches, so condense them down with this function</span>
        <span class="k">def</span> <span class="nf">condense_matches</span><span class="p">(</span><span class="n">matches</span><span class="p">):</span>
            <span class="n">condensed_matches</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                <span class="n">condensed_matches</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">m</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">condensed_matches</span>

        <span class="n">general_bonds</span> <span class="o">=</span> <span class="n">condense_matches</span><span class="p">(</span><span class="n">general_matches</span><span class="p">)</span>

        <span class="c1"># now refine the list using the ignore groups</span>
        <span class="k">if</span> <span class="n">ignore_functional_groups</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">matches_to_ignore</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="c1"># make ignore_functional_groups an iterable object</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ignore_functional_groups</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">ignore_functional_groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">ignore_functional_groups</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">iter</span><span class="p">(</span><span class="n">ignore_functional_groups</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">ignore_functional_groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">ignore_functional_groups</span><span class="p">]</span>

            <span class="c1"># find the functional groups to remove</span>
            <span class="k">for</span> <span class="n">functional_group</span> <span class="ow">in</span> <span class="n">ignore_functional_groups</span><span class="p">:</span>
                <span class="c1"># note I run the searches through this function so they have to be SMIRKS?</span>
                <span class="n">ignore_matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_environment_matches</span><span class="p">(</span>
                    <span class="n">query</span><span class="o">=</span><span class="n">functional_group</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span>
                <span class="p">)</span>
                <span class="n">ignore_matches</span> <span class="o">=</span> <span class="n">condense_matches</span><span class="p">(</span><span class="n">ignore_matches</span><span class="p">)</span>
                <span class="c1"># add the new matches to the matches to ignore</span>
                <span class="n">matches_to_ignore</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ignore_matches</span><span class="p">)</span>

            <span class="c1"># now remove all the matches</span>
            <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches_to_ignore</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">general_bonds</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
                <span class="c1"># if the key is not in the list, the ignore pattern was not valid</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">continue</span>

        <span class="c1"># gather a list of bond instances to return</span>
        <span class="n">rotatable_bonds</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bond_between</span><span class="p">(</span><span class="o">*</span><span class="n">bond</span><span class="p">)</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">general_bonds</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rotatable_bonds</span>

    <span class="k">def</span> <span class="nf">_add_atom</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">atomic_number</span><span class="p">,</span> <span class="n">formal_charge</span><span class="p">,</span> <span class="n">is_aromatic</span><span class="p">,</span> <span class="n">stereochemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an atom</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atomic_number : int</span>
<span class="sd">            Atomic number of the atom</span>
<span class="sd">        formal_charge : int</span>
<span class="sd">            Formal charge of the atom</span>
<span class="sd">        is_aromatic : bool</span>
<span class="sd">            If True, atom is aromatic; if False, not aromatic</span>
<span class="sd">        stereochemistry : str, optional, default=None</span>
<span class="sd">            Either &#39;R&#39; or &#39;S&#39; for specified stereochemistry, or None if stereochemistry is irrelevant</span>
<span class="sd">        name : str, optional, default=None</span>
<span class="sd">            An optional name for the atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the atom in the molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Define a methane molecule</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule()</span>
<span class="sd">        &gt;&gt;&gt; molecule.name = &#39;methane&#39;</span>
<span class="sd">        &gt;&gt;&gt; C = molecule.add_atom(6, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H1 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H2 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H3 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H4 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H1, False, 1)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H2, False, 1)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H3, False, 1)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H4, False, 1)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create an atom</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span>
            <span class="n">atomic_number</span><span class="p">,</span>
            <span class="n">formal_charge</span><span class="p">,</span>
            <span class="n">is_aromatic</span><span class="p">,</span>
            <span class="n">stereochemistry</span><span class="o">=</span><span class="n">stereochemistry</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="c1"># self._particles.append(atom)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalidate_cached_properties</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_virtual_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vsite</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">replaced</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">existing_vsite</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span><span class="p">):</span>
            <span class="n">same_vsite</span> <span class="o">=</span> <span class="n">existing_vsite</span> <span class="o">==</span> <span class="n">vsite</span>
            <span class="k">if</span> <span class="n">same_vsite</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vsite</span>
                    <span class="n">replaced</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;Attempted to add the new virtual site:</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;to molecule: </span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">Another vsite with the same type &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;already exists and replace=False. Existing vsite &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;is:</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vsite</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">existing_vsite</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">replaced</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vsite</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">vsite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_bond_charge_virtual_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a bond charge-type virtual site, in which the location of the charge is specified by the position of two</span>
<span class="sd">        atoms. This supports placement of a virtual site S along a vector between two specified atoms, e.g. to allow</span>
<span class="sd">        for a sigma hole for halogens or similar contexts. With positive values of the distance, the virtual site lies</span>
<span class="sd">        outside the first indexed atom.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : list of openff.toolkit.topology.molecule.Atom objects of shape [N]</span>
<span class="sd">            The atoms defining the virtual site&#39;s position</span>

<span class="sd">        distance : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a scalar</span>

<span class="sd">        charge_increments : list of floats of shape [N], optional, default=None</span>
<span class="sd">            The amount of charge to remove from the VirtualSite&#39;s atoms and put in the VirtualSite. Indexing in this</span>
<span class="sd">            list should match the ordering in the atoms list. Default is None.</span>
<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        sigma : float, default=None</span>
<span class="sd">            Sigma term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        rmin_half : float</span>
<span class="sd">            Rmin_half term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        name : string or None, default=None</span>
<span class="sd">            The name of this virtual site. Default is None.</span>
<span class="sd">        orientations : list of int 2-tuples</span>
<span class="sd">            The orientations that should be used to create the virtual site.</span>
<span class="sd">            Each orientation corresponds to an individual virtual particle.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the newly-added virtual site in the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">replace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">vsite</span> <span class="o">=</span> <span class="n">BondChargeVirtualSite</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_virtual_site</span><span class="p">(</span><span class="n">vsite</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">vsite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_monovalent_lone_pair_virtual_site</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">out_of_plane_angle</span><span class="p">,</span> <span class="n">in_plane_angle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a bond charge-type virtual site, in which the location of the charge is specified by the position of</span>
<span class="sd">        three atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : list of three :class:`openff.toolkit.topology.molecule.Atom` objects</span>
<span class="sd">            The three atoms defining the virtual site&#39;s position</span>

<span class="sd">        distance : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a scalar</span>

<span class="sd">        out_of_plane_angle : :class:`openmm.unit.Quantity` of dimension [Angle] wrapping</span>
<span class="sd">        a scalar</span>

<span class="sd">        in_plane_angle : :class:`openmm.unit.Quantity` of dimension [Angle] wrapping a</span>
<span class="sd">        scalar</span>

<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        sigma : float, default=None</span>
<span class="sd">            Sigma term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        rmin_half : float</span>
<span class="sd">            Rmin_half term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        name : string or None, default=None</span>
<span class="sd">            The name of this virtual site. Default is None.</span>
<span class="sd">        orientations : list of int 3-tuples</span>
<span class="sd">            The orientations that should be used to create the virtual site.</span>
<span class="sd">            Each orientation corresponds to an individual virtual particle.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the newly-added virtual site in the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">replace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">vsite</span> <span class="o">=</span> <span class="n">MonovalentLonePairVirtualSite</span><span class="p">(</span>
            <span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">out_of_plane_angle</span><span class="p">,</span> <span class="n">in_plane_angle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_virtual_site</span><span class="p">(</span><span class="n">vsite</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">vsite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_divalent_lone_pair_virtual_site</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">out_of_plane_angle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a divalent lone pair-type virtual site, in which the location of the charge is specified by the position</span>
<span class="sd">        of three atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : list of three :class:`openff.toolkit.topology.molecule.Atom` objects</span>
<span class="sd">            The three atoms defining the virtual site&#39;s position</span>

<span class="sd">        distance : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a scalar</span>

<span class="sd">        out_of_plane_angle : :class:`openmm.unit.Quantity` of dimension [Angle] wrapping</span>
<span class="sd">        a scalar</span>

<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        sigma : float, default=None</span>
<span class="sd">            Sigma term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        rmin_half : float</span>
<span class="sd">            Rmin_half term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        name : string or None, default=None</span>
<span class="sd">            The name of this virtual site. Default is None.</span>
<span class="sd">        orientations : list of int 3-tuples</span>
<span class="sd">            The orientations that should be used to create the virtual site.</span>
<span class="sd">            Each orientation corresponds to an individual virtual particle.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the newly-added virtual site in the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">replace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">vsite</span> <span class="o">=</span> <span class="n">DivalentLonePairVirtualSite</span><span class="p">(</span>
            <span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">out_of_plane_angle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_virtual_site</span><span class="p">(</span><span class="n">vsite</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">vsite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_trivalent_lone_pair_virtual_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a trivalent lone pair-type virtual site, in which the location of the charge is specified by the position</span>
<span class="sd">         of four atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : list of 4 :class:`openff.toolkit.topology.molecule.Atom` objects</span>
<span class="sd">            The four atoms defining the virtual site&#39;s position</span>

<span class="sd">        distance : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a scalar</span>

<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        sigma : float, default=None</span>
<span class="sd">            Sigma term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        rmin_half : float</span>
<span class="sd">            Rmin_half term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        name : string or None, default=None</span>
<span class="sd">            The name of this virtual site. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">replace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">vsite</span> <span class="o">=</span> <span class="n">TrivalentLonePairVirtualSite</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_virtual_site</span><span class="p">(</span><span class="n">vsite</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">vsite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_bond</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atom1</span><span class="p">,</span>
        <span class="n">atom2</span><span class="p">,</span>
        <span class="n">bond_order</span><span class="p">,</span>
        <span class="n">is_aromatic</span><span class="p">,</span>
        <span class="n">stereochemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fractional_bond_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a bond between two specified atom indices</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom1 : int or openff.toolkit.topology.molecule.Atom</span>
<span class="sd">            Index of first atom or first atom</span>
<span class="sd">        atom2_index : int or openff.toolkit.topology.molecule.Atom</span>
<span class="sd">            Index of second atom or second atom</span>
<span class="sd">        bond_order : int</span>
<span class="sd">            Integral bond order of Kekulized form</span>
<span class="sd">        is_aromatic : bool</span>
<span class="sd">            True if this bond is aromatic, False otherwise</span>
<span class="sd">        stereochemistry : str, optional, default=None</span>
<span class="sd">            Either &#39;E&#39; or &#39;Z&#39; for specified stereochemistry, or None if stereochemistry is irrelevant</span>
<span class="sd">        fractional_bond_order : float, optional, default=None</span>
<span class="sd">            The fractional (eg. Wiberg) bond order</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the bond in the molecule</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom2</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">atom1_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom1</span><span class="p">]</span>
            <span class="n">atom2_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom2</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">atom1_atom</span> <span class="o">=</span> <span class="n">atom1</span>
            <span class="n">atom2_atom</span> <span class="o">=</span> <span class="n">atom2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Invalid inputs to molecule._add_bond. Expected ints or Atoms. &quot;</span>
                <span class="s2">&quot;Received </span><span class="si">{}</span><span class="s2"> (type </span><span class="si">{}</span><span class="s2">) and </span><span class="si">{}</span><span class="s2"> (type </span><span class="si">{}</span><span class="s2">) &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">atom1</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">atom1</span><span class="p">),</span> <span class="n">atom2</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># TODO: Check to make sure bond does not already exist</span>
        <span class="k">if</span> <span class="n">atom1_atom</span><span class="o">.</span><span class="n">is_bonded_to</span><span class="p">(</span><span class="n">atom2_atom</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Bond already exists between </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">atom1_atom</span><span class="p">,</span> <span class="n">atom2_atom</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">bond</span> <span class="o">=</span> <span class="n">Bond</span><span class="p">(</span>
            <span class="n">atom1_atom</span><span class="p">,</span>
            <span class="n">atom2_atom</span><span class="p">,</span>
            <span class="n">bond_order</span><span class="p">,</span>
            <span class="n">is_aromatic</span><span class="p">,</span>
            <span class="n">stereochemistry</span><span class="o">=</span><span class="n">stereochemistry</span><span class="p">,</span>
            <span class="n">fractional_bond_order</span><span class="o">=</span><span class="n">fractional_bond_order</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalidate_cached_properties</span><span class="p">()</span>
        <span class="c1"># TODO: This is a bad way to get bond index</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_conformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a conformation of the molecule</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates: openmm.unit.Quantity(np.array) with shape (n_atoms, 3) and dimension of distance</span>
<span class="sd">            Coordinates of the new conformer, with the first dimension of the array corresponding to the atom index in</span>
<span class="sd">            the Molecule&#39;s indexing system.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index: int</span>
<span class="sd">            The index of this conformer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_conf</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">new_conf</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;molecule.add_conformer given input of the wrong shape: &quot;</span>
                <span class="s2">&quot;Given </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">new_conf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_conf</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">coordinates</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Coordinates passed to Molecule._add_conformer without units. Ensure that coordinates are &quot;</span>
                <span class="s2">&quot;of type openmm.units.Quantity&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO should we checking that the exact same conformer is not in the list already?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_conf</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">partial_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the partial charges (if present) on the molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        partial_charges : a openmm.unit.Quantity - wrapped numpy array [1 x n_atoms] or None</span>
<span class="sd">            The partial charges on this Molecule&#39;s atoms. Returns None if no charges have been specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span>

    <span class="nd">@partial_charges</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">partial_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">charges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the atomic partial charges for this molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        charges : None or a openmm.unit.Quantity - wrapped numpy array [1 x n_atoms]</span>
<span class="sd">            The partial charges to assign to the molecule. If not None, must be in units compatible with openmm.unit.elementary_charge</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">charges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">charges</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">charges</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">charges</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,)</span>

            <span class="n">charges_ec</span> <span class="o">=</span> <span class="n">charges</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="o">=</span> <span class="n">charges_ec</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_particles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of Particle objects, which corresponds to how many positions must be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="n">vsite</span><span class="o">.</span><span class="n">n_particles</span> <span class="k">for</span> <span class="n">vsite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of Atom objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_virtual_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of VirtualSite objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_virtual_particles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of VirtualParticle objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">vsite</span><span class="o">.</span><span class="n">n_particles</span> <span class="k">for</span> <span class="n">vsite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of Bond objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int: number of angles in the Molecule.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_angles</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_propers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int: number of proper torsions in the Molecule.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_torsions</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_propers</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int: number of possible improper torsions in the Molecule.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_torsions</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_rings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of rings found in the Molecule</span>

<span class="sd">        Requires the RDKit to be installed.</span>

<span class="sd">        .. note ::</span>

<span class="sd">            For systems containing some special cases of connected rings, this</span>
<span class="sd">            function may not be well-behaved and may report a different number</span>
<span class="sd">            rings than expected. Some problematic cases include networks of many</span>
<span class="sd">            (5+) rings or bicyclic moieties (i.e. norbornane).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rings</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">particles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all Particle objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">+</span> <span class="p">[</span>
            <span class="n">ptl</span> <span class="k">for</span> <span class="n">vsite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span> <span class="k">for</span> <span class="n">ptl</span> <span class="ow">in</span> <span class="n">vsite</span><span class="o">.</span><span class="n">particles</span>
        <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all Atom objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">conformers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of conformers for this molecule. This returns a list of openmm.unit.Quantity-wrapped numpy</span>
<span class="sd">        arrays, of shape (3 x n_atoms) and with dimensions of distance. The return value is the actual list of</span>
<span class="sd">        conformers, and changes to the contents affect the original FrozenMolecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_conformers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of conformers for this molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">virtual_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all VirtualSite objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_sites</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all Bond objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an iterator over all i-j-k angles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_angles</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">torsions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an iterator over all i-j-k-l torsions.</span>
<span class="sd">        Note that i-j-k-i torsions (cycles) are excluded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torsions : iterable of 4-Atom tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_torsions</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torsions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">propers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all proper torsions in the molecule</span>

<span class="sd">        .. todo::</span>

<span class="sd">           * Do we need to return a ``Torsion`` object that collects information about fractional bond orders?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_torsions</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all improper torsions in the molecule.</span>

<span class="sd">        .. todo ::</span>
<span class="sd">           * Do we need to return a ``Torsion`` object that collects information about fractional bond orders?</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impropers : set of tuple</span>
<span class="sd">            An iterator of tuples, each containing the indices of atoms making</span>
<span class="sd">            up a possible improper torsion.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        smirnoff_impropers, amber_impropers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_torsions</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">smirnoff_impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over improper torsions in the molecule, but only those with</span>
<span class="sd">        trivalent centers, reporting the central atom second in each improper.</span>

<span class="sd">        Note that it&#39;s possible that a trivalent center will not have an improper assigned.</span>
<span class="sd">        This will depend on the force field that is used.</span>

<span class="sd">        Also note that this will return 6 possible atom orderings around each improper</span>
<span class="sd">        center. In current SMIRNOFF parameterization, three of these six</span>
<span class="sd">        orderings will be used for the actual assignment of the improper term</span>
<span class="sd">        and measurement of the angles. These three orderings capture the three unique</span>
<span class="sd">        angles that could be calculated around the improper center, therefore the sum</span>
<span class="sd">        of these three terms will always return a consistent energy.</span>

<span class="sd">        The exact three orderings that will be applied during parameterization can not be</span>
<span class="sd">        determined in this method, since it requires sorting the particle indices, and</span>
<span class="sd">        those indices may change when this molecule is added to a Topology.</span>

<span class="sd">        For more details on the use of three-fold (&#39;trefoil&#39;) impropers, see</span>
<span class="sd">        https://openforcefield.github.io/standards/standards/smirnoff/#impropertorsions</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impropers : set of tuple</span>
<span class="sd">            An iterator of tuples, each containing the indices of atoms making</span>
<span class="sd">            up a possible improper torsion. The central atom is listed second</span>
<span class="sd">            in each tuple.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        impropers, amber_impropers</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Replace with non-cheminformatics-toolkit method</span>
        <span class="c1">#       (ie. just looping over all atoms and finding ones that have 3 bonds?)</span>

        <span class="n">smirnoff_improper_smarts</span> <span class="o">=</span> <span class="s2">&quot;[*:1]~[X3:2](~[*:3])~[*:4]&quot;</span>
        <span class="n">improper_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_environment_matches</span><span class="p">(</span><span class="n">smirnoff_improper_smarts</span><span class="p">)</span>
        <span class="n">smirnoff_impropers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">imp</span><span class="p">)</span> <span class="k">for</span> <span class="n">imp</span> <span class="ow">in</span> <span class="n">improper_idxs</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">smirnoff_impropers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">amber_impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over improper torsions in the molecule, but only those with</span>
<span class="sd">        trivalent centers, reporting the central atom first in each improper.</span>

<span class="sd">        Note that it&#39;s possible that a trivalent center will not have an improper assigned.</span>
<span class="sd">        This will depend on the force field that is used.</span>

<span class="sd">        Also note that this will return 6 possible atom orderings around each improper</span>
<span class="sd">        center. In current AMBER parameterization, one of these six</span>
<span class="sd">        orderings will be used for the actual assignment of the improper term</span>
<span class="sd">        and measurement of the angle. This method does not encode the logic to</span>
<span class="sd">        determine which of the six orderings AMBER would use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impropers : set of tuple</span>
<span class="sd">            An iterator of tuples, each containing the indices of atoms making</span>
<span class="sd">            up a possible improper torsion. The central atom is listed first in</span>
<span class="sd">            each tuple.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        impropers, smirnoff_impropers</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Replace with non-cheminformatics-toolkit method</span>
        <span class="c1">#       (ie. just looping over all atoms and finding ones that have 3 bonds?)</span>
        <span class="n">amber_improper_smarts</span> <span class="o">=</span> <span class="s2">&quot;[X3:1](~[*:2])(~[*:3])~[*:4]&quot;</span>
        <span class="n">improper_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_environment_matches</span><span class="p">(</span><span class="n">amber_improper_smarts</span><span class="p">)</span>
        <span class="n">amber_impropers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">imp</span><span class="p">)</span> <span class="k">for</span> <span class="n">imp</span> <span class="ow">in</span> <span class="n">improper_idxs</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">amber_impropers</span>

    <span class="k">def</span> <span class="nf">_nth_degree_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_degrees</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="n">mol_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">mol_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node_j</span> <span class="ow">in</span> <span class="n">mol_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node_i</span> <span class="o">==</span> <span class="n">node_j</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">path_length</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">mol_graph</span><span class="p">,</span> <span class="n">node_i</span><span class="p">,</span> <span class="n">node_j</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">path_length</span> <span class="o">==</span> <span class="n">n_degrees</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node_i</span> <span class="o">&gt;</span> <span class="n">node_j</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">node_i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">node_j</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">nth_degree_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_degrees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return canonicalized pairs of atoms whose shortest separation is `exactly` n bonds.</span>
<span class="sd">        Only pairs with increasing atom indices are returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n: int</span>
<span class="sd">            The number of bonds separating atoms in each pair</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        neighbors: iterator of tuple of Atom</span>
<span class="sd">            Tuples (len 2) of atom that are separated by ``n`` bonds.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        The criteria used here relies on minimum distances; when there are multiple valid</span>
<span class="sd">        paths between atoms, such as atoms in rings, the shortest path is considered.</span>
<span class="sd">        For example, two atoms in &quot;meta&quot; positions with respect to each other in a benzene</span>
<span class="sd">        are separated by two paths, one length 2 bonds and the other length 4 bonds. This</span>
<span class="sd">        function would consider them to be 2 apart and would not include them if ``n=4`` was</span>
<span class="sd">        passed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_degrees</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot consider neighbors separated by 0 or fewer atoms. Asked to consider &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;path lengths of </span><span class="si">{</span><span class="n">n_degrees</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nth_degree_neighbors</span><span class="p">(</span><span class="n">n_degrees</span><span class="o">=</span><span class="n">n_degrees</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">total_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total charge on the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">charge_sum</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">charge_sum</span> <span class="o">+=</span> <span class="n">atom</span><span class="o">.</span><span class="n">formal_charge</span>
        <span class="k">return</span> <span class="n">charge_sum</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name (or title) of the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the name of this molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Molecule name must be a string&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The properties dictionary of the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hill_formula</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the Hill formula of the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_hill_formula</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_hill_formula</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the Hill formula of this molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        formula : the Hill formula of the molecule</span>

<span class="sd">        Raises</span>
<span class="sd">        -----------</span>
<span class="sd">        NotImplementedError : if the molecule is not of one of the specified types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atom_nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">atomic_number</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">_atom_nums_to_hill_formula</span><span class="p">(</span><span class="n">atom_nums</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_object_to_hill_formula</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Molecule&quot;</span><span class="p">,</span> <span class="s2">&quot;nx.Graph&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Take a Molecule or NetworkX graph and generate its Hill formula.</span>
<span class="sd">        This provides a backdoor to the old functionality of Molecule.to_hill_formula, which</span>
<span class="sd">        was a static method that duck-typed inputs of Molecule or graph objects.&quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="kn">from</span> <span class="nn">openff.toolkit.topology.topology</span> <span class="kn">import</span> <span class="n">TopologyMolecule</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">FrozenMolecule</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">to_hill_formula</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">TopologyMolecule</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_topologymolecule_to_hill_formula</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_networkx_graph_to_hill_formula</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupport object of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2"> passed to &quot;</span>
                <span class="s2">&quot;Molecule._object_to_hill_formula&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">chemical_environment_matches</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">query</span><span class="p">,</span>
        <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve all matches for a given chemical environment query.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        query : str or ChemicalEnvironment</span>
<span class="sd">            SMARTS string (with one or more tagged atoms) or ``ChemicalEnvironment`` query.</span>
<span class="sd">            Query will internally be resolved to SMIRKS using ``query.asSMIRKS()`` if it has an ``.asSMIRKS`` method.</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for chemical environment matches</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matches : list of atom index tuples</span>
<span class="sd">            A list of tuples, containing the indices of the matching atoms.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Retrieve all the carbon-carbon bond matches in a molecule</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;imatinib&#39;)</span>
<span class="sd">        &gt;&gt;&gt; matches = molecule.chemical_environment_matches(&#39;[#6X3:1]~[#6X3:2]&#39;)</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * Do we want to generalize ``query`` to allow other kinds of queries, such as mdtraj DSL, pymol selections, atom index slices, etc?</span>
<span class="sd">             We could call it ``topology.matches(query)`` instead of ``chemical_environment_matches``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Resolve to SMIRKS if needed</span>
        <span class="c1"># TODO: Update this to use updated ChemicalEnvironment API</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="s2">&quot;smirks&quot;</span><span class="p">):</span>
            <span class="n">smirks</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">smirks</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">smirks</span> <span class="o">=</span> <span class="n">query</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;query&#39; must be either a string or a ChemicalEnvironment&quot;</span><span class="p">)</span>

        <span class="c1"># Use specified cheminformatics toolkit to determine matches with specified aromaticity model</span>
        <span class="c1"># TODO: Simplify this by requiring a toolkit registry for the molecule?</span>
        <span class="c1"># TODO: Do we have to pass along an aromaticity model?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;find_smarts_matches&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">smirks</span><span class="p">,</span>
                <span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">find_smarts_matches</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">smirks</span><span class="p">,</span>
                <span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;toolkit_registry&#39; must be either a ToolkitRegistry or a ToolkitWrapper&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">matches</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_iupac</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">iupac_name</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a molecule from IUPAC or common name</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iupac_name : str</span>
<span class="sd">            IUPAC name of molecule to be generated</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for chemical environment matches</span>
<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If false, raises an exception if molecule contains undefined stereochemistry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : Molecule</span>
<span class="sd">            The resulting molecule with position</span>

<span class="sd">        .. note :: This method requires the OpenEye toolkit to be installed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a molecule from an IUPAC name</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;4-[(4-methylpiperazin-1-yl)methyl]-N-(4-methyl-3-{[4-(pyridin-3-yl)pyrimidin-2-yl]amino}phenyl)benzamide&#39;)</span>

<span class="sd">        Create a molecule from a common name</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;imatinib&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;from_iupac&quot;</span><span class="p">,</span>
                <span class="n">iupac_name</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_iupac</span><span class="p">(</span>
                <span class="n">iupac_name</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span> <span class="o">**</span> <span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to from_iupac. Expected ToolkitRegistry or ToolkitWrapper. Got  </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">molecule</span>

    <span class="k">def</span> <span class="nf">to_iupac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate IUPAC name from Molecule</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iupac_name : str</span>
<span class="sd">            IUPAC name of the molecule</span>

<span class="sd">        .. note :: This method requires the OpenEye toolkit to be installed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule(sdf_filepath)</span>
<span class="sd">        &gt;&gt;&gt; iupac_name = molecule.to_iupac()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">to_iupac_method</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="s2">&quot;to_iupac&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">to_iupac_method</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">to_iupac</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to to_iupac. Expected ToolkitRegistry or ToolkitWrapper. Got  </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># TODO: Can `to_iupac` fail if given a well-behaved OFFMol/OEMol?</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">to_iupac_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_topology</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">topology</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a Molecule representation of an OpenFF Topology containing a single Molecule object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        topology : openff.toolkit.topology.Topology</span>
<span class="sd">            The :class:`Topology` object containing a single :class:`Molecule` object.</span>
<span class="sd">            Note that OpenMM and MDTraj ``Topology`` objects are not supported.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>
<span class="sd">            The Molecule object in the topology</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the topology does not contain exactly one molecule.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a molecule from a Topology object that contains exactly one molecule</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_topology(topology)  # doctest: +SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Ensure we are dealing with an OpenFF Topology object</span>
        <span class="k">if</span> <span class="n">topology</span><span class="o">.</span><span class="n">n_topology_molecules</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Topology must contain exactly one molecule&quot;</span><span class="p">)</span>
        <span class="n">molecule</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">reference_molecules</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an OpenFF Topology representation containing one copy of this molecule</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology : openff.toolkit.topology.Topology</span>
<span class="sd">            A Topology representation of this molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;imatinib&#39;)</span>
<span class="sd">        &gt;&gt;&gt; topology = molecule.to_topology()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openff.toolkit.topology</span> <span class="kn">import</span> <span class="n">Topology</span>

        <span class="k">return</span> <span class="n">Topology</span><span class="o">.</span><span class="n">from_molecules</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">file_path</span><span class="p">,</span>
        <span class="n">file_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create one or more molecules from a file</span>

<span class="sd">        .. todo::</span>

<span class="sd">           * Extend this to also include some form of .offmol Open Force Field Molecule format?</span>
<span class="sd">           * Generalize this to also include file-like objects?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path : str or file-like object</span>
<span class="sd">            The path to the file or file-like object to stream one or more molecules from.</span>
<span class="sd">        file_format : str, optional, default=None</span>
<span class="sd">            Format specifier, usually file suffix (eg. &#39;MOL2&#39;, &#39;SMI&#39;)</span>
<span class="sd">            Note that not all toolkits support all formats. Check ToolkitWrapper.toolkit_file_read_formats for your</span>
<span class="sd">            loaded toolkits for details.</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper,</span>
<span class="sd">        optional, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for file loading. If a Toolkit is passed, only</span>
<span class="sd">            the highest-precedence toolkit is used</span>
<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If false, raises an exception if oemol contains undefined stereochemistry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecules : Molecule or list of Molecules</span>
<span class="sd">            If there is a single molecule in the file, a Molecule is returned;</span>
<span class="sd">            otherwise, a list of Molecule objects is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from openff.toolkit.tests.utils import get_monomer_mol2_file_path</span>
<span class="sd">        &gt;&gt;&gt; mol2_file_path = get_monomer_mol2_file_path(&#39;cyclohexane&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_file(mol2_file_path)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">file_format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;If providing a file-like object for reading molecules, the format must be specified&quot;</span>
                <span class="p">)</span>
            <span class="c1"># Assume that files ending in &quot;.gz&quot; should use their second-to-last suffix for compatibility check</span>
            <span class="c1"># TODO: Will all cheminformatics packages be OK with gzipped files?</span>
            <span class="k">if</span> <span class="n">file_path</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;.gz&quot;</span><span class="p">:</span>
                <span class="n">file_format</span> <span class="o">=</span> <span class="n">file_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">file_format</span> <span class="o">=</span> <span class="n">file_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">file_format</span> <span class="o">=</span> <span class="n">file_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;XYZ&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedFileTypeError</span><span class="p">(</span>
                <span class="s2">&quot;Parsing `.xyz` files is not currently supported because they lack sufficient &quot;</span>
                <span class="s2">&quot;chemical information to be used with SMIRNOFF force fields. For more information, &quot;</span>
                <span class="s2">&quot;see https://open-forcefield-toolkit.readthedocs.io/en/latest/faq.html or to provide &quot;</span>
                <span class="s2">&quot;feedback please visit https://github.com/openforcefield/openff-toolkit/issues/1145.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Determine which toolkit to use (highest priority that&#39;s compatible with input type)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="c1"># TODO: Encapsulate this logic into ToolkitRegistry.call()?</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">supported_read_formats</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">query_toolkit</span> <span class="ow">in</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">registered_toolkits</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">file_format</span> <span class="ow">in</span> <span class="n">query_toolkit</span><span class="o">.</span><span class="n">toolkit_file_read_formats</span><span class="p">:</span>
                    <span class="n">toolkit</span> <span class="o">=</span> <span class="n">query_toolkit</span>
                    <span class="k">break</span>
                <span class="n">supported_read_formats</span><span class="p">[</span>
                    <span class="n">query_toolkit</span><span class="o">.</span><span class="n">toolkit_name</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">query_toolkit</span><span class="o">.</span><span class="n">toolkit_file_read_formats</span>
            <span class="k">if</span> <span class="n">toolkit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No toolkits in registry can read file </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2"> (format </span><span class="si">{</span><span class="n">file_format</span><span class="si">}</span><span class="s2">). Supported &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;formats in the provided ToolkitRegistry are </span><span class="si">{</span><span class="n">supported_read_formats</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="p">)</span>
                <span class="c1"># Per issue #407, not allowing RDKit to read mol2 has confused a lot of people. Here we add text</span>
                <span class="c1"># to the error message that will hopefully reduce this confusion.</span>
                <span class="k">if</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;MOL2&quot;</span> <span class="ow">and</span> <span class="n">RDKitToolkitWrapper</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;RDKit does not fully support input of molecules from mol2 format unless they &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;have Corina atom types, and this is not common in the simulation community. For this &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;reason, the Open Force Field Toolkit does not use &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;RDKit to read .mol2. Consider reading from SDF instead. If you would like to attempt &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;to use RDKit to read mol2 anyway, you can load the molecule of interest into an RDKit &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;molecule and use openff.toolkit.topology.Molecule.from_rdkit, but we do not recommend this.&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;PDB&quot;</span> <span class="ow">and</span> <span class="n">RDKitToolkitWrapper</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="s2">&quot;RDKit can not safely read PDBs on their own. Information about bond order and aromaticity &quot;</span>
                        <span class="s2">&quot;is likely to be lost. PDBs can be used along with a valid smiles string with RDKit using &quot;</span>
                        <span class="s2">&quot;the constructor Molecule.from_pdb_and_smiles(file_path, smiles)&quot;</span>
                    <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="c1"># TODO: Encapsulate this logic in ToolkitWrapper?</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="k">if</span> <span class="n">file_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">toolkit_file_read_formats</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Toolkit </span><span class="si">{</span><span class="n">toolkit</span><span class="o">.</span><span class="n">toolkit_name</span><span class="si">}</span><span class="s2"> can not read file </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2"> (format </span><span class="si">{</span><span class="n">file_format</span><span class="si">}</span><span class="s2">). Supported &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;formats for this toolkit are </span><span class="si">{</span><span class="n">toolkit</span><span class="o">.</span><span class="n">toolkit_file_read_formats</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">toolkit_name</span> <span class="o">==</span> <span class="s2">&quot;The RDKit&quot;</span> <span class="ow">and</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;PDB&quot;</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="s2">&quot;RDKit can however read PDBs with a valid smiles string using the &quot;</span>
                        <span class="s2">&quot;Molecule.from_pdb_and_smiles(file_path, smiles) constructor&quot;</span>
                    <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;toolkit_registry&#39; must be either a ToolkitRegistry or a ToolkitWrapper&quot;</span>
            <span class="p">)</span>

        <span class="n">mols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">mols</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span>
                <span class="n">file_path</span><span class="p">,</span>
                <span class="n">file_format</span><span class="o">=</span><span class="n">file_format</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;read&quot;</span><span class="p">):</span>
            <span class="n">file_obj</span> <span class="o">=</span> <span class="n">file_path</span>
            <span class="n">mols</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_file_obj</span><span class="p">(</span>
                <span class="n">file_obj</span><span class="p">,</span>
                <span class="n">file_format</span><span class="o">=</span><span class="n">file_format</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unable to read molecule from file: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file_path</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">mols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">mols</span>

    <span class="k">def</span> <span class="nf">_to_xyz_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the current molecule and its conformers to a multiframe xyz file, if the molecule</span>
<span class="sd">        has no current coordinates all atoms will be set to 0,0,0 in keeping with the behaviour of the</span>
<span class="sd">        backend toolkits.</span>

<span class="sd">        Information on the type of XYZ file written can be found here &lt;http://openbabel.org/wiki/XYZ_(format)&gt;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path : str or file-like object</span>
<span class="sd">            A file-like object or the path to the file to be written.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If we do not have a conformer make one with all zeros</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_conformers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">conformers</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">conformers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conformers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">frame</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">hill_formula</span><span class="si">}{</span><span class="n">frame</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">frame</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">hill_formula</span><span class="si">}</span><span class="s1"> Frame </span><span class="si">{</span><span class="n">frame</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="c1"># check if we have a file path or an open file object</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">xyz_data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xyz_data</span> <span class="o">=</span> <span class="n">file_path</span>

        <span class="c1"># add the data to the xyz_data list</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">geometry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conformers</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">xyz_data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">title</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">atom_coords</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">atom_coords</span><span class="o">.</span><span class="n">_value</span>
                <span class="n">xyz_data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">symbol</span><span class="si">}</span><span class="s2">       </span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2"> .10f</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">y</span><span class="si">:</span><span class="s2"> .10f</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">z</span><span class="si">:</span><span class="s2"> .10f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="c1"># now we up the frame count</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># now close the file</span>
        <span class="n">xyz_data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">file_format</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the current molecule to a file or file-like object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path : str or file-like object</span>
<span class="sd">            A file-like object or the path to the file to be written.</span>
<span class="sd">        file_format : str</span>
<span class="sd">            Format specifier, one of [&#39;MOL2&#39;, &#39;MOL2H&#39;, &#39;SDF&#39;, &#39;PDB&#39;, &#39;SMI&#39;, &#39;CAN&#39;, &#39;TDT&#39;]</span>
<span class="sd">            Note that not all toolkits support all formats</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper,</span>
<span class="sd">        optional, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for file writing. If a Toolkit is passed, only</span>
<span class="sd">            the highest-precedence toolkit is used</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the requested file_format is not supported by one of the installed cheminformatics toolkits</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;imatinib&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule.to_file(&#39;imatinib.mol2&#39;, file_format=&#39;mol2&#39;)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; molecule.to_file(&#39;imatinib.sdf&#39;, file_format=&#39;sdf&#39;)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; molecule.to_file(&#39;imatinib.pdb&#39;, file_format=&#39;pdb&#39;)  # doctest: +SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">toolkit_registry</span> <span class="o">=</span> <span class="n">ToolkitRegistry</span><span class="p">(</span><span class="n">toolkit_precedence</span><span class="o">=</span><span class="p">[])</span>
            <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">add_toolkit</span><span class="p">(</span><span class="n">toolkit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;toolkit_registry&#39; must be either a ToolkitRegistry or a ToolkitWrapper&quot;</span>
            <span class="p">)</span>

        <span class="n">file_format</span> <span class="o">=</span> <span class="n">file_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="c1"># check if xyz, use the toolkit independent method.</span>
        <span class="k">if</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;XYZ&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_xyz_file</span><span class="p">(</span><span class="n">file_path</span><span class="o">=</span><span class="n">file_path</span><span class="p">)</span>

        <span class="c1"># Take the first toolkit that can write the desired output format</span>
        <span class="n">toolkit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">query_toolkit</span> <span class="ow">in</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">registered_toolkits</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">file_format</span> <span class="ow">in</span> <span class="n">query_toolkit</span><span class="o">.</span><span class="n">toolkit_file_write_formats</span><span class="p">:</span>
                <span class="n">toolkit</span> <span class="o">=</span> <span class="n">query_toolkit</span>
                <span class="k">break</span>

        <span class="c1"># Raise an exception if no toolkit was found to provide the requested file_format</span>
        <span class="k">if</span> <span class="n">toolkit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">supported_formats</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">toolkit</span> <span class="ow">in</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">registered_toolkits</span><span class="p">:</span>
                <span class="n">supported_formats</span><span class="p">[</span>
                    <span class="n">toolkit</span><span class="o">.</span><span class="n">toolkit_name</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">toolkit_file_write_formats</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The requested file format (</span><span class="si">{}</span><span class="s2">) is not available from any of the installed toolkits &quot;</span>
                <span class="s2">&quot;(supported formats: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file_format</span><span class="p">,</span> <span class="n">supported_formats</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Write file</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1"># Open file for writing</span>
            <span class="n">toolkit</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">file_format</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">toolkit</span><span class="o">.</span><span class="n">to_file_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">file_format</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">enumerate_tautomers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">max_states</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enumerate the possible tautomers of the current molecule</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_states: int optional, default=20</span>
<span class="sd">            The maximum amount of molecules that should be returned</span>

<span class="sd">        toolkit_registry: openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use to enumerate the tautomers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecules: List[openff.toolkit.topology.Molecule]</span>
<span class="sd">            A list of openff.toolkit.topology.Molecule instances not including the input molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">molecules</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;enumerate_tautomers&quot;</span><span class="p">,</span> <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_states</span><span class="o">=</span><span class="n">max_states</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">molecules</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">enumerate_tautomers</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">max_states</span><span class="o">=</span><span class="n">max_states</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;toolkit_registry&#39; must be either a ToolkitRegistry or a ToolkitWrapper&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">molecules</span>

    <span class="k">def</span> <span class="nf">enumerate_stereoisomers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">undefined_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_isomers</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">rationalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enumerate the stereocenters and bonds of the current molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        undefined_only: bool optional, default=False</span>
<span class="sd">            If we should enumerate all stereocenters and bonds or only those with undefined stereochemistry</span>

<span class="sd">        max_isomers: int optional, default=20</span>
<span class="sd">            The maximum amount of molecules that should be returned</span>

<span class="sd">        rationalise: bool optional, default=True</span>
<span class="sd">            If we should try to build and rationalise the molecule to ensure it can exist</span>

<span class="sd">        toolkit_registry: openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use to enumerate the stereoisomers.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        molecules: List[openff.toolkit.topology.Molecule]</span>
<span class="sd">            A list of :class:`Molecule` instances not including the input molecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">molecules</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;enumerate_stereoisomers&quot;</span><span class="p">,</span>
                <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">undefined_only</span><span class="o">=</span><span class="n">undefined_only</span><span class="p">,</span>
                <span class="n">max_isomers</span><span class="o">=</span><span class="n">max_isomers</span><span class="p">,</span>
                <span class="n">rationalise</span><span class="o">=</span><span class="n">rationalise</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">molecules</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">enumerate_stereoisomers</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">undefined_only</span><span class="o">=</span><span class="n">undefined_only</span><span class="p">,</span>
                <span class="n">max_isomers</span><span class="o">=</span><span class="n">max_isomers</span><span class="p">,</span>
                <span class="n">rationalise</span><span class="o">=</span><span class="n">rationalise</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;toolkit_registry&#39; must be either a ToolkitRegistry or a ToolkitWrapper&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">molecules</span>

    <span class="nd">@OpenEyeToolkitWrapper</span><span class="o">.</span><span class="n">requires_toolkit</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">enumerate_protomers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_states</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enumerate the formal charges of a molecule to generate different protomoers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_states: int optional, default=10,</span>
<span class="sd">            The maximum number of protomer states to be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecules: List[openff.toolkit.topology.Molecule],</span>
<span class="sd">            A list of the protomers of the input molecules not including the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">toolkit</span> <span class="o">=</span> <span class="n">OpenEyeToolkitWrapper</span><span class="p">()</span>
        <span class="n">molecules</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">enumerate_protomers</span><span class="p">(</span><span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_states</span><span class="o">=</span><span class="n">max_states</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">molecules</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@RDKitToolkitWrapper</span><span class="o">.</span><span class="n">requires_toolkit</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">from_rdkit</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">rdmol</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Molecule from an RDKit molecule.</span>

<span class="sd">        Requires the RDKit to be installed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rdmol : rkit.RDMol</span>
<span class="sd">            An RDKit molecule</span>
<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If ``False``, raises an exception if ``rdmol`` contains undefined stereochemistry.</span>
<span class="sd">        hydrogens_are_explicit : bool, default=False</span>
<span class="sd">            If ``False``, RDKit will perform hydrogen addition using ``Chem.AddHs``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>
<span class="sd">            An OpenFF molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a molecule from an RDKit molecule</span>

<span class="sd">        &gt;&gt;&gt; from rdkit import Chem</span>
<span class="sd">        &gt;&gt;&gt; from openff.toolkit.tests.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; rdmol = Chem.MolFromMolFile(get_data_file_path(&#39;systems/monomers/ethanol.sdf&#39;))</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_rdkit(rdmol)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">toolkit</span> <span class="o">=</span> <span class="n">RDKitToolkitWrapper</span><span class="p">()</span>
        <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span>
            <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
            <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="n">hydrogens_are_explicit</span><span class="p">,</span>
            <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">molecule</span>

    <span class="nd">@RDKitToolkitWrapper</span><span class="o">.</span><span class="n">requires_toolkit</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">to_rdkit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aromaticity_model</span><span class="o">=</span><span class="n">DEFAULT_AROMATICITY_MODEL</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an RDKit molecule</span>

<span class="sd">        Requires the RDKit to be installed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        aromaticity_model : str, optional, default=DEFAULT_AROMATICITY_MODEL</span>
<span class="sd">            The aromaticity model to use</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rdmol : rdkit.RDMol</span>
<span class="sd">            An RDKit molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Convert a molecule to RDKit</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule(sdf_filepath)</span>
<span class="sd">        &gt;&gt;&gt; rdmol = molecule.to_rdkit()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">toolkit</span> <span class="o">=</span> <span class="n">RDKitToolkitWrapper</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aromaticity_model</span><span class="o">=</span><span class="n">aromaticity_model</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@OpenEyeToolkitWrapper</span><span class="o">.</span><span class="n">requires_toolkit</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">from_openeye</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">oemol</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a ``Molecule`` from an OpenEye molecule.</span>

<span class="sd">        Requires the OpenEye toolkit to be installed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        oemol : openeye.oechem.OEMol</span>
<span class="sd">            An OpenEye molecule</span>
<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If ``False``, raises an exception if oemol contains undefined stereochemistry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>
<span class="sd">            An OpenFF molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a ``Molecule`` from an OpenEye OEMol</span>

<span class="sd">        &gt;&gt;&gt; from openeye import oechem</span>
<span class="sd">        &gt;&gt;&gt; from openff.toolkit.tests.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; ifs = oechem.oemolistream(get_data_file_path(&#39;systems/monomers/ethanol.mol2&#39;))</span>
<span class="sd">        &gt;&gt;&gt; oemols = list(ifs.GetOEGraphMols())</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_openeye(oemols[0])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">toolkit</span> <span class="o">=</span> <span class="n">OpenEyeToolkitWrapper</span><span class="p">()</span>
        <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_openeye</span><span class="p">(</span>
            <span class="n">oemol</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span> <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">molecule</span>

    <span class="nd">@requires_package</span><span class="p">(</span><span class="s2">&quot;qcelemental&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_qcschema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplicity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">extras</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a QCElemental Molecule.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        multiplicity : int, default=1,</span>
<span class="sd">            The multiplicity of the molecule;</span>
<span class="sd">            sets ``molecular_multiplicity`` field for QCElemental Molecule.</span>

<span class="sd">        conformer : int, default=0,</span>
<span class="sd">            The index of the conformer to use for the QCElemental Molecule geometry.</span>

<span class="sd">        extras : dict, default=None</span>
<span class="sd">            A dictionary that should be included in the ``extras`` field on the QCElemental Molecule.</span>
<span class="sd">            This can be used to include extra information, such as a smiles representation.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------</span>
<span class="sd">        qcelemental.models.Molecule</span>
<span class="sd">            A validated QCElemental Molecule.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a QCElemental Molecule:</span>

<span class="sd">        &gt;&gt;&gt; import qcelemental as qcel</span>
<span class="sd">        &gt;&gt;&gt; mol = Molecule.from_smiles(&#39;CC&#39;)</span>
<span class="sd">        &gt;&gt;&gt; mol.generate_conformers(n_conformers=1)</span>
<span class="sd">        &gt;&gt;&gt; qcemol = mol.to_qcschema()</span>

<span class="sd">        Raises</span>
<span class="sd">        --------</span>
<span class="sd">        MissingDependencyError</span>
<span class="sd">            If qcelemental is not installed, the qcschema can not be validated.</span>
<span class="sd">        InvalidConformerError</span>
<span class="sd">            No conformer found at the given index.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span> <span class="nn">qcelemental</span> <span class="k">as</span> <span class="nn">qcel</span>

        <span class="c1"># get/ check the geometry</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformers</span><span class="p">[</span><span class="n">conformer</span><span class="p">]</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">bohr</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InvalidConformerError</span><span class="p">(</span>
                <span class="s2">&quot;The molecule must have a conformation to produce a valid qcschema; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;no conformer was found at index </span><span class="si">{</span><span class="n">conformer</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Gather the required qcschema data</span>
        <span class="n">charge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_charge</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="p">)</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1_index</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom2_index</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">bond_order</span><span class="p">)</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span>
        <span class="p">]</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Element</span><span class="o">.</span><span class="n">getByAtomicNumber</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">)</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">extras</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extras</span><span class="p">[</span>
                <span class="s2">&quot;canonical_isomeric_explicit_hydrogen_mapped_smiles&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_smiles</span><span class="p">(</span><span class="n">mapped</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extras</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;canonical_isomeric_explicit_hydrogen_mapped_smiles&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_smiles</span><span class="p">(</span>
                    <span class="n">mapped</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="p">}</span>

        <span class="n">schema_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;symbols&quot;</span><span class="p">:</span> <span class="n">symbols</span><span class="p">,</span>
            <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">geometry</span><span class="p">,</span>
            <span class="c1"># If we have no bonds we must supply None</span>
            <span class="s2">&quot;connectivity&quot;</span><span class="p">:</span> <span class="n">connectivity</span> <span class="k">if</span> <span class="n">connectivity</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;molecular_charge&quot;</span><span class="p">:</span> <span class="n">charge</span><span class="p">,</span>
            <span class="s2">&quot;molecular_multiplicity&quot;</span><span class="p">:</span> <span class="n">multiplicity</span><span class="p">,</span>
            <span class="s2">&quot;extras&quot;</span><span class="p">:</span> <span class="n">extras</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">qcel</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="n">schema_dict</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_mapped_smiles</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">mapped_smiles</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an :class:`Molecule` from a mapped SMILES made with cmiles.</span>
<span class="sd">        The molecule will be in the order of the indexing in the mapped smiles string.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapped_smiles: str,</span>
<span class="sd">            A CMILES-style mapped smiles string with explicit hydrogens.</span>

<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMILES-to-molecule conversion</span>

<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If false, raises an exception if oemol contains undefined stereochemistry.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        offmol : openff.toolkit.topology.molecule.Molecule</span>
<span class="sd">            An OpenFF molecule instance.</span>

<span class="sd">        Raises</span>
<span class="sd">        --------</span>
<span class="sd">        SmilesParsingError</span>
<span class="sd">            If the given SMILES had no indexing picked up by the toolkits.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create the molecule from the smiles and check we have the right number of indexes</span>
        <span class="c1"># in the mapped SMILES</span>
        <span class="n">offmol</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_smiles</span><span class="p">(</span>
            <span class="n">mapped_smiles</span><span class="p">,</span>
            <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span><span class="p">,</span>
            <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># check we found some mapping and remove it as we do not want to expose atom maps</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">offmol</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;atom_map&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SmilesParsingError</span><span class="p">(</span>
                <span class="s2">&quot;The given SMILES has no indexing, please generate a valid explicit hydrogen &quot;</span>
                <span class="s2">&quot;mapped SMILES using cmiles.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="o">!=</span> <span class="n">offmol</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SmilesParsingError</span><span class="p">(</span>
                <span class="s2">&quot;The mapped smiles does not contain enough indexes to remap the molecule.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># remap the molecule using the atom map found in the smiles</span>
        <span class="c1"># the order is mapping = Dict[current_index: new_index]</span>
        <span class="c1"># first renumber the mapping dict indexed from 0, currently from 1 as 0 indicates no mapping in toolkits</span>
        <span class="n">adjusted_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">current</span><span class="p">,</span> <span class="n">new</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">current</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">offmol</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="n">adjusted_mapping</span><span class="p">,</span> <span class="n">current_to_new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@requires_package</span><span class="p">(</span><span class="s2">&quot;qcelemental&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">from_qcschema</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">qca_record</span><span class="p">,</span>
        <span class="n">client</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Molecule from a QCArchive molecule record or dataset entry</span>
<span class="sd">        based on attached cmiles information.</span>

<span class="sd">        For a molecule record, a conformer will be set from its geometry.</span>

<span class="sd">        For a dataset entry, if a corresponding client instance is provided,</span>
<span class="sd">        the starting geometry for that entry will be used as a conformer.</span>

<span class="sd">        A QCElemental Molecule produced from ``Molecule.to_qcschema`` can be round-tripped</span>
<span class="sd">        through this method to produce a new, valid Molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qca_record : dict</span>
<span class="sd">            A QCArchive molecule record or dataset entry.</span>

<span class="sd">        client : optional, default=None,</span>
<span class="sd">            A qcportal.FractalClient instance to use for fetching an initial geometry.</span>
<span class="sd">            Only used if ``qca_record`` is a dataset entry.</span>

<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMILES-to-molecule conversion</span>

<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If false, raises an exception if qca_record contains undefined stereochemistry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>
<span class="sd">            An OpenFF molecule instance.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Get Molecule from a QCArchive molecule record:</span>

<span class="sd">        &gt;&gt;&gt; from qcportal import FractalClient</span>
<span class="sd">        &gt;&gt;&gt; client = FractalClient()</span>
<span class="sd">        &gt;&gt;&gt; offmol = Molecule.from_qcschema(client.query_molecules(molecular_formula=&quot;C16H20N3O5&quot;)[0])</span>

<span class="sd">        Get Molecule from a QCArchive optimization entry:</span>

<span class="sd">        &gt;&gt;&gt; from qcportal import FractalClient</span>
<span class="sd">        &gt;&gt;&gt; client = FractalClient()</span>
<span class="sd">        &gt;&gt;&gt; optds = client.get_collection(&quot;OptimizationDataset&quot;,</span>
<span class="sd">                                          &quot;SMIRNOFF Coverage Set 1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; offmol = Molecule.from_qcschema(optds.get_entry(&#39;coc(o)oc-0&#39;))</span>

<span class="sd">        Same as above, but with conformer(s) from initial molecule(s) by providing client to database:</span>

<span class="sd">        &gt;&gt;&gt; offmol = Molecule.from_qcschema(optds.get_entry(&#39;coc(o)oc-0&#39;), client=client)</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            - If the record dict can not be made from ``qca_record``.</span>
<span class="sd">            - If a ``client`` is passed and it could not retrieve the initial molecule.</span>

<span class="sd">        KeyError</span>
<span class="sd">            If the dict does not contain the ``canonical_isomeric_explicit_hydrogen_mapped_smiles``.</span>

<span class="sd">        InvalidConformerError</span>
<span class="sd">            Silent error, if the conformer could not be attached.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We can accept the Dataset entry record or the dict with JSON encoding</span>
        <span class="c1"># lets get it all in the dict rep</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qca_record</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">qca_record</span> <span class="o">=</span> <span class="n">qca_record</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;json&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="s2">&quot;The object passed could not be converted to a dict with json encoding&quot;</span>
                <span class="p">)</span>

        <span class="c1"># identify if this is a dataset entry</span>
        <span class="k">if</span> <span class="s2">&quot;attributes&quot;</span> <span class="ow">in</span> <span class="n">qca_record</span><span class="p">:</span>
            <span class="n">mapped_smiles</span> <span class="o">=</span> <span class="n">qca_record</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">][</span>
                <span class="s2">&quot;canonical_isomeric_explicit_hydrogen_mapped_smiles&quot;</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">client</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># try and find the initial molecule conformations and attach them</span>
                <span class="c1"># collect the input molecules</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">input_mols</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">query_molecules</span><span class="p">(</span>
                        <span class="nb">id</span><span class="o">=</span><span class="n">qca_record</span><span class="p">[</span><span class="s2">&quot;initial_molecules&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># this must be an optimisation record</span>
                    <span class="n">input_mols</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">query_molecules</span><span class="p">(</span>
                        <span class="nb">id</span><span class="o">=</span><span class="n">qca_record</span><span class="p">[</span><span class="s2">&quot;initial_molecule&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="s2">&quot;The provided client can not query molecules, make sure it is an instance of&quot;</span>
                        <span class="s2">&quot;qcportal.client.FractalClient() with the correct address.&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">input_mols</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># identify if this is a molecule record</span>
        <span class="k">elif</span> <span class="s2">&quot;extras&quot;</span> <span class="ow">in</span> <span class="n">qca_record</span><span class="p">:</span>
            <span class="n">mapped_smiles</span> <span class="o">=</span> <span class="n">qca_record</span><span class="p">[</span><span class="s2">&quot;extras&quot;</span><span class="p">][</span>
                <span class="s2">&quot;canonical_isomeric_explicit_hydrogen_mapped_smiles&quot;</span>
            <span class="p">]</span>
            <span class="n">input_mols</span> <span class="o">=</span> <span class="p">[</span><span class="n">qca_record</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;The record must contain the hydrogen mapped smiles to be safely made from the archive. &quot;</span>
                <span class="s2">&quot;It is not present in either &#39;attributes&#39; or &#39;extras&#39; on the provided `qca_record`&quot;</span>
            <span class="p">)</span>

        <span class="c1"># make a new molecule that has been reordered to match the cmiles mapping</span>
        <span class="n">offmol</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_mapped_smiles</span><span class="p">(</span>
            <span class="n">mapped_smiles</span><span class="p">,</span>
            <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span><span class="p">,</span>
            <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># now for each molecule convert and attach the input geometry</span>
        <span class="n">initial_ids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">molecule</span> <span class="ow">in</span> <span class="n">input_mols</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">mol</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;json&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mol</span> <span class="o">=</span> <span class="n">molecule</span>

            <span class="n">geometry</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mol</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">unit</span><span class="o">.</span><span class="n">bohr</span>
            <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">offmol</span><span class="o">.</span><span class="n">_add_conformer</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">))</span>
                <span class="c1"># in case this molecule didn&#39;t come from a server at all</span>
                <span class="k">if</span> <span class="s2">&quot;id&quot;</span> <span class="ow">in</span> <span class="n">mol</span><span class="p">:</span>
                    <span class="n">initial_ids</span><span class="p">[</span><span class="n">mol</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">offmol</span><span class="o">.</span><span class="n">n_conformers</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="n">InvalidConformerError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid conformer for this molecule, the geometry could not be attached.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># attach a dict that has the initial molecule ids and the number of the conformer it is stored in</span>
        <span class="c1"># if it&#39;s empty, don&#39;t bother</span>
        <span class="k">if</span> <span class="n">initial_ids</span><span class="p">:</span>
            <span class="n">offmol</span><span class="o">.</span><span class="n">_properties</span><span class="p">[</span><span class="s2">&quot;initial_molecules&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_ids</span>

        <span class="k">return</span> <span class="n">offmol</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@RDKitToolkitWrapper</span><span class="o">.</span><span class="n">requires_toolkit</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">from_pdb_and_smiles</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">smiles</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Molecule from a pdb file and a SMILES string using RDKit.</span>

<span class="sd">        Requires RDKit to be installed.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        The molecule is created and sanitised based on the SMILES string, we then find a mapping</span>
<span class="sd">        between this molecule and one from the PDB based only on atomic number and connections.</span>
<span class="sd">        The SMILES molecule is then reindexed to match the PDB, the conformer is attached, and the</span>
<span class="sd">        molecule returned.</span>

<span class="sd">        Note that any stereochemistry in the molecule is set by the SMILES, and not the coordinates</span>
<span class="sd">        of the PDB.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path: str</span>
<span class="sd">            PDB file path</span>
<span class="sd">        smiles : str</span>
<span class="sd">            a valid smiles string for the pdb, used for stereochemistry, formal charges, and bond order</span>
<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If false, raises an exception if SMILES contains undefined stereochemistry.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        molecule : openff.toolkit.Molecule</span>
<span class="sd">            An OFFMol instance with ordering the same as used in the PDB file.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        InvalidConformerError</span>
<span class="sd">            If the SMILES and PDB molecules are not isomorphic.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">toolkit</span> <span class="o">=</span> <span class="n">RDKitToolkitWrapper</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_pdb_and_smiles</span><span class="p">(</span>
            <span class="n">file_path</span><span class="p">,</span> <span class="n">smiles</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="p">,</span> <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">canonical_order_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Canonical order the atoms in a copy of the molecule using a toolkit, returns a new copy.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or openff.toolkit.utils.toolkits.ToolkitWrapper, optional</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMILES-to-molecule conversion</span>

<span class="sd">         Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>
<span class="sd">            An new OpenFF style molecule with atoms in the canonical order.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;canonical_order_atoms&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="k">return</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">canonical_order_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to from_smiles. Expected ToolkitRegistry or ToolkitWrapper. Got  </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">remap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping_dict</span><span class="p">,</span> <span class="n">current_to_new</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remap all of the indexes in the molecule to match the given mapping dict</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapping_dict : dict,</span>
<span class="sd">            A dictionary of the mapping between indexes, this should start from 0.</span>
<span class="sd">        current_to_new : bool, default=True</span>
<span class="sd">            If this is ``True``, then ``mapping_dict`` is of the form ``{current_index: new_index}``;</span>
<span class="sd">            otherwise, it is of the form ``{new_index: current_index}``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_molecule :  openff.toolkit.topology.molecule.Molecule</span>
<span class="sd">            An openff.toolkit.Molecule instance with all attributes transferred, in the PDB order.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_virtual_sites</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;We can not remap virtual sites yet!&quot;</span><span class="p">)</span>

        <span class="c1"># make sure the size of the mapping matches the current molecule</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The number of mapping indices(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not match the number of&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;atoms in this molecule(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># make two mapping dicts we need new to old for atoms</span>
        <span class="c1"># and old to new for bonds</span>
        <span class="k">if</span> <span class="n">current_to_new</span><span class="p">:</span>
            <span class="n">cur_to_new</span> <span class="o">=</span> <span class="n">mapping_dict</span>
            <span class="n">new_to_cur</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">mapping_dict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">mapping_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_to_cur</span> <span class="o">=</span> <span class="n">mapping_dict</span>
            <span class="n">cur_to_new</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">mapping_dict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">mapping_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="n">new_molecule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        <span class="n">new_molecule</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># add the atoms list</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">):</span>
                <span class="c1"># get the old atom info</span>
                <span class="n">old_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="n">new_to_cur</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">new_molecule</span><span class="o">.</span><span class="n">_add_atom</span><span class="p">(</span><span class="o">**</span><span class="n">old_atom</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
        <span class="c1"># this is the first time we access the mapping; catch an index error here corresponding to mapping that starts</span>
        <span class="c1"># from 0 or higher</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The mapping supplied is missing a relation corresponding to atom(</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># add the bonds but with atom indexes in a sorted ascending order</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">cur_to_new</span><span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1_index</span><span class="p">],</span> <span class="n">cur_to_new</span><span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2_index</span><span class="p">]])</span>
            <span class="n">bond_dict</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">new_molecule</span><span class="o">.</span><span class="n">_add_bond</span><span class="p">(</span><span class="o">**</span><span class="n">bond_dict</span><span class="p">)</span>

        <span class="c1"># we can now resort the bonds</span>
        <span class="n">sorted_bonds</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">new_molecule</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;atom1_index&quot;</span><span class="p">,</span> <span class="s2">&quot;atom2_index&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">new_molecule</span><span class="o">.</span><span class="n">_bonds</span> <span class="o">=</span> <span class="n">sorted_bonds</span>

        <span class="c1"># remap the charges</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_charges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">):</span>
                <span class="n">new_charges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_charges</span><span class="p">[</span><span class="n">new_to_cur</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span>
                    <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span>
                <span class="p">)</span>
            <span class="n">new_molecule</span><span class="o">.</span><span class="n">partial_charges</span> <span class="o">=</span> <span class="n">new_charges</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span>

        <span class="c1"># remap the conformers there can be more than one</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">conformer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformers</span><span class="p">:</span>
                <span class="n">new_conformer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">):</span>
                    <span class="n">new_conformer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">conformer</span><span class="p">[</span><span class="n">new_to_cur</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span>
                        <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span>
                    <span class="p">)</span>
                <span class="n">new_molecule</span><span class="o">.</span><span class="n">_add_conformer</span><span class="p">(</span><span class="n">new_conformer</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>

        <span class="c1"># move any properties across</span>
        <span class="n">new_molecule</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span>

        <span class="k">return</span> <span class="n">new_molecule</span>

    <span class="nd">@OpenEyeToolkitWrapper</span><span class="o">.</span><span class="n">requires_toolkit</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">to_openeye</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aromaticity_model</span><span class="o">=</span><span class="n">DEFAULT_AROMATICITY_MODEL</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an OpenEye molecule</span>

<span class="sd">        Requires the OpenEye toolkit to be installed.</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * Use stored conformer positions instead of an argument.</span>
<span class="sd">           * Should the aromaticity model be specified in some other way?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        aromaticity_model : str, optional, default=DEFAULT_AROMATICITY_MODEL</span>
<span class="sd">            The aromaticity model to use</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        oemol : openeye.oechem.OEMol</span>
<span class="sd">            An OpenEye molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create an OpenEye molecule from a Molecule</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;CC&#39;)</span>
<span class="sd">        &gt;&gt;&gt; oemol = molecule.to_openeye()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">toolkit</span> <span class="o">=</span> <span class="n">OpenEyeToolkitWrapper</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">to_openeye</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aromaticity_model</span><span class="o">=</span><span class="n">aromaticity_model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an iterator over all i-j-k angles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Build Angle objects instead of tuple of atoms.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_angles&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_construct_bonded_atoms_list</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom1</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">atom3</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom2</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">atom1</span> <span class="o">==</span> <span class="n">atom3</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="c1"># TODO: Encapsulate this logic into an Angle class.</span>
                        <span class="k">if</span> <span class="n">atom1</span><span class="o">.</span><span class="n">molecule_atom_index</span> <span class="o">&lt;</span> <span class="n">atom3</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">atom3</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">atom3</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">atom1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_construct_torsions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct sets containing the atoms improper and proper torsions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Build Proper/ImproperTorsion objects instead of tuple of atoms.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_torsions&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_construct_bonded_atoms_list</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_propers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom1</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">atom3</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom2</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">atom1</span> <span class="o">==</span> <span class="n">atom3</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">for</span> <span class="n">atom4</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom3</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">atom4</span> <span class="o">==</span> <span class="n">atom2</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="c1"># Exclude i-j-k-i</span>
                            <span class="k">if</span> <span class="n">atom1</span> <span class="o">==</span> <span class="n">atom4</span><span class="p">:</span>
                                <span class="k">continue</span>

                            <span class="k">if</span> <span class="n">atom1</span><span class="o">.</span><span class="n">molecule_atom_index</span> <span class="o">&lt;</span> <span class="n">atom4</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">:</span>
                                <span class="n">torsion</span> <span class="o">=</span> <span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">atom3</span><span class="p">,</span> <span class="n">atom4</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">torsion</span> <span class="o">=</span> <span class="p">(</span><span class="n">atom4</span><span class="p">,</span> <span class="n">atom3</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">atom1</span><span class="p">)</span>

                            <span class="bp">self</span><span class="o">.</span><span class="n">_propers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">atom3i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom2</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">atom3i</span> <span class="o">==</span> <span class="n">atom3</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="k">if</span> <span class="n">atom3i</span> <span class="o">==</span> <span class="n">atom1</span><span class="p">:</span>
                                <span class="k">continue</span>

                            <span class="n">improper</span> <span class="o">=</span> <span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">atom3</span><span class="p">,</span> <span class="n">atom3i</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">improper</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_torsions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propers</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span>

    <span class="k">def</span> <span class="nf">_construct_bonded_atoms_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct list of all atoms each atom is bonded to.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add this to cached_properties</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_bondedAtoms&quot;</span><span class="p">):</span>
            <span class="c1"># self._atoms = [ atom for atom in self.atoms() ]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="p">:</span>
                <span class="n">atom1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1_index</span><span class="p">]</span>
                <span class="n">atom2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2_index</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom2</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_bonded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_index_1</span><span class="p">,</span> <span class="n">atom_index_2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if atoms are bonded, False if not.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom_index_1 : int</span>
<span class="sd">        atom_index_2 : int</span>
<span class="sd">            Atom indices</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_bonded : bool</span>
<span class="sd">            True if atoms are bonded, False otherwise</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_bonded_atoms_list</span><span class="p">()</span>
        <span class="n">atom1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="n">atom_index_1</span><span class="p">]</span>
        <span class="n">atom2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="n">atom_index_2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_bond_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the bond between two atoms</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i, j : int or Atom</span>
<span class="sd">            Atoms or atom indices to check</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bond : Bond</span>
<span class="sd">            The bond between i and j.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">atom_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">atom_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">atom_i</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">atom_j</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid input passed to get_bond_between(). Expected ints or Atoms, &quot;</span>
                <span class="s2">&quot;got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">atom_i</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">bond</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">atom</span> <span class="o">==</span> <span class="n">atom_i</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">atom</span> <span class="o">==</span> <span class="n">atom_j</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">bond</span>

        <span class="kn">from</span> <span class="nn">openff.toolkit.topology</span> <span class="kn">import</span> <span class="n">NotBondedError</span>

        <span class="k">raise</span> <span class="n">NotBondedError</span><span class="p">(</span><span class="s2">&quot;No bond between atom </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of rings in this molecule.</span>

<span class="sd">        Requires the RDKit to be installed.</span>

<span class="sd">        .. note ::</span>

<span class="sd">            For systems containing some special cases of connected rings, this</span>
<span class="sd">            function may not be well-behaved and may report a different number</span>
<span class="sd">            rings than expected. Some problematic cases include networks of many</span>
<span class="sd">            (5+) rings or bicyclic moieties (i.e. norbornane).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_rings</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rings</span>

    <span class="nd">@RDKitToolkitWrapper</span><span class="o">.</span><span class="n">requires_toolkit</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_get_rings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call out to RDKitToolkitWrapper methods to find the rings in this molecule.</span>

<span class="sd">        Requires the RDKit to be installed.</span>

<span class="sd">        .. note ::</span>

<span class="sd">            For systems containing some special cases of connected rings, this</span>
<span class="sd">            function may not be well-behaved and may report a different number</span>
<span class="sd">            rings than expected. Some problematic cases include networks of many</span>
<span class="sd">            (5+) rings or bicyclic moieties (i.e. norbornane).</span>

<span class="sd">        .. todo :: This could be refactored to use ToolkitWrapper.call() to flexibly</span>
<span class="sd">            access other toolkits, if find_rings is implemented.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rings : tuple of tuple of int</span>
<span class="sd">            A nested tuple with one subtuple per ring and each subtuple containing</span>
<span class="sd">            a tuple of the indices of atoms containing with it. If no rings are</span>
<span class="sd">            found, a single empty tuple is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">toolkit</span> <span class="o">=</span> <span class="n">RDKitToolkitWrapper</span><span class="p">()</span>
        <span class="n">rings</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">find_rings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rings</span> <span class="o">=</span> <span class="n">rings</span>


<div class="viewcode-block" id="Molecule"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule">[docs]</a><span class="k">class</span> <span class="nc">Molecule</span><span class="p">(</span><span class="n">FrozenMolecule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mutable chemical representation of a molecule, such as a small molecule or biopolymer.</span>

<span class="sd">    .. todo :: What other API calls would be useful for supporting biopolymers as small molecules? Perhaps iterating over chains and residues?</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Create a molecule from an sdf file</span>

<span class="sd">    &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">    &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">    &gt;&gt;&gt; molecule = Molecule(sdf_filepath)</span>

<span class="sd">    Convert to OpenEye OEMol object</span>

<span class="sd">    &gt;&gt;&gt; oemol = molecule.to_openeye()</span>

<span class="sd">    Create a molecule from an OpenEye molecule</span>

<span class="sd">    &gt;&gt;&gt; molecule = Molecule.from_openeye(oemol)</span>

<span class="sd">    Convert to RDKit Mol object</span>

<span class="sd">    &gt;&gt;&gt; rdmol = molecule.to_rdkit()</span>

<span class="sd">    Create a molecule from an RDKit molecule</span>

<span class="sd">    &gt;&gt;&gt; molecule = Molecule.from_rdkit(rdmol)</span>

<span class="sd">    Create a molecule from IUPAC name (requires the OpenEye toolkit)</span>

<span class="sd">    &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;imatinib&#39;)</span>

<span class="sd">    Create a molecule from SMILES</span>

<span class="sd">    &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;Cc1ccccc1&#39;)</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Molecule.__init__"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Molecule object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : optional, default=None</span>
<span class="sd">            If specified, attempt to construct a copy of the Molecule from the</span>
<span class="sd">            specified object. This can be any one of the following:</span>

<span class="sd">            * a :class:`Molecule` object</span>
<span class="sd">            * a file that can be used to construct a :class:`Molecule` object</span>
<span class="sd">            * an ``openeye.oechem.OEMol``</span>
<span class="sd">            * an ``rdkit.Chem.rdchem.Mol``</span>
<span class="sd">            * a serialized :class:`Molecule` object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create an empty molecule:</span>

<span class="sd">        &gt;&gt;&gt; empty_molecule = Molecule()</span>

<span class="sd">        Create a molecule from a file that can be used to construct a molecule,</span>
<span class="sd">        using either a filename or file-like object:</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule(sdf_filepath)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule(open(sdf_filepath, &#39;r&#39;), file_format=&#39;sdf&#39;)</span>

<span class="sd">        &gt;&gt;&gt; import gzip</span>
<span class="sd">        &gt;&gt;&gt; mol2_gz_filepath = get_data_file_path(&#39;molecules/toluene.mol2.gz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule(gzip.GzipFile(mol2_gz_filepath, &#39;r&#39;), file_format=&#39;mol2&#39;)</span>

<span class="sd">        Create a molecule from another molecule:</span>

<span class="sd">        &gt;&gt;&gt; molecule_copy = Molecule(molecule)</span>

<span class="sd">        Convert to OpenEye OEMol object</span>

<span class="sd">        &gt;&gt;&gt; oemol = molecule.to_openeye()</span>

<span class="sd">        Create a molecule from an OpenEye molecule:</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule(oemol)</span>

<span class="sd">        Convert to RDKit Mol object</span>

<span class="sd">        &gt;&gt;&gt; rdmol = molecule.to_rdkit()</span>

<span class="sd">        Create a molecule from an RDKit molecule:</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule(rdmol)</span>

<span class="sd">        Create a molecule from a serialized molecule object:</span>

<span class="sd">        &gt;&gt;&gt; serialized_molecule = molecule.__getstate__()</span>
<span class="sd">        &gt;&gt;&gt; molecule_copy = Molecule(serialized_molecule)</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * If a filename or file-like object is specified but the file</span>
<span class="sd">             contains more than one molecule, what is the proper behavior?</span>
<span class="sd">             Read just the first molecule, or raise an exception if more</span>
<span class="sd">             than one molecule is found?</span>

<span class="sd">           * Should we also support SMILES strings or IUPAC names for</span>
<span class="sd">             ``other``?</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># super(self, Molecule).__init__(*args, **kwargs)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Molecule</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># TODO: Change this to add_atom(Atom) to improve encapsulation and extensibility?</span>
<div class="viewcode-block" id="Molecule.add_atom"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.add_atom">[docs]</a>    <span class="k">def</span> <span class="nf">add_atom</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">atomic_number</span><span class="p">,</span> <span class="n">formal_charge</span><span class="p">,</span> <span class="n">is_aromatic</span><span class="p">,</span> <span class="n">stereochemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an atom</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atomic_number : int</span>
<span class="sd">            Atomic number of the atom</span>
<span class="sd">        formal_charge : int</span>
<span class="sd">            Formal charge of the atom</span>
<span class="sd">        is_aromatic : bool</span>
<span class="sd">            If ``True``, atom is aromatic; if ``False``, not aromatic</span>
<span class="sd">        stereochemistry : str, optional, default=None</span>
<span class="sd">            Either ``&#39;R&#39;`` or ``&#39;S&#39;`` for specified stereochemistry, or ``None`` if stereochemistry is irrelevant</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            An optional name for the atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the atom in the molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Define a methane molecule</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule()</span>
<span class="sd">        &gt;&gt;&gt; molecule.name = &#39;methane&#39;</span>
<span class="sd">        &gt;&gt;&gt; C = molecule.add_atom(6, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H1 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H2 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H3 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H4 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H1, False, 1)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H2, False, 1)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H3, False, 1)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H4, False, 1)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atom_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_atom</span><span class="p">(</span>
            <span class="n">atomic_number</span><span class="p">,</span>
            <span class="n">formal_charge</span><span class="p">,</span>
            <span class="n">is_aromatic</span><span class="p">,</span>
            <span class="n">stereochemistry</span><span class="o">=</span><span class="n">stereochemistry</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">atom_index</span></div>

<div class="viewcode-block" id="Molecule.add_bond_charge_virtual_site"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.add_bond_charge_virtual_site">[docs]</a>    <span class="k">def</span> <span class="nf">add_bond_charge_virtual_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a virtual site representing the charge on a bond.</span>

<span class="sd">        Create a bond charge-type virtual site, in which the location of the</span>
<span class="sd">        charge is specified by the position of two atoms. This supports</span>
<span class="sd">        placement of a virtual site :math:`S` along a vector between two specified</span>
<span class="sd">        atoms, e.g. to allow for a sigma hole for halogens or similar contexts.</span>
<span class="sd">        With positive values of the distance, the virtual site lies outside the</span>
<span class="sd">        first indexed atom.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : list of :class:`openff.toolkit.topology.molecule.Atom` objects</span>
<span class="sd">            The atoms defining the virtual site&#39;s position</span>

<span class="sd">        distance : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a scalar</span>

<span class="sd">        charge_increments : list of floats of shape [N], optional, default=None</span>
<span class="sd">            The amount of charge to remove from the VirtualSite&#39;s atoms and put</span>
<span class="sd">            in the VirtualSite. Indexing in this list should match the ordering</span>
<span class="sd">            in the atoms list. Default is None.</span>
<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon term for VdW properties of virtual site. Default is ``None``.</span>
<span class="sd">        sigma : float, default=None</span>
<span class="sd">            Sigma term for VdW properties of virtual site. Default is ``None``.</span>
<span class="sd">        rmin_half : float</span>
<span class="sd">            Rmin_half term for VdW properties of virtual site. Default is ``None``.</span>
<span class="sd">        name : string or None, default=&#39;&#39;</span>
<span class="sd">            The name of this virtual site. Default is &#39;&#39;.</span>
<span class="sd">        symmetric : bool, default=True</span>
<span class="sd">            Whether to make virtual site symmetric by creating two particles</span>
<span class="sd">            instead of just one. As an example, for N_2 this should be set to</span>
<span class="sd">            True to model both lone pairs with the same parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the newly-added virtual site in the molecule</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;orientations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;orientations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">vsite_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_bond_charge_virtual_site</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vsite_index</span></div>

<div class="viewcode-block" id="Molecule.add_monovalent_lone_pair_virtual_site"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.add_monovalent_lone_pair_virtual_site">[docs]</a>    <span class="k">def</span> <span class="nf">add_monovalent_lone_pair_virtual_site</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">out_of_plane_angle</span><span class="p">,</span> <span class="n">in_plane_angle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a bond charge-type virtual site, in which the location of the charge is specified by the position of three atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : list of three :class:`openff.toolkit.topology.molecule.Atom` objects</span>
<span class="sd">            The three atoms defining the virtual site&#39;s position</span>

<span class="sd">        distance : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a scalar</span>

<span class="sd">        out_of_plane_angle : :class:`openmm.unit.Quantity` of dimension [Angle] wrapping</span>
<span class="sd">        a scalar</span>

<span class="sd">        in_plane_angle : :class:`openmm.unit.Quantity` of dimension [Angle] wrapping a</span>
<span class="sd">        scalar</span>

<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        sigma : float, default=None</span>
<span class="sd">            Sigma term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        rmin_half : float</span>
<span class="sd">            Rmin_half term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        name : string or None, default=&#39;&#39;</span>
<span class="sd">            The name of this virtual site. Default is &#39;&#39;.</span>
<span class="sd">        symmetric : bool, default=False</span>
<span class="sd">            Whether to make virtual site symmetric by creating two particles</span>
<span class="sd">            instead of just one. Note that because this site is defined is placed</span>
<span class="sd">            on the noncentral atom, setting this to True will place one particle</span>
<span class="sd">            on atom1, and the other on atom3.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the newly-added virtual site in the molecule</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;orientations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;orientations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">vsite_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_monovalent_lone_pair_virtual_site</span><span class="p">(</span>
            <span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">out_of_plane_angle</span><span class="p">,</span> <span class="n">in_plane_angle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">vsite_index</span></div>

    <span class="c1"># def add_divalent_lone_pair_virtual_site(self, atoms, distance, out_of_plane_angle, in_plane_angle, charge_increments=None, weights=None, epsilon=None, sigma=None, rmin_half=None, name=None):</span>
<div class="viewcode-block" id="Molecule.add_divalent_lone_pair_virtual_site"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.add_divalent_lone_pair_virtual_site">[docs]</a>    <span class="k">def</span> <span class="nf">add_divalent_lone_pair_virtual_site</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">out_of_plane_angle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a divalent lone pair-type virtual site, in which the location of the charge is specified by the position of three atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : list of three :class:`openff.toolkit.topology.molecule.Atom` objects</span>
<span class="sd">            The three atoms defining the virtual site&#39;s position</span>

<span class="sd">        distance : :class:`openmm.unit.Quantity` of dimension [Length] wrapping a scalar</span>

<span class="sd">        out_of_plane_angle : :class:`openmm.unit.Quantity` of dimension [Angle] wrapping</span>
<span class="sd">        a scalar</span>

<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        sigma : float, default=None</span>
<span class="sd">            Sigma term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        rmin_half : float</span>
<span class="sd">            Rmin_half term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        name : string or None, default=&#39;&#39;</span>
<span class="sd">            The name of this virtual site. Default is &#39;&#39;.</span>
<span class="sd">        symmetric : bool, default=True</span>
<span class="sd">            Whether to make virtual site symmetric by creating two particles</span>
<span class="sd">            instead of just one. As an example, for TIP5 should be set to True</span>
<span class="sd">            to model both lone pairs with the same parameters.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the newly-added virtual site in the molecule</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;orientations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;orientations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">vsite_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_divalent_lone_pair_virtual_site</span><span class="p">(</span>
            <span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">out_of_plane_angle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">vsite_index</span></div>

<div class="viewcode-block" id="Molecule.add_trivalent_lone_pair_virtual_site"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.add_trivalent_lone_pair_virtual_site">[docs]</a>    <span class="k">def</span> <span class="nf">add_trivalent_lone_pair_virtual_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a trivalent lone pair-type virtual site, in which the location of the charge is specified by the position of four atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : list of four :class:`openff.toolkit.topology.molecule.Atom` objects</span>
<span class="sd">            The four atoms defining the virtual site&#39;s position</span>

<span class="sd">        distance : openmm.unit.Quantity of dimension [Length] wrapping a scalar</span>

<span class="sd">        epsilon : float</span>
<span class="sd">            Epsilon term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        sigma : float, default=None</span>
<span class="sd">            Sigma term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        rmin_half : float</span>
<span class="sd">            Rmin_half term for VdW properties of virtual site. Default is None.</span>
<span class="sd">        name : string or None, default=&#39;&#39;</span>
<span class="sd">            The name of this virtual site. Default is &#39;&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the newly-added virtual site in the molecule</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This virtual site only makes sense with a single orientation</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;orientations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">vsite_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_trivalent_lone_pair_virtual_site</span><span class="p">(</span>
            <span class="n">atoms</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">vsite_index</span></div>

<div class="viewcode-block" id="Molecule.add_bond"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.add_bond">[docs]</a>    <span class="k">def</span> <span class="nf">add_bond</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atom1</span><span class="p">,</span>
        <span class="n">atom2</span><span class="p">,</span>
        <span class="n">bond_order</span><span class="p">,</span>
        <span class="n">is_aromatic</span><span class="p">,</span>
        <span class="n">stereochemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fractional_bond_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a bond between two specified atom indices</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom1 : int or openff.toolkit.topology.molecule.Atom</span>
<span class="sd">            Index of first atom</span>
<span class="sd">        atom2 : int or openff.toolkit.topology.molecule.Atom</span>
<span class="sd">            Index of second atom</span>
<span class="sd">        bond_order : int</span>
<span class="sd">            Integral bond order of Kekulized form</span>
<span class="sd">        is_aromatic : bool</span>
<span class="sd">            True if this bond is aromatic, False otherwise</span>
<span class="sd">        stereochemistry : str, optional, default=None</span>
<span class="sd">            Either ``&#39;E&#39;`` or ``&#39;Z&#39;`` for specified stereochemistry, or ``None`` if stereochemistry is irrelevant</span>
<span class="sd">        fractional_bond_order : float, optional, default=None</span>
<span class="sd">            The fractional (eg. Wiberg) bond order</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index: int</span>
<span class="sd">            Index of the bond in this molecule</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bond_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_bond</span><span class="p">(</span>
            <span class="n">atom1</span><span class="p">,</span>
            <span class="n">atom2</span><span class="p">,</span>
            <span class="n">bond_order</span><span class="p">,</span>
            <span class="n">is_aromatic</span><span class="p">,</span>
            <span class="n">stereochemistry</span><span class="o">=</span><span class="n">stereochemistry</span><span class="p">,</span>
            <span class="n">fractional_bond_order</span><span class="o">=</span><span class="n">fractional_bond_order</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">bond_index</span></div>

<div class="viewcode-block" id="Molecule.add_conformer"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.add_conformer">[docs]</a>    <span class="k">def</span> <span class="nf">add_conformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a conformation of the molecule</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates: openmm.unit.Quantity(np.array) with shape (n_atoms, 3) and dimension of distance</span>
<span class="sd">            Coordinates of the new conformer, with the first dimension of the array corresponding to the atom index in</span>
<span class="sd">            the Molecule&#39;s indexing system.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index: int</span>
<span class="sd">            The index of this conformer</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO how can be check that a set of coords and no connections</span>
        <span class="c1">#   is a conformation that does not change connectivity?</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_conformer</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.visualize"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.visualize">[docs]</a>    <span class="k">def</span> <span class="nf">visualize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">backend</span><span class="o">=</span><span class="s2">&quot;rdkit&quot;</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_all_hydrogens</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render a visualization of the molecule in Jupyter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        backend : str, optional, default=&#39;rdkit&#39;</span>
<span class="sd">            Which visualization engine to use. Choose from:</span>

<span class="sd">            - rdkit</span>
<span class="sd">            - openeye</span>
<span class="sd">            - nglview (conformers needed)</span>

<span class="sd">        width : int, optional, default=500</span>
<span class="sd">            Width of the generated representation (only applicable to</span>
<span class="sd">            ``backend=openeye`` or ``backend=rdkit``)</span>
<span class="sd">        height : int, optional, default=300</span>
<span class="sd">            Width of the generated representation (only applicable to</span>
<span class="sd">            ``backend=openeye`` or ``backend=rdkit``)</span>
<span class="sd">        show_all_hydrogens : bool, optional, default=True</span>
<span class="sd">            Whether to explicitly depict all hydrogen atoms. (only applicable to</span>
<span class="sd">            ``backend=openeye`` or ``backend=rdkit``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            Depending on the backend chosen:</span>

<span class="sd">            - rdkit  IPython.display.SVG</span>
<span class="sd">            - openeye  IPython.display.Image</span>
<span class="sd">            - nglview  nglview.NGLWidget</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openff.toolkit.utils.toolkits</span> <span class="kn">import</span> <span class="n">OPENEYE_AVAILABLE</span><span class="p">,</span> <span class="n">RDKIT_AVAILABLE</span>

        <span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;nglview&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">nglview</span> <span class="k">as</span> <span class="nn">nv</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MissingDependencyError</span><span class="p">(</span><span class="s2">&quot;nglview&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">height</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># TODO: More specific exception</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The width, height, and show_all_hydrogens arguments do not apply to the nglview backend.&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">show_all_hydrogens</span><span class="p">:</span>
                <span class="c1"># TODO: More specific exception</span>
                <span class="c1"># TODO: Implement this? Should be able to just strip hydrogens from the PDB</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;show_all_hydrogens=False is not supported by the nglview backend&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformers</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">openff.toolkit.utils.viz</span> <span class="kn">import</span> <span class="n">_OFFTrajectoryNGLView</span>

                <span class="n">trajectory_like</span> <span class="o">=</span> <span class="n">_OFFTrajectoryNGLView</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">widget</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">NGLWidget</span><span class="p">(</span><span class="n">trajectory_like</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">widget</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: More specific exception</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Visualizing with NGLview requires that the molecule has &quot;</span>
                    <span class="s2">&quot;conformers.&quot;</span>
                <span class="p">)</span>

        <span class="n">width</span> <span class="o">=</span> <span class="mi">500</span> <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">width</span>
        <span class="n">height</span> <span class="o">=</span> <span class="mi">300</span> <span class="k">if</span> <span class="n">height</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">height</span>
        <span class="n">show_all_hydrogens</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">show_all_hydrogens</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">show_all_hydrogens</span>

        <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;rdkit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">RDKIT_AVAILABLE</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">SVG</span>
                <span class="kn">from</span> <span class="nn">rdkit.Chem.Draw</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># type: ignore[import]</span>
                    <span class="n">rdDepictor</span><span class="p">,</span>
                    <span class="n">rdMolDraw2D</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="kn">from</span> <span class="nn">rdkit.Chem.rdmolops</span> <span class="kn">import</span> <span class="n">RemoveHs</span>  <span class="c1"># type: ignore[import]</span>

                <span class="n">rdmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">()</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">show_all_hydrogens</span><span class="p">:</span>
                    <span class="c1"># updateExplicitCount: Keep a record of the hydrogens we remove.</span>
                    <span class="c1"># This is used in visualization to distinguish eg radicals from normal species</span>
                    <span class="n">rdmol</span> <span class="o">=</span> <span class="n">RemoveHs</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">updateExplicitCount</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">rdDepictor</span><span class="o">.</span><span class="n">SetPreferCoordGen</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">rdDepictor</span><span class="o">.</span><span class="n">Compute2DCoords</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
                <span class="n">rdmol</span> <span class="o">=</span> <span class="n">rdMolDraw2D</span><span class="o">.</span><span class="n">PrepareMolForDrawing</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

                <span class="n">drawer</span> <span class="o">=</span> <span class="n">rdMolDraw2D</span><span class="o">.</span><span class="n">MolDraw2DSVG</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
                <span class="n">drawer</span><span class="o">.</span><span class="n">DrawMolecule</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
                <span class="n">drawer</span><span class="o">.</span><span class="n">FinishDrawing</span><span class="p">()</span>

                <span class="k">return</span> <span class="n">SVG</span><span class="p">(</span><span class="n">drawer</span><span class="o">.</span><span class="n">GetDrawingText</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;RDKit was requested as a visualization backend but &quot;</span>
                    <span class="s2">&quot;it was not found to be installed. Falling back to &quot;</span>
                    <span class="s2">&quot;trying to use OpenEye for visualization.&quot;</span>
                <span class="p">)</span>
                <span class="n">backend</span> <span class="o">=</span> <span class="s2">&quot;openeye&quot;</span>
        <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;openeye&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">OPENEYE_AVAILABLE</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">Image</span>
                <span class="kn">from</span> <span class="nn">openeye</span> <span class="kn">import</span> <span class="n">oedepict</span>

                <span class="n">oemol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_openeye</span><span class="p">()</span>

                <span class="n">opts</span> <span class="o">=</span> <span class="n">oedepict</span><span class="o">.</span><span class="n">OE2DMolDisplayOptions</span><span class="p">(</span>
                    <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">oedepict</span><span class="o">.</span><span class="n">OEScale_AutoScale</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">show_all_hydrogens</span><span class="p">:</span>
                    <span class="n">opts</span><span class="o">.</span><span class="n">SetHydrogenStyle</span><span class="p">(</span><span class="n">oedepict</span><span class="o">.</span><span class="n">OEHydrogenStyle_ImplicitAll</span><span class="p">)</span>

                <span class="n">oedepict</span><span class="o">.</span><span class="n">OEPrepareDepiction</span><span class="p">(</span><span class="n">oemol</span><span class="p">)</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">oedepict</span><span class="o">.</span><span class="n">OEImage</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
                <span class="n">display</span> <span class="o">=</span> <span class="n">oedepict</span><span class="o">.</span><span class="n">OE2DMolDisplay</span><span class="p">(</span><span class="n">oemol</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>
                <span class="n">oedepict</span><span class="o">.</span><span class="n">OERenderMolecule</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">display</span><span class="p">)</span>
                <span class="n">png</span> <span class="o">=</span> <span class="n">oedepict</span><span class="o">.</span><span class="n">OEWriteImageToString</span><span class="p">(</span><span class="s2">&quot;png&quot;</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">png</span><span class="p">)</span>

        <span class="c1"># TODO: More specific exception</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find an appropriate backend&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_ipython_display_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;nglview&quot;</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;rdkit&quot;</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;openeye&quot;</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span></div>


<span class="k">def</span> <span class="nf">_networkx_graph_to_hill_formula</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="s2">&quot;nx.Graph&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a NetworkX graph to a Hill formula.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : nx.Graph</span>
<span class="sd">        The graph to convert.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        The Hill formula corresponding to the graph.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The graph must be a NetworkX graph.&quot;</span><span class="p">)</span>

    <span class="n">atom_nums</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;atomic_number&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">_atom_nums_to_hill_formula</span><span class="p">(</span><span class="n">atom_nums</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_topologymolecule_to_hill_formula</span><span class="p">(</span><span class="n">topology_molecule</span><span class="p">:</span> <span class="s2">&quot;TopologyMolecule&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a TopologyMolecule to a Hill formula.</span>

<span class="sd">    This function exists only to maintain backwards-compatibility with the old</span>
<span class="sd">    behavior of Molecule.to_hill_formulat of Molecule.to_hill_formula, which was</span>
<span class="sd">    a static method that duck-typed inputs of Molecule or graph objects. When</span>
<span class="sd">    `TopologyMolecule` is removed, this should also be removed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    topology_molecule : TopologyMolecule</span>
<span class="sd">        The TopologyMolecule to convert.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        The Hill formula corresponding to the TopologyMolecule.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">atom_nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">atomic_number</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">topology_molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">_atom_nums_to_hill_formula</span><span class="p">(</span><span class="n">atom_nums</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_atom_nums_to_hill_formula</span><span class="p">(</span><span class="n">atom_nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a `Counter` object of atom counts by atomic number, generate the corresponding</span>
<span class="sd">    Hill formula. See https://en.wikipedia.org/wiki/Chemical_formula#Hill_system&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

    <span class="n">atom_symbol_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span>
        <span class="n">Element</span><span class="o">.</span><span class="n">getByAtomicNumber</span><span class="p">(</span><span class="n">atom_num</span><span class="p">)</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">atom_num</span> <span class="ow">in</span> <span class="n">atom_nums</span>
    <span class="p">)</span>

    <span class="n">formula</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Check for C and H first, to make a correct hill formula</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">atom_symbol_counts</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">atom_symbol_counts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
            <span class="n">formula</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">formula</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>

    <span class="c1"># now get the rest of the elements in alphabetical ordering</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">atom_symbol_counts</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">atom_symbol_counts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
        <span class="n">formula</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">formula</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
</pre></div>

          </article>
        </div>

        <aside class="column is-hidden-mobile is-2-desktop is-3-tablet">
          
        </aside>
      </div>
  </main>
  <footer class="footer">
  <div class="footer-content">
    <div class="columns">
      <div class="fineprint column">
          <div class="copyright">
              &#169; Copyright 2021, Open Force Field Initiative.
              
          </div>
          Last updated on
            Feb 09, 2022.
          <br/>
          Created using
          <a href="http://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
           and
          <a href="https://github.com/openforcefield/openff-sphinx-theme/">the Open Force Field Sphinx theme</a>
      </div>
      <div class="socials column">
        <p class="pb-3">An <a href="https://openforcefield.org/" class="has-text-white">Open Force Field Initiative</a> project.</p>
        <div>
          
            
              
                <a href="https://zenodo.org/communities/openforcefield/" class="icon has-text-light is-medium" title="OpenFF on Zenodo">
                  <i class="fa-lg ai-lg ai ai-zenodo"></i>
                </a>
              
            
              
                <a href="https://www.youtube.com/channel/UCh0aJSUm_sYr7nuTzhW806g" class="icon has-text-light is-medium" title="OpenFF on YouTube">
                  <i class="fa-lg ai-lg fab fa-youtube"></i>
                </a>
              
            
              
                <a href="https://github.com/openforcefield" class="icon has-text-light is-medium" title="OpenFF on GitHub">
                  <i class="fa-lg ai-lg fab fa-github"></i>
                </a>
              
            
              
                <a href="https://twitter.com/openforcefield" class="icon has-text-light is-medium" title="OpenFF on Twitter">
                  <i class="fa-lg ai-lg fab fa-twitter"></i>
                </a>
              
            
              
                <a href="https://www.linkedin.com/company/openforcefield/" class="icon has-text-light is-medium" title="OpenFF on LinkedIn">
                  <i class="fa-lg ai-lg fab fa-linkedin"></i>
                </a>
              
            
          
        </div>

      </div>
    </div>
  </div>
</footer>
  </body>
</html>