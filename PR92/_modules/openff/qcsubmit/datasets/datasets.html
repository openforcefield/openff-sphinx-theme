
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  
  <link rel="icon" type="image/svg" href="../../../../_static/images/favicon.svg" />
  <link rel="apple-touch-icon" type="image/svg" href="../../../../_static/images/favicon.svg" />
  

  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="../../../../_static/site.css"/>
  
  <meta name="theme-color" content="#015480;">
  
  
    <title>openff.qcsubmit.datasets.datasets &#8212; OpenFF Sphinx theme</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/openff.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/autodoc_pydantic.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/rtd_sphinx_search.min.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/js/rtd_search_config.js"></script>
    <script src="../../../../_static/js/rtd_sphinx_search.min.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   

  </head>
  <body dir=ltr
        data-md-color-accent=openff-toolkit-blue
        class="has-navbar-fixed-top">
  <header data-md-component="header">
  <nav class="navbar is-primary is-fixed-top is-flex-touch has-shadow" role="navigation" aria-label="main navigation">
    <div class="navbar-brand">
      <a href="../../../../index.html" title="OpenFF Sphinx theme" class="navbar-item is-hidden-mobile">
        
          <img src="../../../../_static/images/logos/openforcefield_v1_white.png" alt="OpenFF Sphinx theme logo">
        
      </a>
    </div>

    <div class="has-text-light is-hidden-mobile nav-title">
      <div class="breadcrumb">
  <ul>
        <li><a href="../../../../index.html">OpenFF Sphinx theme</a></li>
      <li><a href="../../../index.html">Module code</a></li>
      <li class="is-active"><a href="#">openff.qcsubmit.datasets.datasets</a></li>
  </ul>
</div>
    </div>
    <div class="has-text-light is-hidden-tablet nav-title">
      <span> openff.qcsubmit.datasets.datasets </span>
    </div>

    <div class="navbar-end">
      <span class="navbar-item nav-search is-hidden-mobile" role="search">
        <form action="../../../../search.html" method="GET" name="search">
  <div class="control has-icons-right">
    <span class="icon is-small is-right">
      <i class="fas fa-search"></i>
    </span>
    <input class="input is-primary" type="text"  name="q" placeholder="Search"
         autocapitalize="off" autocomplete="off" spellcheck="false">
  </div>
</form>
      </span>
      
        <a href="https://github.com/openforcefield/openff-sphinx-theme/" class="is-family-monospace navbar-item is-hidden-touch has-text-light">
          
          <span class="icon-text">
            <span class="icon">
              <i class="fab fa-github"></i>
            </span>
            <span>
          
            openff-sphinx-theme
          
            </span>
          </span>
          
        </a>
      
      <a href="https://docs.openforcefield.org/" class="navbar-item is-hidden-touch">
        <img
          src="../../../../_static/images/logos/openforcefield_v2_white.png"
          alt="Open Force Field Initiative logo"
        >
      </a>
    </div>
    <span class="navbar-burger-spacer is-hidden-tablet"></span>
  </nav>

  

  <div class="level is-hidden-mobile nav-tabs">
      
      <div class="level-item has-text-centered"><a href="https://squidfunk.github.io/mkdocs-material/">Material for MkDocs</a></div>
      
      <div class="level-item has-text-centered"><a href="https://bashtage.github.io/sphinx-material/">Material for Sphinx</a></div>
      
      <div class="level-item has-text-centered"><a href="https://openforcefield.org">The OpenFF Initiative</a></div>
      
      <div class="level-item has-text-centered"><a href="https://github.com/openforcefield/openff-sphinx-theme/">openff-sphinx-theme on GitHub</a></div>
  </div>

</header>

  
  <main class="mb-6">
      <div class="columns">
        <input type="checkbox" id="drawer-toggle" class="is-hidden">
        <label for="drawer-toggle" role="button" class="navbar-burger burger is-light is-hidden-tablet">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </label>

        <aside class="column is-2-desktop is-3-tablet" id="drawer">
          <div class="is-hidden-tablet clip-siblings">
            <a href="../../../../index.html" title="OpenFF Sphinx theme">
              <h1>
                OpenFF Sphinx theme
              </h1>
            </a>
            
              <div class="py-3" role="search">
                <form action="../../../../search.html" method="GET" name="search">
  <div class="control has-icons-right">
    <span class="icon is-small is-right">
      <i class="fas fa-search"></i>
    </span>
    <input class="input is-primary" type="text"  name="q" placeholder="Search"
         autocapitalize="off" autocomplete="off" spellcheck="false">
  </div>
</form>
              </div>
            
          </div>
          
<nav class="menu ff-globaltoc">
          
          <p class="menu-label"><span class="caption-text">Basic Use</span></p>
          <ul class="menu-list">
        
      
          
          <li>
            <a href="../../../../customization.html" class="">Customization</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../specimen.html" class="">Specimen</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../additional_samples.html" class=""><code class="docutils literal notranslate"><span class="pre">additional_samples_with_very_long_name</span></code></a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../subpage/index.html" class=""><code class="docutils literal notranslate"><span class="pre">Level</span> <span class="pre">1</span></code> page</a>
            
            </li>
          
        
      
          
            </ul>
          
          <p class="menu-label"><span class="caption-text">Other Examples and Uses</span></p>
          <ul class="menu-list">
        
      
          
          <li>
            <a href="../../../../pymethod.html" class="">Python Methods</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../numpydoc_example.html" class="">NumPy Docstrings</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../autodoc_pydantic_example.html" class="">autodoc_pydantic API Docs</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../numpydoc.html" class="">Openff-toolkit example</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../pydantic.html" class="">Pydantic API docs</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../notebook.html" class="">Jupyter Notebooks</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../markdown.html" class="">Markdown</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../rst-cheatsheet/rst-cheatsheet.html" class="">rst Cheatsheet</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../primer.html" class="">reStructuredText Primer</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../expanded-tables.html" class="">Expanded tables</a>
            
            </li>
          
        
      
          
            </ul>
          
          <p class="menu-label"><span class="caption-text">Changes and License</span></p>
          <ul class="menu-list">
        
      
          
          <li>
            <a href="../../../../change-log.html" class="">Change Log</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../license.html" class="">License</a>
            
            </li>
          
            </ul>
          
        
      
    </ul>
  </nav>

        </aside>

        <div class="column is-8-desktop is-9-tablet">
          <article class="content">
            
  <h1>Source code for openff.qcsubmit.datasets.datasets</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Generator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">qcelemental</span> <span class="k">as</span> <span class="nn">qcel</span>
<span class="kn">import</span> <span class="nn">qcportal</span> <span class="k">as</span> <span class="nn">ptl</span>
<span class="kn">import</span> <span class="nn">tqdm</span>
<span class="kn">from</span> <span class="nn">openff.toolkit</span> <span class="kn">import</span> <span class="n">topology</span> <span class="k">as</span> <span class="n">off</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">Field</span><span class="p">,</span> <span class="n">constr</span><span class="p">,</span> <span class="n">validator</span>
<span class="kn">from</span> <span class="nn">qcelemental.models</span> <span class="kn">import</span> <span class="n">AtomicInput</span><span class="p">,</span> <span class="n">OptimizationInput</span>
<span class="kn">from</span> <span class="nn">qcelemental.models.procedures</span> <span class="kn">import</span> <span class="n">QCInputSpecification</span>
<span class="kn">from</span> <span class="nn">qcportal.models.common_models</span> <span class="kn">import</span> <span class="n">DriverEnum</span><span class="p">,</span> <span class="n">QCSpecification</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Literal</span>

<span class="kn">from</span> <span class="nn">openff.qcsubmit.common_structures</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CommonBase</span><span class="p">,</span>
    <span class="n">Metadata</span><span class="p">,</span>
    <span class="n">MoleculeAttributes</span><span class="p">,</span>
    <span class="n">QCSpec</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">openff.qcsubmit.constraints</span> <span class="kn">import</span> <span class="n">Constraints</span>
<span class="kn">from</span> <span class="nn">openff.qcsubmit.datasets.entries</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DatasetEntry</span><span class="p">,</span>
    <span class="n">FilterEntry</span><span class="p">,</span>
    <span class="n">OptimizationEntry</span><span class="p">,</span>
    <span class="n">TorsionDriveEntry</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">openff.qcsubmit.exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DatasetCombinationError</span><span class="p">,</span>
    <span class="n">MissingBasisCoverageError</span><span class="p">,</span>
    <span class="n">QCSpecificationError</span><span class="p">,</span>
    <span class="n">UnsupportedFiletypeError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">openff.qcsubmit.procedures</span> <span class="kn">import</span> <span class="n">GeometricProcedure</span>
<span class="kn">from</span> <span class="nn">openff.qcsubmit.serializers</span> <span class="kn">import</span> <span class="n">deserialize</span><span class="p">,</span> <span class="n">serialize</span>
<span class="kn">from</span> <span class="nn">openff.qcsubmit.utils</span> <span class="kn">import</span> <span class="n">chunk_generator</span>
<span class="kn">from</span> <span class="nn">openff.qcsubmit.utils.smirnoff</span> <span class="kn">import</span> <span class="n">smirnoff_coverage</span>
<span class="kn">from</span> <span class="nn">openff.qcsubmit.utils.visualize</span> <span class="kn">import</span> <span class="n">molecules_to_pdf</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">openff.toolkit.typing.engines.smirnoff</span> <span class="kn">import</span> <span class="n">ForceField</span>
    <span class="kn">from</span> <span class="nn">qcportal</span> <span class="kn">import</span> <span class="n">FractalClient</span>
    <span class="kn">from</span> <span class="nn">qcportal.collections.collection</span> <span class="kn">import</span> <span class="n">Collection</span>
    <span class="kn">from</span> <span class="nn">qcportal.models.common_models</span> <span class="kn">import</span> <span class="n">OptimizationSpecification</span>

<span class="n">C</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Collection&quot;</span><span class="p">)</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">DatasetEntry</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_BaseDataset</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">CommonBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A general base model for QCSubmit datasets which act as wrappers around a corresponding QFractal collection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dataset_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The name of the dataset, this will be the name given to the collection in QCArchive.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">dataset_tagline</span><span class="p">:</span> <span class="n">constr</span><span class="p">(</span><span class="n">min_length</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="s2">&quot;[a-zA-Z]&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># noqa</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The tagline should be a short description of the dataset which will be displayed by the QCArchive client when the collections are listed.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;_BaseDataset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="s2">&quot;_BaseDataset&quot;</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The dataset type corresponds to the type of collection that will be made in QCArchive.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">description</span><span class="p">:</span> <span class="n">constr</span><span class="p">(</span><span class="n">min_length</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="s2">&quot;[a-zA-Z]&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># noqa</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;A long description of the datasets purpose and details about the molecules within.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="n">Metadata</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="n">Metadata</span><span class="p">(),</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The metadata describing the dataset.&quot;</span>
    <span class="p">)</span>
    <span class="n">provenance</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="p">{},</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;A dictionary of the software and versions used to generate the dataset.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">dataset</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DatasetEntry</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="p">{},</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The actual dataset to be stored in QCArchive.&quot;</span>
    <span class="p">)</span>
    <span class="n">filtered_molecules</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">FilterEntry</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="p">{},</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The set of workflow components used to generate the dataset with any filtered molecules.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">_file_writers</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;json&quot;</span><span class="p">:</span> <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make sure the metadata has been assigned correctly if not autofill some information.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># set the collection type here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">collection_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">dataset_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_name</span>

        <span class="c1"># some fields can be reused here</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">short_description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">short_description</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_tagline</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">long_description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">long_description</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_entry_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">E</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_generate_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="s2">&quot;FractalClient&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">C</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the corresponding QCFractal Collection for this Dataset.</span>

<span class="sd">        Each QCSubmit Dataset class corresponds to and wraps</span>
<span class="sd">        a QCFractal Collection class. This method generates an instance</span>
<span class="sd">        of that corresponding Collection, with inputs applied from</span>
<span class="sd">        Dataset attributes.</span>

<span class="sd">        Args:</span>
<span class="sd">            client:</span>
<span class="sd">                Client to use for connecting to a QCFractal server instance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Collection instance corresponding to this Dataset.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_get_procedure_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;OptimizationSpecification&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the procedure spec, if applicable, for this Dataset.</span>

<span class="sd">        If the dataset has no concept of procedure specs, this method</span>
<span class="sd">        should return `None`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Specification for the optimization procedure to perform.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_get_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">C</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shim method to get indices from different Collection types.</span>

<span class="sd">        The mechanism for getting indices from different QCFractal Collections</span>
<span class="sd">        is inconsistent. This method wraps the required calls to the given</span>
<span class="sd">        Collection to yield these indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        collection : Collection</span>
<span class="sd">            Collection instance corresponding to this Dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        indices : List[str]</span>
<span class="sd">            Indices from the entries in the Collection.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_compute_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">QCSpec</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a dict giving the full arguments to the Collection&#39;s</span>
<span class="sd">        `compute` method.</span>

<span class="sd">        This requires the compute spec defining the compute operations,</span>
<span class="sd">        as well as the set of indices to operate on.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spec : QCSpec</span>
<span class="sd">            The method, basis, program, and other parameters for compute execution.</span>
<span class="sd">        indices : List[str]</span>
<span class="sd">            List of entry indices to apply the compute spec to.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spec_kwargs : Dict[str, Any]</span>
<span class="sd">            A dict giving the full arguments to the compute method of this</span>
<span class="sd">            Dataset&#39;s corresponding Collection.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_add_entries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">C</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add entries to the Dataset&#39;s corresponding Collection.</span>

<span class="sd">        This method allows for handling of e.g. generating the index/name for</span>
<span class="sd">        the corresponding Collection from each item in `self.dataset`. Since</span>
<span class="sd">        each item may feature more than one conformer, appropriate handling</span>
<span class="sd">        differs between e.g. `OptimizationDataset` and `TorsiondriveDataset`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        collection : Collection</span>
<span class="sd">            Collection instance corresponding to this Dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        indices : List[str]</span>
<span class="sd">            A list of the entry indices added.</span>
<span class="sd">        new_entries : int</span>
<span class="sd">            The number of new entries added.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_add_entry</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">:</span> <span class="n">qcel</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">Molecule</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">C</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">E</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to add a molecule from the local dataset to the QCArchive instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_add_dataset_specification</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spec</span><span class="p">:</span> <span class="n">QCSpec</span><span class="p">,</span>
        <span class="n">dataset</span><span class="p">:</span> <span class="n">C</span><span class="p">,</span>
        <span class="n">procedure_spec</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;OptimizationSpecification&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add the given compute spec to this Datasets&#39;s corresponding Collection.</span>

<span class="sd">        This will check if a spec under this name has already been added and if it should be overwritten.</span>

<span class="sd">        If a specification is already stored under this name in the collection we have options:</span>
<span class="sd">            - If a spec with the same name but different details has been added and used we must raise an error to change the name of the new spec</span>
<span class="sd">            - If the spec has been added and has not been used then overwrite it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spec : QCSpec</span>
<span class="sd">            The QCSpec we are trying to add to the Collection.</span>
<span class="sd">        procedure_spec : OptimizationSpecification</span>
<span class="sd">            The procedure spec to add, in this case an `OptimizationSpecification`.</span>
<span class="sd">        dataset : Collection</span>
<span class="sd">            The Collection to add this compute spec to.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            `True` if the specification is present in the collection</span>
<span class="sd">            and is exactly the same as what we are trying to add.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        QCSpecificationError</span>
<span class="sd">            If a specification with the same name is already added to the collection but has different settings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">to_tasks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">AtomicInput</span><span class="p">,</span> <span class="n">OptimizationInput</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a dictionary of QCengine tasks which correspond to this dataset stored by the program which should be used for the task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">submit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">client</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;FractalClient&quot;</span><span class="p">],</span>
        <span class="n">processes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">ignore_errors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Submit the dataset to a QCFractal server.</span>

<span class="sd">        Args:</span>
<span class="sd">            client:</span>
<span class="sd">                The name of the file containing the client information or an actual client instance.</span>
<span class="sd">            processes:</span>
<span class="sd">                Number of processes to use for submission; if ``None``, all available processes will be used.</span>
<span class="sd">            ignore_errors:</span>
<span class="sd">                If the user wants to submit the compute regardless of errors set this to ``True``.</span>
<span class="sd">                Mainly to override basis coverage.</span>
<span class="sd">            chunk_size:</span>
<span class="sd">                Max number of entries+specs to include in individual `client.compute` calls.</span>
<span class="sd">                If ``None``, will use ``query_limit`` from ``client``.</span>
<span class="sd">            verbose:</span>
<span class="sd">                If progress bars and submission statistics should be printed ``True`` or not ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary of the compute response from the client for each specification submitted.</span>

<span class="sd">        Raises:</span>
<span class="sd">            MissingBasisCoverageError:</span>
<span class="sd">                If the chosen basis set does not cover some of the elements in the dataset.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chunk_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">query_limit</span>

        <span class="c1"># pre submission checks</span>
        <span class="c1"># make sure we have some QCSpec to submit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_qc_specs</span><span class="p">()</span>
        <span class="c1"># basis set coverage check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_missing_basis_coverage</span><span class="p">(</span><span class="n">raise_errors</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="n">ignore_errors</span><span class="p">))</span>

        <span class="c1"># get client instance</span>
        <span class="n">target_client</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_activate_client</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>

        <span class="c1"># see if collection already exists</span>
        <span class="c1"># if so, we&#39;ll extend it</span>
        <span class="c1"># if not, we&#39;ll create a new one</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">target_client</span><span class="o">.</span><span class="n">get_collection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">validate_metadata</span><span class="p">(</span><span class="n">raise_errors</span><span class="o">=</span><span class="ow">not</span> <span class="n">ignore_errors</span><span class="p">)</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_collection</span><span class="p">(</span><span class="n">client</span><span class="o">=</span><span class="n">target_client</span><span class="p">)</span>

        <span class="c1"># create specifications</span>
        <span class="n">procedure_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_procedure_spec</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_specifications</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_dataset_specification</span><span class="p">(</span>
                <span class="n">spec</span><span class="o">=</span><span class="n">spec</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span> <span class="n">procedure_spec</span><span class="o">=</span><span class="n">procedure_spec</span>
            <span class="p">)</span>

        <span class="c1"># add the molecules to the database</span>
        <span class="n">indices</span><span class="p">,</span> <span class="n">new_entries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_entries</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of new entries: </span><span class="si">{</span><span class="n">new_entries</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_records</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># if we have no indices, such as with a pure compute submission,</span>
        <span class="c1"># then get all of the existing ones and use these</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_indices</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>

        <span class="n">responses</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># set up process pool for compute submission</span>
        <span class="c1"># if processes == 1, perform in-process, no pool</span>
        <span class="k">if</span> <span class="n">processes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">processes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">multiprocessing.pool</span> <span class="kn">import</span> <span class="n">Pool</span>

            <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">processes</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="c1"># add compute specs to the collection</span>
                <span class="k">for</span> <span class="n">spec_name</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_specifications</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">spec_tasks</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">work_list</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">mol_chunk</span> <span class="ow">in</span> <span class="n">chunk_generator</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">):</span>
                        <span class="n">spec_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_kwargs</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">mol_chunk</span><span class="p">)</span>
                        <span class="n">work_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">compute</span><span class="p">,</span> <span class="o">**</span><span class="n">spec_kwargs</span><span class="p">)</span>
                        <span class="p">)</span>

                    <span class="k">for</span> <span class="n">work</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                        <span class="n">work_list</span><span class="p">,</span>
                        <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">work_list</span><span class="p">),</span>
                        <span class="n">ncols</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
                        <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Creating tasks for: </span><span class="si">{</span><span class="n">spec_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">,</span>
                    <span class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">work</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">spec_tasks</span> <span class="o">+=</span> <span class="n">result</span>
                        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                            <span class="n">spec_tasks</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span>

                    <span class="n">responses</span><span class="p">[</span><span class="n">spec_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec_tasks</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">spec_name</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_specifications</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">spec_tasks</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mol_chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                        <span class="n">chunk_generator</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">),</span>
                        <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">/</span> <span class="n">chunk_size</span><span class="p">,</span>
                        <span class="n">ncols</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
                        <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Creating tasks for: </span><span class="si">{</span><span class="n">spec_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">spec_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_kwargs</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">mol_chunk</span><span class="p">)</span>

                    <span class="c1"># PERFORMANCE HACK: only call save on the first compute call to add spec,</span>
                    <span class="c1"># but not on subsequent calls for basic Datasets</span>
                    <span class="k">if</span> <span class="n">collection</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Dataset&quot;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">spec_kwargs</span><span class="p">[</span><span class="s2">&quot;save&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">spec_kwargs</span><span class="p">[</span><span class="s2">&quot;save&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="n">result</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="o">**</span><span class="n">spec_kwargs</span><span class="p">)</span>
                    <span class="c1"># datasets give a compute response, but opt and torsiondrives give ints</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">spec_tasks</span> <span class="o">+=</span> <span class="n">result</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="n">spec_tasks</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span>

                <span class="c1"># one last call to `save` to push collection object to server</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
                <span class="n">responses</span><span class="p">[</span><span class="n">spec_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec_tasks</span>

        <span class="k">return</span> <span class="n">responses</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;_BaseDataset&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;_BaseDataset&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add two Basicdatasets together.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Dataset object from a compressed json file.</span>

<span class="sd">        Args:</span>
<span class="sd">            file_name: The name of the file the dataset should be created from.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_molecule_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">off</span><span class="o">.</span><span class="n">Molecule</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search through the dataset for a molecule and return the dataset index of any exact molecule matches.</span>

<span class="sd">        Args:</span>
<span class="sd">            molecule: The smiles string for the molecule or an openforcefield.topology.Molecule that is to be searched for.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of dataset indices which contain the target molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if we have a smiles string convert it</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">off</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">from_smiles</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># make a unique inchi key</span>
        <span class="n">inchi_key</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">to_inchikey</span><span class="p">(</span><span class="n">fixed_hydrogens</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">inchi_key</span> <span class="o">==</span> <span class="n">entry</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">inchi_key</span><span class="p">:</span>
                <span class="c1"># they have same basic inchi now match the molecule</span>
                <span class="k">if</span> <span class="n">molecule</span> <span class="o">==</span> <span class="n">entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                    <span class="n">hits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hits</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filtered</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">off</span><span class="o">.</span><span class="n">Molecule</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A generator which yields a openff molecule representation for each molecule filtered while creating this dataset.</span>

<span class="sd">        Note:</span>
<span class="sd">            Modifying the molecule will have no effect on the data stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_molecules</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">smiles</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">molecules</span><span class="p">:</span>
                <span class="n">offmol</span> <span class="o">=</span> <span class="n">off</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">from_smiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">offmol</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_filtered</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the total number of molecules filtered by the components used in a workflow to create this dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">molecules</span><span class="p">)</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_molecules</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">filtered</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_records</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total number of records that will be created on submission of the dataset.</span>

<span class="sd">        Note:</span>
<span class="sd">            * The number returned will be different depending on the dataset used.</span>
<span class="sd">            * The amount of unique molecule can be found using `n_molecules`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_records</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">)</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="k">return</span> <span class="n">n_records</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_molecules</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the number of unique molecules to be submitted.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * This method has been improved for better performance on large datasets and has been tested on an optimization dataset of over 10500 molecules.</span>
<span class="sd">            * This function does not calculate the total number of entries of the dataset see `n_records`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">molecules</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">inchikey</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">inchi_key</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">like_mols</span> <span class="o">=</span> <span class="n">molecules</span><span class="p">[</span><span class="n">inchikey</span><span class="p">]</span>
                <span class="n">mol_to_add</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">to_inchikey</span><span class="p">(</span>
                    <span class="n">fixed_hydrogens</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">like_mols</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mol_to_add</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span>
                        <span class="kc">False</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">to_inchikey</span><span class="p">(</span><span class="n">fixed_hydrogens</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">molecules</span><span class="p">[</span><span class="n">inchikey</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">molecules</span><span class="p">[</span><span class="n">inchikey</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">entry</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="p">]</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">molecules</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecules</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">off</span><span class="o">.</span><span class="n">Molecule</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A generator that creates an openforcefield.topology.Molecule one by one from the dataset.</span>

<span class="sd">        Note:</span>
<span class="sd">            Editing the molecule will not effect the data stored in the dataset as it is immutable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">molecule_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># create the molecule from the cmiles data</span>
            <span class="k">yield</span> <span class="n">molecule_data</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the amount of components that have been ran during generating the dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_filtered</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_molecules</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_filtered</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gather the details of the components that were ran during the creation of this dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">components</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_molecules</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;molecules&quot;</span><span class="p">}))</span>

        <span class="k">return</span> <span class="n">components</span>

    <span class="k">def</span> <span class="nf">filter_molecules</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">molecules</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">off</span><span class="o">.</span><span class="n">Molecule</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">off</span><span class="o">.</span><span class="n">Molecule</span><span class="p">]],</span>
        <span class="n">component</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">component_settings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">component_provenance</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter a molecule or list of molecules by the component they failed.</span>

<span class="sd">        Args:</span>
<span class="sd">            molecules:</span>
<span class="sd">                A molecule or list of molecules to be filtered.</span>
<span class="sd">            component_settings:</span>
<span class="sd">                The dictionary representation of the component that filtered this set of molecules.</span>
<span class="sd">            component:</span>
<span class="sd">                The name of the component.</span>
<span class="sd">            component_provenance:</span>
<span class="sd">                The dictionary representation of the component provenance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">molecules</span><span class="p">,</span> <span class="n">off</span><span class="o">.</span><span class="n">Molecule</span><span class="p">):</span>
            <span class="c1"># make into a list</span>
            <span class="n">molecules</span> <span class="o">=</span> <span class="p">[</span><span class="n">molecules</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_molecules</span><span class="p">:</span>
            <span class="n">filter_mols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">molecule</span><span class="o">.</span><span class="n">to_smiles</span><span class="p">(</span><span class="n">isomeric</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">explicit_hydrogens</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">molecule</span> <span class="ow">in</span> <span class="n">molecules</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filtered_molecules</span><span class="p">[</span><span class="n">component</span><span class="p">]</span><span class="o">.</span><span class="n">molecules</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">filter_mols</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filter_data</span> <span class="o">=</span> <span class="n">FilterEntry</span><span class="p">(</span>
                <span class="n">off_molecules</span><span class="o">=</span><span class="n">molecules</span><span class="p">,</span>
                <span class="n">component</span><span class="o">=</span><span class="n">component</span><span class="p">,</span>
                <span class="n">component_provenance</span><span class="o">=</span><span class="n">component_provenance</span><span class="p">,</span>
                <span class="n">component_settings</span><span class="o">=</span><span class="n">component_settings</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">filtered_molecules</span><span class="p">[</span><span class="n">filter_data</span><span class="o">.</span><span class="n">component</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter_data</span>

    <span class="k">def</span> <span class="nf">add_molecule</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">molecule</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">off</span><span class="o">.</span><span class="n">Molecule</span><span class="p">],</span>
        <span class="n">extras</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keywords</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a molecule to the dataset under the given index with the passed cmiles.</span>

<span class="sd">        Args:</span>
<span class="sd">            index:</span>
<span class="sd">                The index that should be associated with the molecule in QCArchive.</span>
<span class="sd">            molecule:</span>
<span class="sd">                The instance of the molecule which contains its conformer information.</span>
<span class="sd">            extras:</span>
<span class="sd">                The extras that should be supplied into the qcportal.moldels.Molecule.</span>
<span class="sd">            keywords:</span>
<span class="sd">                Any extra keywords which are required for the calculation.</span>

<span class="sd">        Note:</span>
<span class="sd">            Each molecule in this basic dataset should have all of its conformers expanded out into separate entries.</span>
<span class="sd">            Thus here we take the general molecule index and increment it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># only use attributes if supplied else generate</span>
        <span class="c1"># Note we should only reuse attributes if making a dataset from a result so the attributes are consistent</span>
        <span class="k">if</span> <span class="s2">&quot;attributes&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;attributes&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="n">MoleculeAttributes</span><span class="o">.</span><span class="n">from_openff_molecule</span><span class="p">(</span><span class="n">molecule</span><span class="o">=</span><span class="n">molecule</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">data_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entry_class</span><span class="p">()(</span>
                <span class="n">off_molecule</span><span class="o">=</span><span class="n">molecule</span><span class="p">,</span>
                <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                <span class="n">extras</span><span class="o">=</span><span class="n">extras</span> <span class="ow">or</span> <span class="p">{},</span>
                <span class="n">keywords</span><span class="o">=</span><span class="n">keywords</span> <span class="ow">or</span> <span class="p">{},</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_entry</span>
            <span class="c1"># add any extra elements to the metadata</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data_entry</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">qcel</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ValidationError</span><span class="p">:</span>
            <span class="c1"># the molecule has some qcschema issue and should be removed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_molecules</span><span class="p">(</span>
                <span class="n">molecules</span><span class="o">=</span><span class="n">molecule</span><span class="p">,</span>
                <span class="n">component</span><span class="o">=</span><span class="s2">&quot;QCSchemaIssues&quot;</span><span class="p">,</span>
                <span class="n">component_settings</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;component_description&quot;</span><span class="p">:</span> <span class="s2">&quot;The molecule was removed as a valid QCSchema could not be made&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;QCSchemaIssues&quot;</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">component_provenance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">provenance</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_missing_basis_coverage</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">raise_errors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Work out if the selected basis set covers all of the elements in the dataset for each specification if not return the missing</span>
<span class="sd">        element symbols.</span>

<span class="sd">        Args:</span>
<span class="sd">            raise_errors: If `True` the function will raise an error for missing basis coverage, else we return the missing data and just print warnings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">re</span>
        <span class="kn">import</span> <span class="nn">warnings</span>

        <span class="kn">import</span> <span class="nn">basis_set_exchange</span> <span class="k">as</span> <span class="nn">bse</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">openmm.app</span> <span class="kn">import</span> <span class="n">Element</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">simtk.openmm.app</span> <span class="kn">import</span> <span class="n">Element</span>

        <span class="n">basis_report</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_specifications</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;torchani&quot;</span><span class="p">:</span>
                <span class="c1"># check ani1 first</span>
                <span class="n">ani_coverage</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;ani1x&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;O&quot;</span><span class="p">},</span>
                    <span class="s2">&quot;ani1ccx&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;O&quot;</span><span class="p">},</span>
                    <span class="s2">&quot;ani2x&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;O&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;Cl&quot;</span><span class="p">},</span>
                <span class="p">}</span>
                <span class="n">covered_elements</span> <span class="o">=</span> <span class="n">ani_coverage</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
                <span class="c1"># this is validated at the spec level so we should not get an error here</span>
                <span class="n">difference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">covered_elements</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">spec</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;psi4&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">basis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># now check psi4</span>
                    <span class="c1"># TODO this list should be updated with more basis transforms as we find them</span>
                    <span class="n">psi4_converter</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;dzvp&quot;</span><span class="p">:</span> <span class="s2">&quot;dgauss-dzvp&quot;</span><span class="p">}</span>
                    <span class="n">month_subs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;jun-&quot;</span><span class="p">,</span> <span class="s2">&quot;mar-&quot;</span><span class="p">,</span> <span class="s2">&quot;apr-&quot;</span><span class="p">,</span> <span class="s2">&quot;may-&quot;</span><span class="p">,</span> <span class="s2">&quot;feb-&quot;</span><span class="p">}</span>
                    <span class="n">basis</span> <span class="o">=</span> <span class="n">psi4_converter</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">spec</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
                    <span class="c1"># here we need to apply conversions for special characters to match bse</span>
                    <span class="c1"># replace the *</span>
                    <span class="n">basis</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;\*&quot;</span><span class="p">,</span> <span class="s2">&quot;_st_&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
                    <span class="c1"># replace any /</span>
                    <span class="n">basis</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;_sl_&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
                    <span class="c1"># check for heavy tags</span>
                    <span class="n">basis</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;heavy-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">basis_meta</span> <span class="o">=</span> <span class="n">bse</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">()[</span><span class="n">basis</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="c1"># now try and do month subs</span>
                        <span class="k">for</span> <span class="n">month</span> <span class="ow">in</span> <span class="n">month_subs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">month</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">:</span>
                                <span class="n">basis</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">month</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
                        <span class="c1"># now try and get the basis again</span>
                        <span class="n">basis_meta</span> <span class="o">=</span> <span class="n">bse</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">()[</span><span class="n">basis</span><span class="p">]</span>

                    <span class="n">elements</span> <span class="o">=</span> <span class="n">basis_meta</span><span class="p">[</span><span class="s2">&quot;versions&quot;</span><span class="p">][</span><span class="n">basis_meta</span><span class="p">[</span><span class="s2">&quot;latest_version&quot;</span><span class="p">]][</span>
                        <span class="s2">&quot;elements&quot;</span>
                    <span class="p">]</span>
                    <span class="n">covered_elements</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">Element</span><span class="o">.</span><span class="n">getByAtomicNumber</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">.</span><span class="n">symbol</span>
                            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elements</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">difference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">covered_elements</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># the basis is wrote with the method so print a warning about validation</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The spec </span><span class="si">{</span><span class="n">spec</span><span class="o">.</span><span class="n">spec_name</span><span class="si">}</span><span class="s2"> has a basis of None, this will not be validated.&quot;</span><span class="p">,</span>
                        <span class="ne">UserWarning</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">difference</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">elif</span> <span class="n">spec</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;openmm&quot;</span><span class="p">:</span>
                <span class="c1"># smirnoff covered elements</span>
                <span class="n">covered_elements</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;O&quot;</span><span class="p">,</span> <span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Cl&quot;</span><span class="p">,</span> <span class="s2">&quot;Br&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;I&quot;</span><span class="p">}</span>
                <span class="n">difference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">covered_elements</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">spec</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;rdkit&quot;</span><span class="p">:</span>
                <span class="c1"># all atoms are defined in the uff so return an empty set.</span>
                <span class="n">difference</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># xtb</span>
                <span class="c1"># all atoms are covered and this must be xtb</span>
                <span class="n">difference</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="n">basis_report</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">spec_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">difference</span>

        <span class="k">for</span> <span class="n">spec_name</span><span class="p">,</span> <span class="n">report</span> <span class="ow">in</span> <span class="n">basis_report</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">report</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raise_errors</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">MissingBasisCoverageError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The following elements: </span><span class="si">{</span><span class="n">report</span><span class="si">}</span><span class="s2"> are not covered by the selected basis : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">qc_specifications</span><span class="p">[</span><span class="n">spec_name</span><span class="p">]</span><span class="o">.</span><span class="n">basis</span><span class="si">}</span><span class="s2"> and method : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">qc_specifications</span><span class="p">[</span><span class="n">spec_name</span><span class="p">]</span><span class="o">.</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The following elements: </span><span class="si">{</span><span class="n">report</span><span class="si">}</span><span class="s2"> are not covered by the selected basis : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">qc_specifications</span><span class="p">[</span><span class="n">spec_name</span><span class="p">]</span><span class="o">.</span><span class="n">basis</span><span class="si">}</span><span class="s2"> and method : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">qc_specifications</span><span class="p">[</span><span class="n">spec_name</span><span class="p">]</span><span class="o">.</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="ne">UserWarning</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raise_errors</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">basis_report</span>

    <span class="k">def</span> <span class="nf">_get_spec_keywords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">QCSpec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ptl</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">KeywordSet</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a keyword set which is specific to this QC specification and accounts for implicit solvent when requested.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ptl</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">KeywordSet</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="n">spec</span><span class="o">.</span><span class="n">qc_keywords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">export_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">compression</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the dataset to file so that it can be used to make another dataset quickly.</span>

<span class="sd">        Args:</span>
<span class="sd">            file_name:</span>
<span class="sd">                The name of the file the dataset should be wrote to.</span>
<span class="sd">            compression:</span>
<span class="sd">                The type of compression that should be added to the export.</span>

<span class="sd">        Raises:</span>
<span class="sd">            UnsupportedFiletypeError: If the requested file type is not supported.</span>


<span class="sd">        Note:</span>
<span class="sd">            The supported file types are:</span>

<span class="sd">            - `json`</span>

<span class="sd">            Additionally, the file will automatically compressed depending on the</span>
<span class="sd">            final extension if compression is not explicitly supplied:</span>

<span class="sd">            - `json.xz`</span>
<span class="sd">            - `json.gz`</span>
<span class="sd">            - `json.bz2`</span>

<span class="sd">            Check serializers.py for more details. Right now bz2 seems to</span>
<span class="sd">            produce the smallest files.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check here early, just to filter anything non-json for now</span>
        <span class="c1"># Ideally the serializers should be checking this</span>
        <span class="n">split</span> <span class="o">=</span> <span class="n">file_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">split</span> <span class="o">=</span> <span class="n">split</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">split</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">if</span> <span class="s2">&quot;json&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">split</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedFiletypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The dataset export file name with leading extension </span><span class="si">{</span><span class="n">split</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> is not supported, &quot;</span>
                <span class="s2">&quot;please end the file name with json.&quot;</span>
            <span class="p">)</span>

        <span class="n">serialize</span><span class="p">(</span><span class="n">serializable</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">coverage_report</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">force_field</span><span class="p">:</span> <span class="s2">&quot;ForceField&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a summary of how many molecules within this dataset would be assigned</span>
<span class="sd">        each of the parameters in a force field.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Parameters which would not be assigned to any molecules in the dataset</span>
<span class="sd">              will not be included in the returned summary.</span>

<span class="sd">        Args:</span>
<span class="sd">            force_field: The force field containing the parameters to summarize.</span>
<span class="sd">            verbose: If true a progress bar will be shown on screen.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary of the form ``coverage[handler_name][parameter_smirks] = count``</span>
<span class="sd">            which stores the number of molecules within this dataset that would be</span>
<span class="sd">            assigned to each parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">smirnoff_coverage</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molecules</span><span class="p">,</span> <span class="n">force_field</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visualize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">toolkit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;openeye&quot;</span><span class="p">,</span> <span class="s2">&quot;rdkit&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a pdf file of the molecules with any torsions highlighted using either openeye or rdkit.</span>

<span class="sd">        Args:</span>
<span class="sd">            file_name:</span>
<span class="sd">                The name of the pdf file which will be produced.</span>
<span class="sd">            columns:</span>
<span class="sd">                The number of molecules per row.</span>
<span class="sd">            toolkit:</span>
<span class="sd">                The option to specify the backend toolkit used to produce the pdf file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">molecules</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">off_mol</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">off_mol</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;dihedrals&quot;</span><span class="p">):</span>
                <span class="n">off_mol</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;dihedrals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dihedrals</span>

            <span class="n">molecules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">off_mol</span><span class="p">)</span>

        <span class="n">molecules_to_pdf</span><span class="p">(</span><span class="n">molecules</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">toolkit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">molecules_to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">file_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the molecules to the requested file type.</span>

<span class="sd">        Args:</span>
<span class="sd">            file_name:</span>
<span class="sd">                The name of the file the molecules should be stored in.</span>
<span class="sd">            file_type:</span>
<span class="sd">                The file format that should be used to store the molecules.</span>

<span class="sd">        Important:</span>
<span class="sd">            The supported file types are:</span>

<span class="sd">            - SMI</span>
<span class="sd">            - INCHI</span>
<span class="sd">            - INCKIKEY</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">file_writers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;smi&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecules_to_smiles</span><span class="p">,</span>
            <span class="s2">&quot;inchi&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecules_to_inchi</span><span class="p">,</span>
            <span class="s2">&quot;inchikey&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecules_to_inchikey</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># get the list of molecules</span>
            <span class="n">molecules</span> <span class="o">=</span> <span class="n">file_writers</span><span class="p">[</span><span class="n">file_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()]()</span>

            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">molecule</span> <span class="ow">in</span> <span class="n">molecules</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">molecule</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedFiletypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The requested file type </span><span class="si">{</span><span class="n">file_type</span><span class="si">}</span><span class="s2"> is not supported, supported types are&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_writers</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_molecules_to_smiles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a list of molecules canonical isomeric smiles.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">smiles</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">canonical_isomeric_smiles</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">smiles</span>

    <span class="k">def</span> <span class="nf">_molecules_to_inchi</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a list of the molecules standard InChI.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">inchi</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">standard_inchi</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">inchi</span>

    <span class="k">def</span> <span class="nf">_molecules_to_inchikey</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a list of the molecules standard InChIKey.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">inchikey</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">inchi_key</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">inchikey</span>


<div class="viewcode-block" id="BasicDataset"><a class="viewcode-back" href="../../../../generated/openff.qcsubmit.datasets.BasicDataset.html#openff.qcsubmit.datasets.BasicDataset">[docs]</a><span class="k">class</span> <span class="nc">BasicDataset</span><span class="p">(</span><span class="n">_BaseDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The general QCFractal dataset class which contains all of the molecules and information about them prior to</span>
<span class="sd">    submission.</span>

<span class="sd">    The class is a simple holder of the dataset and information about it and can do simple checks on the data before</span>
<span class="sd">    submitting it such as ensuring that the molecules have cmiles information</span>
<span class="sd">    and a unique index to be identified by.</span>

<span class="sd">    Note:</span>
<span class="sd">        The molecules in this dataset are all expanded so that different conformers are unique submissions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;DataSet&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;DataSet&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_entry_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">DatasetEntry</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">DatasetEntry</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;BasicDataset&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BasicDataset&quot;</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">copy</span>

        <span class="c1"># make sure the dataset types match</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DatasetCombinationError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The datasets must be the same type, you can not add types </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># create a new datset</span>
        <span class="n">new_dataset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># update the elements in the dataset</span>
        <span class="n">new_dataset</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># search for the molecule</span>
            <span class="n">entry_ids</span> <span class="o">=</span> <span class="n">new_dataset</span><span class="o">.</span><span class="n">get_molecule_entry</span><span class="p">(</span>
                <span class="n">entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">entry_ids</span><span class="p">:</span>
                <span class="n">new_dataset</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mol_id</span> <span class="o">=</span> <span class="n">entry_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">current_entry</span> <span class="o">=</span> <span class="n">new_dataset</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">mol_id</span><span class="p">]</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">atom_map</span> <span class="o">=</span> <span class="n">off</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">are_isomorphic</span><span class="p">(</span>
                    <span class="n">entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="n">current_entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="n">return_atom_map</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># remap the molecule and all conformers</span>
                <span class="n">entry_mol</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">mapped_mol</span> <span class="o">=</span> <span class="n">entry_mol</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="n">mapping_dict</span><span class="o">=</span><span class="n">atom_map</span><span class="p">,</span> <span class="n">current_to_new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mapped_mol</span><span class="o">.</span><span class="n">n_conformers</span><span class="p">):</span>
                    <span class="n">mapped_schema</span> <span class="o">=</span> <span class="n">mapped_mol</span><span class="o">.</span><span class="n">to_qcschema</span><span class="p">(</span>
                        <span class="n">conformer</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">extras</span><span class="o">=</span><span class="n">current_entry</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extras</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">mapped_schema</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_entry</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">:</span>
                        <span class="n">current_entry</span><span class="o">.</span><span class="n">initial_molecules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapped_schema</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_dataset</span>

    <span class="k">def</span> <span class="nf">_generate_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="s2">&quot;FractalClient&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_name</span><span class="p">,</span>
            <span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">,</span>
            <span class="n">default_driver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span>
            <span class="n">default_program</span><span class="o">=</span><span class="s2">&quot;psi4&quot;</span><span class="p">,</span>
            <span class="n">tagline</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_tagline</span><span class="p">,</span>
            <span class="n">tags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_tags</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
            <span class="n">provenance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">provenance</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">dict</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">collection</span>

    <span class="k">def</span> <span class="nf">_get_procedure_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Needed for `submit` usage.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_get_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">:</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">molecule_id</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">records</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_add_dataset_specification</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spec</span><span class="p">:</span> <span class="n">QCSpec</span><span class="p">,</span>
        <span class="n">dataset</span><span class="p">:</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">procedure_spec</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;OptimizationSpecification&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add the given compute spec to this Datasets&#39;s corresponding Collection.</span>

<span class="sd">        Args:</span>
<span class="sd">            spec:</span>
<span class="sd">                The QCSpec we are trying to add to the dataset in the QCArchive instance.</span>
<span class="sd">            dataset:</span>
<span class="sd">                The dataset to add this compute spec to.</span>
<span class="sd">            procedure_spec:</span>
<span class="sd">                The procedure spec to add; ignored for ``BasicDataset``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ``True`` if the specification successfully added, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># generate the keyword set</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spec_keywords</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># try and add the keywords; if present then continue</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">add_keywords</span><span class="p">(</span>
                <span class="n">alias</span><span class="o">=</span><span class="n">spec</span><span class="o">.</span><span class="n">spec_name</span><span class="p">,</span>
                <span class="n">program</span><span class="o">=</span><span class="n">spec</span><span class="o">.</span><span class="n">program</span><span class="p">,</span>
                <span class="n">keyword</span><span class="o">=</span><span class="n">kw</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_compute_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="n">spec_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_tag</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="p">)</span>
        <span class="n">spec_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="s2">&quot;basis&quot;</span><span class="p">,</span> <span class="s2">&quot;program&quot;</span><span class="p">}))</span>
        <span class="n">spec_kwargs</span><span class="p">[</span><span class="s2">&quot;keywords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">spec_name</span>
        <span class="n">spec_kwargs</span><span class="p">[</span><span class="s2">&quot;protocols&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;wavefunction&quot;</span><span class="p">:</span> <span class="n">spec</span><span class="o">.</span><span class="n">store_wavefunction</span><span class="o">.</span><span class="n">value</span><span class="p">}</span>
        <span class="n">spec_kwargs</span><span class="p">[</span><span class="s2">&quot;subset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="k">return</span> <span class="n">spec_kwargs</span>

    <span class="k">def</span> <span class="nf">_add_entries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="n">new_entries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># check if the index has a number tag</span>
                <span class="c1"># if so, start from this tag</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clean_index</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">molecule</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;-</span><span class="si">{</span><span class="n">tag</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">new_entries</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_entry</span><span class="p">(</span>
                            <span class="n">molecule</span><span class="o">=</span><span class="n">molecule</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_entries</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_entry</span><span class="p">(</span>
                        <span class="n">molecule</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                        <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># upload collection object to server</span>
        <span class="n">dataset</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="c1"># we have to convert the indices to the object ids</span>
        <span class="n">object_ids</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">entry</span><span class="o">.</span><span class="n">molecule_id</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">records</span> <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">indices</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">object_ids</span><span class="p">,</span> <span class="n">new_entries</span>

    <span class="k">def</span> <span class="nf">_add_entry</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">molecule</span><span class="p">:</span> <span class="n">qcel</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">Molecule</span><span class="p">,</span>
        <span class="n">dataset</span><span class="p">:</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">DatasetEntry</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to add molecule the dataset.</span>
<span class="sd">        Return `True` if successful, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">add_entry</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">molecule</span><span class="o">=</span><span class="n">molecule</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="BasicDataset.to_tasks"><a class="viewcode-back" href="../../../../generated/openff.qcsubmit.datasets.BasicDataset.html#openff.qcsubmit.datasets.BasicDataset.to_tasks">[docs]</a>    <span class="k">def</span> <span class="nf">to_tasks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">AtomicInput</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a dictionary of single QCEngine tasks that correspond to this dataset organised by program name. The tasks can be passed directly</span>
<span class="sd">        to qcengine.compute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_specifications</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">qc_model</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">qc_model</span>
            <span class="n">keywords</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">qc_keywords</span>
            <span class="n">protocols</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;wavefunction&quot;</span><span class="p">:</span> <span class="n">spec</span><span class="o">.</span><span class="n">store_wavefunction</span><span class="o">.</span><span class="n">value</span><span class="p">}</span>
            <span class="n">program</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># check if the index has a number tag</span>
                <span class="c1"># if so, start from this tag</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clean_index</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">molecule</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;-</span><span class="si">{</span><span class="n">tag</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>

                    <span class="n">data</span><span class="p">[</span><span class="n">program</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">AtomicInput</span><span class="p">(</span>
                            <span class="nb">id</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                            <span class="n">molecule</span><span class="o">=</span><span class="n">molecule</span><span class="p">,</span>
                            <span class="n">driver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span>
                            <span class="n">model</span><span class="o">=</span><span class="n">qc_model</span><span class="p">,</span>
                            <span class="n">keywords</span><span class="o">=</span><span class="n">keywords</span><span class="p">,</span>
                            <span class="n">protocols</span><span class="o">=</span><span class="n">protocols</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div></div>


<span class="k">class</span> <span class="nc">OptimizationDataset</span><span class="p">(</span><span class="n">BasicDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An optimisation dataset class which handles submission of settings differently from the basic dataset, and creates</span>
<span class="sd">    optimization datasets in the public or local qcarcive instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;OptimizationDataset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;OptimizationDataset&quot;</span>
    <span class="n">driver</span><span class="p">:</span> <span class="n">DriverEnum</span> <span class="o">=</span> <span class="n">DriverEnum</span><span class="o">.</span><span class="n">gradient</span>
    <span class="n">optimization_procedure</span><span class="p">:</span> <span class="n">GeometricProcedure</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="n">GeometricProcedure</span><span class="p">(),</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The optimization program and settings that should be used.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">dataset</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">OptimizationEntry</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_entry_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">OptimizationEntry</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">OptimizationEntry</span>

    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;driver&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_check_driver</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">driver</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make sure that the driver is set to gradient only and not changed.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">driver</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="s2">&quot;gradient&quot;</span><span class="p">:</span>
            <span class="n">driver</span> <span class="o">=</span> <span class="n">DriverEnum</span><span class="o">.</span><span class="n">gradient</span>
        <span class="k">return</span> <span class="n">driver</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;OptimizationDataset&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;OptimizationDataset&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add two Optimization datasets together, if the constraints are different then the entries are considered different.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">copy</span>

        <span class="kn">from</span> <span class="nn">openff.qcsubmit.utils</span> <span class="kn">import</span> <span class="n">remap_list</span>

        <span class="c1"># make sure the dataset types match</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DatasetCombinationError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The datasets must be the same type, you can not add types </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># create a new dataset</span>
        <span class="n">new_dataset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># update the elements in the dataset</span>
        <span class="n">new_dataset</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># search for the molecule</span>
            <span class="n">entry_ids</span> <span class="o">=</span> <span class="n">new_dataset</span><span class="o">.</span><span class="n">get_molecule_entry</span><span class="p">(</span>
                <span class="n">entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">entry_ids</span><span class="p">:</span>
                <span class="n">records</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">mol_id</span> <span class="ow">in</span> <span class="n">entry_ids</span><span class="p">:</span>
                    <span class="n">current_entry</span> <span class="o">=</span> <span class="n">new_dataset</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">mol_id</span><span class="p">]</span>
                    <span class="c1"># for each entry count the number of inputs incase we need a new entry</span>
                    <span class="n">records</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_entry</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">)</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">atom_map</span> <span class="o">=</span> <span class="n">off</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">are_isomorphic</span><span class="p">(</span>
                        <span class="n">entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                        <span class="n">current_entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                        <span class="n">return_atom_map</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="n">current_constraints</span> <span class="o">=</span> <span class="n">current_entry</span><span class="o">.</span><span class="n">constraints</span>
                    <span class="c1"># make sure all constraints are the same</span>
                    <span class="c1"># remap the entry to compare</span>
                    <span class="n">entry_constraints</span> <span class="o">=</span> <span class="n">Constraints</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">entry</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">freeze</span><span class="p">:</span>
                        <span class="n">entry_constraints</span><span class="o">.</span><span class="n">add_freeze_constraint</span><span class="p">(</span>
                            <span class="n">constraint</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">remap_list</span><span class="p">(</span><span class="n">constraint</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">atom_map</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">entry</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">set</span><span class="p">:</span>
                        <span class="n">entry_constraints</span><span class="o">.</span><span class="n">add_set_constraint</span><span class="p">(</span>
                            <span class="n">constraint</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                            <span class="n">remap_list</span><span class="p">(</span><span class="n">constraint</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">atom_map</span><span class="p">),</span>
                            <span class="n">constraint</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="k">if</span> <span class="n">current_constraints</span> <span class="o">==</span> <span class="n">entry_constraints</span><span class="p">:</span>
                        <span class="c1"># transfer the entries</span>
                        <span class="c1"># remap and transfer</span>
                        <span class="n">off_mol</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">mapped_mol</span> <span class="o">=</span> <span class="n">off_mol</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span>
                            <span class="n">mapping_dict</span><span class="o">=</span><span class="n">atom_map</span><span class="p">,</span> <span class="n">current_to_new</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mapped_mol</span><span class="o">.</span><span class="n">n_conformers</span><span class="p">):</span>
                            <span class="n">mapped_schema</span> <span class="o">=</span> <span class="n">mapped_mol</span><span class="o">.</span><span class="n">to_qcschema</span><span class="p">(</span>
                                <span class="n">conformer</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                                <span class="n">extras</span><span class="o">=</span><span class="n">current_entry</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extras</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="k">if</span> <span class="n">mapped_schema</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_entry</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">:</span>
                                <span class="n">current_entry</span><span class="o">.</span><span class="n">initial_molecules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapped_schema</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="c1"># else:</span>
                    <span class="c1">#     # if they are not the same move on to the next entry</span>
                    <span class="c1">#     continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># we did not break so add the entry with a new unique index</span>
                    <span class="n">core</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clean_index</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                    <span class="n">entry</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">core</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;-</span><span class="si">{</span><span class="n">tag</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">records</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">new_dataset</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">entry</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if no other molecules just add it</span>
                <span class="n">new_dataset</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">entry</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span>

        <span class="k">return</span> <span class="n">new_dataset</span>

    <span class="k">def</span> <span class="nf">_add_keywords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="s2">&quot;FractalClient&quot;</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">QCSpec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the keywords to the client and return the index number of the keyword set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            kw_id: The keyword index number in the client.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">kw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spec_keywords</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">kw_id</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">add_keywords</span><span class="p">([</span><span class="n">kw</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">kw_id</span>

    <span class="k">def</span> <span class="nf">get_qc_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">keyword_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QCSpecification</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the QC specification for the computation.</span>

<span class="sd">        Args:</span>
<span class="sd">            spec_name: The name of the spec we want to convert to a QCSpecification</span>
<span class="sd">            keyword_id: The string of the keyword set id number.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The dictionary representation of the QC specification</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_specifications</span><span class="p">[</span><span class="n">spec_name</span><span class="p">]</span>
        <span class="n">qc_spec</span> <span class="o">=</span> <span class="n">QCSpecification</span><span class="p">(</span>
            <span class="n">driver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">spec</span><span class="o">.</span><span class="n">method</span><span class="p">,</span>
            <span class="n">basis</span><span class="o">=</span><span class="n">spec</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span>
            <span class="n">keywords</span><span class="o">=</span><span class="n">keyword_id</span><span class="p">,</span>
            <span class="n">program</span><span class="o">=</span><span class="n">spec</span><span class="o">.</span><span class="n">program</span><span class="p">,</span>
            <span class="n">protocols</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wavefunction&quot;</span><span class="p">:</span> <span class="n">spec</span><span class="o">.</span><span class="n">store_wavefunction</span><span class="p">},</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">qc_spec</span>

    <span class="k">def</span> <span class="nf">_add_dataset_specification</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spec</span><span class="p">:</span> <span class="n">QCSpec</span><span class="p">,</span>
        <span class="n">dataset</span><span class="p">:</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">OptimizationDataset</span><span class="p">,</span>
        <span class="n">procedure_spec</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;OptimizationSpecification&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add the given compute spec to this Datasets&#39;s corresponding Collection.</span>

<span class="sd">        Args:</span>
<span class="sd">            spec:</span>
<span class="sd">                The QCSpec we are trying to add to the collection</span>
<span class="sd">            dataset:</span>
<span class="sd">                The QCArchive dataset this specification should be added to</span>
<span class="sd">            procedure_spec:</span>
<span class="sd">                The qcportal style optimization spec</span>

<span class="sd">        Raises:</span>
<span class="sd">            QCSpecificationError: If a specification with the same name is already added to the collection but has different settings.</span>

<span class="sd">        Note:</span>
<span class="sd">            If a specification is already stored under this name in the collection we have options:</span>
<span class="sd">            - If a spec with the same name but different details has been added and used we must raise an error to change the name of the new spec</span>
<span class="sd">            - If the spec has been added and has not been used then overwrite it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># build the qcportal version of our spec</span>
        <span class="n">kw_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_keywords</span><span class="p">(</span><span class="n">client</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">client</span><span class="p">,</span> <span class="n">spec</span><span class="o">=</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">qcportal_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_qc_spec</span><span class="p">(</span><span class="n">spec_name</span><span class="o">=</span><span class="n">spec</span><span class="o">.</span><span class="n">spec_name</span><span class="p">,</span> <span class="n">keyword_id</span><span class="o">=</span><span class="n">kw_id</span><span class="p">)</span>

        <span class="c1"># see if the spec is in the history</span>
        <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">spec_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">history</span><span class="p">:</span>
            <span class="n">collection_spec</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get_specification</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">spec</span><span class="o">.</span><span class="n">spec_name</span><span class="p">)</span>
            <span class="c1"># check they are the same</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">collection_spec</span><span class="o">.</span><span class="n">optimization_spec</span> <span class="o">==</span> <span class="n">procedure_spec</span>
                <span class="ow">and</span> <span class="n">qcportal_spec</span> <span class="o">==</span> <span class="n">collection_spec</span><span class="o">.</span><span class="n">qc_spec</span>
            <span class="p">):</span>
                <span class="c1"># the spec is already there and is the same so just skip adding it</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">QCSpecificationError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;A specification with the name </span><span class="si">{</span><span class="n">spec</span><span class="o">.</span><span class="n">spec_name</span><span class="si">}</span><span class="s2"> is already registered with the collection but has different settings and has already been used and should not be overwriten. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Please change the name of this specification to continue.&quot;</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the spec either has not been added or has not been used so set the new default</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">add_specification</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">spec</span><span class="o">.</span><span class="n">spec_name</span><span class="p">,</span>
                <span class="n">optimization_spec</span><span class="o">=</span><span class="n">procedure_spec</span><span class="p">,</span>
                <span class="n">qc_spec</span><span class="o">=</span><span class="n">qcportal_spec</span><span class="p">,</span>
                <span class="n">description</span><span class="o">=</span><span class="n">spec</span><span class="o">.</span><span class="n">spec_description</span><span class="p">,</span>
                <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_generate_collection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="s2">&quot;FractalClient&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">OptimizationDataset</span><span class="p">:</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">OptimizationDataset</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_name</span><span class="p">,</span>
            <span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">,</span>
            <span class="n">tagline</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_tagline</span><span class="p">,</span>
            <span class="n">tags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_tags</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
            <span class="n">provenance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">provenance</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">dict</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">collection</span>

    <span class="k">def</span> <span class="nf">_get_procedure_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_procedure</span><span class="o">.</span><span class="n">get_optimzation_spec</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">collection</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_compute_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="n">spec_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_tag</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="p">)</span>
        <span class="n">spec_kwargs</span><span class="p">[</span><span class="s2">&quot;subset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="n">spec_kwargs</span><span class="p">[</span><span class="s2">&quot;specification&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">spec_name</span>
        <span class="k">return</span> <span class="n">spec_kwargs</span>

    <span class="k">def</span> <span class="nf">_add_entries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">OptimizationDataset</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="n">new_entries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># check if the index has a number tag</span>
                <span class="c1"># if so, start from this tag</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clean_index</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">molecule</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;-</span><span class="si">{</span><span class="n">tag</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">new_entries</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_entry</span><span class="p">(</span>
                            <span class="n">molecule</span><span class="o">=</span><span class="n">molecule</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_entries</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_entry</span><span class="p">(</span>
                        <span class="n">molecule</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                        <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># upload remainder molecules to the server</span>
        <span class="n">dataset</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">indices</span><span class="p">,</span> <span class="n">new_entries</span>

    <span class="k">def</span> <span class="nf">_add_entry</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">molecule</span><span class="p">:</span> <span class="n">qcel</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">Molecule</span><span class="p">,</span>
        <span class="n">dataset</span><span class="p">:</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">OptimizationDataset</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">OptimizationEntry</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a molecule to the given optimization dataset and return the ids and the result of adding the molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">add_entry</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">initial_molecule</span><span class="o">=</span><span class="n">molecule</span><span class="p">,</span>
                <span class="n">attributes</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">dict</span><span class="p">(),</span>
                <span class="n">additional_keywords</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">formatted_keywords</span><span class="p">,</span>
                <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">to_tasks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">OptimizationInput</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a list of QCEngine optimisation inputs organised by the optimisation engine which should be used to run the task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">opt_program</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_procedure</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_specifications</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">qc_model</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">qc_model</span>
            <span class="n">qc_keywords</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">qc_keywords</span>
            <span class="n">qc_spec</span> <span class="o">=</span> <span class="n">QCInputSpecification</span><span class="p">(</span>
                <span class="n">driver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">qc_model</span><span class="p">,</span> <span class="n">keywords</span><span class="o">=</span><span class="n">qc_keywords</span>
            <span class="p">)</span>
            <span class="n">opt_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_procedure</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;program&quot;</span><span class="p">})</span>
            <span class="c1"># this needs to be the single point calculation program</span>
            <span class="n">opt_spec</span><span class="p">[</span><span class="s2">&quot;program&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">program</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clean_index</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">molecule</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;-</span><span class="si">{</span><span class="n">tag</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>

                    <span class="n">data</span><span class="p">[</span><span class="n">opt_program</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">OptimizationInput</span><span class="p">(</span>
                            <span class="nb">id</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                            <span class="n">keywords</span><span class="o">=</span><span class="n">opt_spec</span><span class="p">,</span>
                            <span class="n">input_specification</span><span class="o">=</span><span class="n">qc_spec</span><span class="p">,</span>
                            <span class="n">initial_molecule</span><span class="o">=</span><span class="n">molecule</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>


<span class="k">class</span> <span class="nc">TorsiondriveDataset</span><span class="p">(</span><span class="n">OptimizationDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An torsiondrive dataset class which handles submission of settings differently from the basic dataset, and creates</span>
<span class="sd">    torsiondrive datasets in the public or local qcarcive instance.</span>

<span class="sd">    Important:</span>
<span class="sd">        The dihedral_ranges for the whole dataset can be defined here or if different scan ranges are required on a case</span>
<span class="sd">        by case basis they can be defined for each torsion in a molecule separately in the keywords of the torsiondrive entry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dataset</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TorsionDriveEntry</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;TorsionDriveDataset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;TorsionDriveDataset&quot;</span>
    <span class="n">optimization_procedure</span><span class="p">:</span> <span class="n">GeometricProcedure</span> <span class="o">=</span> <span class="n">GeometricProcedure</span><span class="o">.</span><span class="n">parse_obj</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;enforce&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s2">&quot;reset&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;qccnv&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;epsilon&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="n">grid_spacing</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="p">[</span><span class="mi">15</span><span class="p">],</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The grid spcaing that should be used for all torsiondrives, this can be overwriten on a per entry basis.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">energy_upper_limit</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="mf">0.05</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The upper energy limit to spawn new optimizations in the torsiondrive.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">dihedral_ranges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The scan range that should be used for each torsiondrive, this can be overwriten on a per entry basis.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">energy_decrease_thresh</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The energy lower threshold to trigger new optimizations in the torsiondrive.&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_entry_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">TorsionDriveEntry</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">TorsionDriveEntry</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;TorsiondriveDataset&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TorsiondriveDataset&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add two TorsiondriveDatasets together, if the central bond in the dihedral is the same the entries are considered the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">copy</span>

        <span class="c1"># make sure the dataset types match</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DatasetCombinationError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The datasets must be the same type, you can not add types </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># create a new dataset</span>
        <span class="n">new_dataset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># update the elements in the dataset</span>
        <span class="n">new_dataset</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># search for the molecule</span>
            <span class="n">entry_ids</span> <span class="o">=</span> <span class="n">new_dataset</span><span class="o">.</span><span class="n">get_molecule_entry</span><span class="p">(</span>
                <span class="n">entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">mol_id</span> <span class="ow">in</span> <span class="n">entry_ids</span><span class="p">:</span>
                <span class="n">current_entry</span> <span class="o">=</span> <span class="n">new_dataset</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">mol_id</span><span class="p">]</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">atom_map</span> <span class="o">=</span> <span class="n">off</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">are_isomorphic</span><span class="p">(</span>
                    <span class="n">entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="n">current_entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="n">return_atom_map</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># gather the current dihedrals forward and backwards</span>
                <span class="n">current_dihedrals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="p">[(</span><span class="n">dihedral</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="k">for</span> <span class="n">dihedral</span> <span class="ow">in</span> <span class="n">current_entry</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">dihedral</span> <span class="ow">in</span> <span class="n">current_entry</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">:</span>
                    <span class="n">current_dihedrals</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">dihedral</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]))</span>
                    <span class="n">current_dihedrals</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">dihedral</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

                <span class="c1"># now gather the other entry dihedrals forwards and backwards</span>
                <span class="n">other_dihedrals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">dihedral</span> <span class="ow">in</span> <span class="n">entry</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">:</span>
                    <span class="n">other_dihedrals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">atom_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dihedral</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]))</span>
                    <span class="n">other_dihedrals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">atom_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dihedral</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

                <span class="n">difference</span> <span class="o">=</span> <span class="n">current_dihedrals</span> <span class="o">-</span> <span class="n">other_dihedrals</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">difference</span><span class="p">:</span>
                    <span class="c1"># the entry is already there so add new conformers and skip</span>
                    <span class="n">off_mol</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get_off_molecule</span><span class="p">(</span><span class="n">include_conformers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">mapped_mol</span> <span class="o">=</span> <span class="n">off_mol</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span>
                        <span class="n">mapping_dict</span><span class="o">=</span><span class="n">atom_map</span><span class="p">,</span> <span class="n">current_to_new</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mapped_mol</span><span class="o">.</span><span class="n">n_conformers</span><span class="p">):</span>
                        <span class="n">mapped_schema</span> <span class="o">=</span> <span class="n">mapped_mol</span><span class="o">.</span><span class="n">to_qcschema</span><span class="p">(</span>
                            <span class="n">conformer</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                            <span class="n">extras</span><span class="o">=</span><span class="n">current_entry</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extras</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">mapped_schema</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_entry</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">:</span>
                            <span class="n">current_entry</span><span class="o">.</span><span class="n">initial_molecules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapped_schema</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># none of the entries matched so add it</span>
                <span class="n">new_dataset</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span>

        <span class="k">return</span> <span class="n">new_dataset</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_records</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the number of records that will be submitted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generate_collection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="s2">&quot;FractalClient&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">TorsionDriveDataset</span><span class="p">:</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">TorsionDriveDataset</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_name</span><span class="p">,</span>
            <span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">,</span>
            <span class="n">tagline</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_tagline</span><span class="p">,</span>
            <span class="n">tags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_tags</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
            <span class="n">provenance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">provenance</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">dict</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">collection</span>

    <span class="k">def</span> <span class="nf">_add_entries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">TorsionDriveDataset</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="n">new_entries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">new_entries</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_entry</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># upload remainder molecules to the server</span>
        <span class="n">dataset</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">indices</span><span class="p">,</span> <span class="n">new_entries</span>

    <span class="k">def</span> <span class="nf">_add_entry</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">molecule</span><span class="p">:</span> <span class="n">qcel</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">Molecule</span><span class="p">,</span>
        <span class="n">dataset</span><span class="p">:</span> <span class="n">ptl</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">TorsionDriveDataset</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">TorsionDriveEntry</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a molecule to the given torsiondrive dataset and return the id and</span>
<span class="sd">        the result of adding the molecule.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">add_entry</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="n">initial_molecules</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">initial_molecules</span><span class="p">,</span>
                <span class="n">dihedrals</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">,</span>
                <span class="n">grid_spacing</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">grid_spacing</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span><span class="p">,</span>
                <span class="n">energy_upper_limit</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">energy_upper_limit</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_upper_limit</span><span class="p">,</span>
                <span class="n">additional_keywords</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">formatted_keywords</span><span class="p">,</span>
                <span class="n">attributes</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">dict</span><span class="p">(),</span>
                <span class="n">energy_decrease_thresh</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">energy_decrease_thresh</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_decrease_thresh</span><span class="p">,</span>
                <span class="n">dihedral_ranges</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">dihedral_ranges</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedral_ranges</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">to_tasks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">OptimizationInput</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a list of QCEngine procedure tasks which correspond to this dataset.&quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>

          </article>
        </div>

        <aside class="column is-hidden-touch is-2">
          
        </aside>
      </div>
  </main>
  <footer class="footer">
  <div class="footer-content">
    <div class="columns">
      <div class="fineprint column">
          <div class="copyright">
              &#169; Copyright 2021, Open Force Field Initiative.
              
          </div>
          Last updated on
            Oct 17, 2023.
          <br/>
          Created using
          <a href="http://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
           and
          <a href="https://github.com/openforcefield/openff-sphinx-theme/">the Open Force Field Sphinx theme</a>
      </div>
      <div class="socials column">
        <p class="pb-3">An <a href="https://openforcefield.org/" class="has-text-white">Open Force Field Initiative</a> project.</p>
        <div>
          
            
              
                <a href="https://zenodo.org/communities/openforcefield/" class="icon has-text-light is-medium" title="OpenFF on Zenodo">
                  <i class="fa-lg ai-lg ai ai-zenodo"></i>
                </a>
              
            
              
                <a href="https://www.youtube.com/channel/UCh0aJSUm_sYr7nuTzhW806g" class="icon has-text-light is-medium" title="OpenFF on YouTube">
                  <i class="fa-lg ai-lg fab fa-youtube"></i>
                </a>
              
            
              
                <a href="https://github.com/openforcefield" class="icon has-text-light is-medium" title="OpenFF on GitHub">
                  <i class="fa-lg ai-lg fab fa-github"></i>
                </a>
              
            
              
                <a href="https://twitter.com/openforcefield" class="icon has-text-light is-medium" title="OpenFF on Twitter">
                  <i class="fa-lg ai-lg fab fa-twitter"></i>
                </a>
              
            
              
                <a href="https://www.linkedin.com/company/openforcefield/" class="icon has-text-light is-medium" title="OpenFF on LinkedIn">
                  <i class="fa-lg ai-lg fab fa-linkedin"></i>
                </a>
              
            
          
        </div>

      </div>
    </div>
  </div>
</footer>
  </body>
</html>