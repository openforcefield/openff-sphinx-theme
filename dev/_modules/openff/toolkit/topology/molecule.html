
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  
  <link rel="icon" type="image/svg" href="../../../../_static/images/favicon.svg" />
  <link rel="apple-touch-icon" type="image/svg" href="../../../../_static/images/favicon.svg" />
  

  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="../../../../_static/site.css"/>
  
  <meta name="theme-color" content="#015480;">
  
  
    <title>openff.toolkit.topology.molecule &#8212; OpenFF Sphinx theme</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/openff.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/autodoc_pydantic.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   

  </head>
  <body dir=ltr
        data-md-color-accent=openff-toolkit-blue
        class="has-navbar-fixed-top">
  <header data-md-component="header">
  <nav class="navbar is-primary is-fixed-top is-flex-touch has-shadow" role="navigation" aria-label="main navigation">
    <div class="navbar-brand">
      <a href="../../../../index.html" title="OpenFF Sphinx theme" class="navbar-item is-hidden-mobile">
        
          <img src="../../../../_static/images/logos/openforcefield_v1_white.png" alt="OpenFF Sphinx theme logo">
        
      </a>
    </div>

    <div class="has-text-light is-hidden-mobile nav-title">
      <div class="breadcrumb">
  <ul>
        <li><a href="../../../../index.html">OpenFF Sphinx theme</a></li>
      <li><a href="../../../index.html">Module code</a></li>
      <li class="is-active"><a href="#">openff.toolkit.topology.molecule</a></li>
  </ul>
</div>
    </div>
    <div class="has-text-light is-hidden-tablet nav-title">
      <span> openff.toolkit.topology.molecule </span>
    </div>

    <div class="navbar-end">
      <span class="navbar-item nav-search is-hidden-mobile">
        
<form action="../../../../search.html" method="GET" name="search">
  <div class="control has-icons-right">
    <span class="icon is-small is-right">
      <i class="fas fa-search"></i>
    </span>
    <input class="input is-primary" type="text"  name="q" placeholder="Search"
         autocapitalize="off" autocomplete="off" spellcheck="false">
  </div>
</form>

      </span>
      
        <a href="https://github.com/openforcefield/openff-sphinx-theme/" class="is-family-monospace navbar-item is-hidden-touch has-text-light">
          
          <span class="icon-text">
            <span class="icon">
              <i class="fab fa-github"></i>
            </span>
            <span>
          
            openff-sphinx-theme
          
            </span>
          </span>
          
        </a>
      
      <a href="https://docs.openforcefield.org/" class="navbar-item is-hidden-touch">
        <img
          src="../../../../_static/images/logos/openforcefield_v2_white.png"
          alt="Open Force Field Initiative logo"
        >
      </a>
    </div>
    <span class="navbar-burger-spacer is-hidden-tablet"></span>
  </nav>

  

  <div class="level is-hidden-mobile nav-tabs">
      
      <div class="level-item has-text-centered"><a href="https://squidfunk.github.io/mkdocs-material/">Material for MkDocs</a></div>
      
      <div class="level-item has-text-centered"><a href="https://bashtage.github.io/sphinx-material/">Material for Sphinx</a></div>
      
      <div class="level-item has-text-centered"><a href="https://openforcefield.org">The OpenFF Initiative</a></div>
      
      <div class="level-item has-text-centered"><a href="https://github.com/openforcefield/openff-sphinx-theme/">openff-sphinx-theme on GitHub</a></div>
  </div>

</header>

  
  <main class="mb-6">
      <div class="columns">
        <input type="checkbox" id="drawer-toggle" class="is-hidden">
        <label for="drawer-toggle" role="button" class="navbar-burger burger is-light is-hidden-tablet">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </label>

        <aside class="column is-2-desktop is-3-tablet" id="drawer">
          <div class="is-hidden-tablet clip-siblings">
            <a href="../../../../index.html" title="OpenFF Sphinx theme">
              <h1>
                OpenFF Sphinx theme
              </h1>
            </a>
            <div class="py-3">
              
<form action="../../../../search.html" method="GET" name="search">
  <div class="control has-icons-right">
    <span class="icon is-small is-right">
      <i class="fas fa-search"></i>
    </span>
    <input class="input is-primary" type="text"  name="q" placeholder="Search"
         autocapitalize="off" autocomplete="off" spellcheck="false">
  </div>
</form>

            </div>
          </div>
          
<nav class="menu ff-globaltoc">
          
          <p class="menu-label"><span class="caption-text">Basic Use</span></p>
          <ul class="menu-list">
        
      
          
          <li>
            <a href="../../../../customization.html" class="">Customization</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../specimen.html" class="">Specimen</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../additional_samples.html" class=""><code class="docutils literal notranslate"><span class="pre">additional_samples_with_very_long_name</span></code></a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../subpage/index.html" class=""><code class="docutils literal notranslate"><span class="pre">Level</span> <span class="pre">1</span></code> page</a>
            
            </li>
          
        
      
          
            </ul>
          
          <p class="menu-label"><span class="caption-text">Other Examples and Uses</span></p>
          <ul class="menu-list">
        
      
          
          <li>
            <a href="../../../../pymethod.html" class="">Python Methods</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../numpydoc_example.html" class="">NumPy Docstrings</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../autodoc_pydantic_example.html" class="">autodoc_pydantic API Docs</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../numpydoc.html" class="">Openff-toolkit example</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../pydantic.html" class="">Pydantic API docs</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../notebook.html" class="">Jupyter Notebooks</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../markdown.html" class="">Markdown</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../rst-cheatsheet/rst-cheatsheet.html" class="">rst Cheatsheet</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../primer.html" class="">reStructuredText Primer</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../expanded-tables.html" class="">Expanded tables</a>
            
            </li>
          
        
      
          
            </ul>
          
          <p class="menu-label"><span class="caption-text">Changes and License</span></p>
          <ul class="menu-list">
        
      
          
          <li>
            <a href="../../../../change-log.html" class="">Change Log</a>
            
            </li>
          
        
      
          
          <li>
            <a href="../../../../license.html" class="">License</a>
            
            </li>
          
            </ul>
          
        
      
    </ul>
  </nav>

        </aside>

        <div class="column is-8-desktop is-9-tablet">
          <article class="content">
            
  <h1>Source code for openff.toolkit.topology.molecule</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Molecular chemical entity representation and routines to interface with cheminformatics toolkits</span>

<span class="sd">.. todo::</span>

<span class="sd">   * Our main philosophy here is to keep the object contents of topology objects easily serializable/deserializable</span>

<span class="sd">   * Have ``Molecule`` raise an exception if loading/creating molecules with unspecified stereochemistry?</span>
<span class="sd">   * Create ``FrozenMolecule`` to represent immutable molecule</span>
<span class="sd">   * Make ``Atom`` and ``Bond`` an inner class of Molecule?</span>
<span class="sd">   * Add ``Molecule.from_smarts()`` or ``.from_tagged_smiles()`` to allow a tagged SMARTS string</span>
<span class="sd">     (where tags are zero-indexed atom indices) to be used to create a molecule with the given atom numbering.</span>
<span class="sd">   * How can we make the ``Molecule`` API more useful to codes like perses that modify molecules on the fly?</span>
<span class="sd">   * Use `attrs &lt;http://www.attrs.org/&gt;`_ for convenient class initialization?</span>
<span class="sd">   * JSON/BSON representations of objects?</span>
<span class="sd">   * Generalize Molecule infrastructure to provide &quot;plug-in&quot; support for cheminformatics toolkits</span>
<span class="sd">   * Do we need a way to write a bunch of molecules to a file, or serialize a set of molecules to a file?</span>
<span class="sd">     We currently don&#39;t have a way to do that through the ``Molecule`` API, even though there is a way to</span>
<span class="sd">     read multiple molecules via ``Molecules.from_file()``.</span>
<span class="sd">   * Should we allow the removal of atoms too?</span>
<span class="sd">   * Should invalidation of cached properties be handled via something like a tracked list?</span>
<span class="sd">   * Refactor toolkit encapsulation to generalize and provide only a few major toolkit methods and toolkit objects</span>
<span class="sd">        that can be queried for features</span>
<span class="sd">   * Speed up overall import time by putting non-global imports only where they are needed</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">UserDict</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cmp_to_key</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">DefaultDict</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Generator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">TextIO</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">openff.units</span> <span class="kn">import</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">unit</span>
<span class="kn">from</span> <span class="nn">openff.units.elements</span> <span class="kn">import</span> <span class="n">MASSES</span><span class="p">,</span> <span class="n">SYMBOLS</span>
<span class="kn">from</span> <span class="nn">openff.utilities.exceptions</span> <span class="kn">import</span> <span class="n">MissingOptionalDependencyError</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="kn">from</span> <span class="nn">openff.toolkit.utils.constants</span> <span class="kn">import</span> <span class="n">DEFAULT_AROMATICITY_MODEL</span>
<span class="kn">from</span> <span class="nn">openff.toolkit.utils.exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BondExistsError</span><span class="p">,</span>
    <span class="n">HierarchySchemeNotFoundException</span><span class="p">,</span>
    <span class="n">HierarchySchemeWithIteratorNameAlreadyRegisteredException</span><span class="p">,</span>
    <span class="n">IncompatibleUnitError</span><span class="p">,</span>
    <span class="n">InvalidAtomMetadataError</span><span class="p">,</span>
    <span class="n">InvalidBondOrderError</span><span class="p">,</span>
    <span class="n">InvalidConformerError</span><span class="p">,</span>
    <span class="n">MissingPartialChargesError</span><span class="p">,</span>
    <span class="n">MultipleMoleculesInPDBError</span><span class="p">,</span>
    <span class="n">RemapIndexError</span><span class="p">,</span>
    <span class="n">SmilesParsingError</span><span class="p">,</span>
    <span class="n">UnsupportedFileTypeError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">openff.toolkit.utils.serialization</span> <span class="kn">import</span> <span class="n">Serializable</span>
<span class="kn">from</span> <span class="nn">openff.toolkit.utils.toolkits</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="n">InvalidToolkitRegistryError</span><span class="p">,</span>
    <span class="n">OpenEyeToolkitWrapper</span><span class="p">,</span>
    <span class="n">RDKitToolkitWrapper</span><span class="p">,</span>
    <span class="n">ToolkitRegistry</span><span class="p">,</span>
    <span class="n">ToolkitWrapper</span><span class="p">,</span>
    <span class="n">UndefinedStereochemistryError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">openff.toolkit.utils.utils</span> <span class="kn">import</span> <span class="n">get_data_file_path</span><span class="p">,</span> <span class="n">requires_package</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">openff.toolkit.topology._mm_molecule</span> <span class="kn">import</span> <span class="n">_SimpleAtom</span><span class="p">,</span> <span class="n">_SimpleMolecule</span>

<span class="c1"># TODO: Can we have the `ALLOWED_*_MODELS` list automatically appear in the docstrings below?</span>
<span class="c1"># TODO: Should `ALLOWED_*_MODELS` be objects instead of strings?</span>
<span class="c1"># TODO: Should these be imported from `openff.toolkit.cheminformatics.aromaticity_models` and `.bondorder_models`?</span>

<span class="c1"># TODO: Allow all OpenEye aromaticity models to be used with OpenEye names?</span>
<span class="c1">#       Only support OEAroModel_MDL in RDKit version?</span>

<span class="n">TKR</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">ToolkitRegistry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_molecule_deprecation</span><span class="p">(</span><span class="n">old_method</span><span class="p">,</span> <span class="n">new_method</span><span class="p">):</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Molecule.</span><span class="si">{</span><span class="n">old_method</span><span class="si">}</span><span class="s2"> is deprecated. Use Molecule.</span><span class="si">{</span><span class="n">new_method</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">,</span>
        <span class="n">MoleculeDeprecationWarning</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">MoleculeDeprecationWarning</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Warning for deprecated portions of the Molecule API.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">Particle</span><span class="p">(</span><span class="n">Serializable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all particles in a molecule.</span>

<span class="sd">    A particle object could be an ``Atom`` or similar.</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;FrozenMolecule&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ``Molecule`` this particle is part of.</span>

<span class="sd">        .. todo::</span>

<span class="sd">            * Should we have a single unique ``Molecule`` for each molecule</span>
<span class="sd">              type in the system, or if we have multiple copies of the same</span>
<span class="sd">              molecule, should we have multiple ``Molecule``\ s?</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span>

    <span class="nd">@molecule</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the particle&#39;s molecule pointer. Note that this will only work if the particle currently</span>
<span class="sd">        doesn&#39;t have a molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> already has an associated molecule&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="n">err</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="o">=</span> <span class="n">molecule</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecule_particle_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of this particle in its molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of the particle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert to dictionary representation.&quot;&quot;&quot;</span>
        <span class="c1"># Implement abstract method Serializable.to_dict()</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>  <span class="c1"># TODO</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Static constructor from dictionary representation.&quot;&quot;&quot;</span>
        <span class="c1"># Implement abstract method Serializable.to_dict()</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>  <span class="c1"># TODO</span>


<span class="k">class</span> <span class="nc">AtomMetadataDict</span><span class="p">(</span><span class="n">UserDict</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InvalidAtomMetadataError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Attempted to set atom metadata with a non-string key. (key: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">InvalidAtomMetadataError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Attempted to set atom metadata with a non-string or integer &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;value. (value: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Atom</span><span class="p">(</span><span class="n">Particle</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A chemical atom.</span>

<span class="sd">    .. todo::</span>

<span class="sd">       * Do we want to support the addition of arbitrary additional properties,</span>
<span class="sd">         such as floating point quantities (e.g. ``charge``), integral</span>
<span class="sd">         quantities (such as ``id`` or ``serial`` index in a PDB file),</span>
<span class="sd">         or string labels (such as Lennard-Jones types)?</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atomic_number</span><span class="p">,</span>
        <span class="n">formal_charge</span><span class="p">,</span>
        <span class="n">is_aromatic</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">molecule</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">stereochemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an immutable Atom object.</span>

<span class="sd">        Object is serializable and immutable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atomic_number : int</span>
<span class="sd">            Atomic number of the atom. Must be non-negative and non-zero.</span>
<span class="sd">        formal_charge : int or openff.units.unit.Quantity-wrapped int with dimension &quot;charge&quot;</span>
<span class="sd">            Formal charge of the atom</span>
<span class="sd">        is_aromatic : bool</span>
<span class="sd">            If True, atom is aromatic; if False, not aromatic</span>
<span class="sd">        stereochemistry : str, optional, default=None</span>
<span class="sd">            Either &#39;R&#39; or &#39;S&#39; for specified stereochemistry, or None for ambiguous stereochemistry</span>
<span class="sd">        name : str, optional, default=None</span>
<span class="sd">            An optional name to be associated with the atom</span>
<span class="sd">        metadata : dict[str: (int, str)], default=None</span>
<span class="sd">            An optional dictionary where keys are strings and values are strings or ints. This is intended</span>
<span class="sd">            to record atom-level information used to inform hierarchy definition and iteration, such as</span>
<span class="sd">            grouping atom by residue and chain.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a non-aromatic carbon atom</span>

<span class="sd">        &gt;&gt;&gt; atom = Atom(6, 0, False)</span>

<span class="sd">        Create a chiral carbon atom</span>

<span class="sd">        &gt;&gt;&gt; atom = Atom(6, 0, False, stereochemistry=&#39;R&#39;, name=&#39;CT&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atomic_number</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;atomic number must be int, found </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">atomic_number</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atomic_number</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;atomic number must be positive, given </span><span class="si">{</span><span class="n">atomic_number</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_atomic_number</span> <span class="o">=</span> <span class="n">atomic_number</span>

        <span class="c1"># Use the setter here, since it will handle either ints or Quantities</span>
        <span class="c1"># and it is designed to quickly process ints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">=</span> <span class="n">formal_charge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_aromatic</span> <span class="o">=</span> <span class="n">is_aromatic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span> <span class="o">=</span> <span class="n">stereochemistry</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="o">=</span> <span class="n">molecule</span>
        <span class="c1"># From Jeff: I&#39;m going to assume that this is implicit in the parent Molecule&#39;s ordering of atoms</span>
        <span class="c1"># self._molecule_atom_index = molecule_atom_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span> <span class="o">=</span> <span class="n">AtomMetadataDict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span> <span class="o">=</span> <span class="n">AtomMetadataDict</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>

    <span class="c1"># TODO: We can probably avoid an explicit call and determine this dynamically</span>
    <span class="c1">#   from self._molecule (maybe caching the result) to get rid of some bookkeeping.</span>
    <span class="c1"># TODO: Should stereochemistry be reset/cleared/recomputed upon addition of a bond?</span>
    <span class="k">def</span> <span class="nf">add_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a bond that this atom is involved in</span>

<span class="sd">        .. todo :: Is this how we want to keep records?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bond: an openff.toolkit.topology.molecule.Bond</span>
<span class="sd">            A bond involving this atom</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dict representation of the atom.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: Should this be implicit in the atom ordering when saved?</span>
        <span class="c1"># atom_dict[&#39;molecule_atom_index&#39;] = self._molecule_atom_index</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;atomic_number&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atomic_number</span><span class="p">,</span>
            <span class="s2">&quot;formal_charge&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formal_charge</span><span class="o">.</span><span class="n">m</span><span class="p">,</span>  <span class="c1"># Trust that the unit is e</span>
            <span class="s2">&quot;is_aromatic&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_aromatic</span><span class="p">,</span>
            <span class="s2">&quot;stereochemistry&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
            <span class="s2">&quot;metadata&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">),</span>
        <span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">atom_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an Atom from a dict representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">atom_dict</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The atom&#39;s metadata dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">formal_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The atom&#39;s formal charge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formal_charge</span>

    <span class="nd">@formal_charge</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">formal_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the atom&#39;s formal charge. Accepts either ints or unit-wrapped ints with units of charge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_formal_charge</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="c1"># Faster to check equality than convert, so short-circuit</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">units</span> <span class="ow">is</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">=</span> <span class="n">other</span>
            <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">units</span> <span class="ow">in</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="o">.</span><span class="n">compatible_units</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_formal_charge</span> <span class="o">=</span> <span class="n">other</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">IncompatibleUnitError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot set formal charge with a quantity with units </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">units</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">openmm</span> <span class="kn">import</span> <span class="n">unit</span> <span class="k">as</span> <span class="n">openmm_unit</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">openmm_unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">IncompatibleUnitError</span><span class="p">(</span>
                    <span class="s2">&quot;Unsupported type passed to formal_charge setter. &quot;</span>
                    <span class="s2">&quot;Found object of type {type(other)}.&quot;</span>
                <span class="p">)</span>

            <span class="kn">from</span> <span class="nn">openff.units.openmm</span> <span class="kn">import</span> <span class="n">from_openmm</span>

            <span class="n">converted</span> <span class="o">=</span> <span class="n">from_openmm</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">converted</span><span class="o">.</span><span class="n">units</span> <span class="ow">in</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="o">.</span><span class="n">compatible_units</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_formal_charge</span> <span class="o">=</span> <span class="n">converted</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">IncompatibleUnitError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot set formal charge with a quantity with units </span><span class="si">{</span><span class="n">converted</span><span class="o">.</span><span class="n">units</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">partial_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The partial charge of the atom, if any.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unit-wrapped float with dimension of atomic charge, or None if no charge has been specified</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule_atom_index</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">_partial_charges</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="nd">@partial_charge</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">partial_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">charge</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">partial_charges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingPartialChargesError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot set individual atom&#39;s partial charge if it is in a molecule with no partial charges. &quot;</span>
                <span class="s2">&quot;Instead, use the `Molecule.partial_charges` setter. If this behavior is important to you, &quot;</span>
                <span class="s2">&quot;please raise an issue describing your use case.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">charge</span><span class="p">,</span> <span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot set partial charge with an object that is not a openff.unit.Quantity or float. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Found object of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">charge</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">charge</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">charge</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">charge</span><span class="p">,</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">charge</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot set partial charge with an object that is not a wrapped int or float. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Found unit-wrapped </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">charge</span><span class="o">.</span><span class="n">m</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="n">molecule_partial_charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">partial_charges</span>
        <span class="n">molecule_partial_charges</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">charge</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">partial_charges</span> <span class="o">=</span> <span class="n">molecule_partial_charges</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_aromatic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The atom&#39;s is_aromatic flag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_aromatic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stereochemistry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The atom&#39;s stereochemistry (if defined, otherwise None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span>

    <span class="nd">@stereochemistry</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">stereochemistry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the atoms stereochemistry</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            The stereochemistry around this atom, allowed values are &quot;CW&quot;, &quot;CCW&quot;, or None,</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if (value != &#39;CW&#39;) and (value != &#39;CCW&#39;) and not(value is None):</span>
        <span class="c1">#    raise Exception(</span>
        <span class="c1">#       &quot;Atom stereochemistry setter expected &#39;CW&#39;, &#39;CCW&#39;, or None. &quot;&quot;</span>
        <span class="c1">#       &quot;Received {} (type {})&quot;.format(value, type(value))&quot;</span>
        <span class="c1"># )</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atomic_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The integer atomic number of the atom.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atomic_number</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the symbol implied by the atomic number of this atom</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SYMBOLS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mass</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quantity</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The standard atomic weight (abundance-weighted isotopic mass) of the atomic site.</span>

<span class="sd">        The mass is reported in units of Dalton.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is assumed elsewhere in the codebase to be in units of Dalton, which is what is</span>
        <span class="c1"># reported by MASSES as of openff-units v0.1.5. There may be performance implications if</span>
        <span class="c1"># other functions need to verify or convert units.</span>
        <span class="c1"># https://github.com/openforcefield/openff-toolkit/pull/1182#discussion_r802078273</span>
        <span class="k">return</span> <span class="n">MASSES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of this atom, if any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : string</span>
<span class="sd">            The new name for this atom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;In setting atom name. Expected str, received </span><span class="si">{</span><span class="n">other</span><span class="si">}</span><span class="s2"> (type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">other</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The list of ``Bond`` objects this atom is involved in.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bonded_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;Atom&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The list of ``Atom`` objects this atom is involved in bonds with</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">bond</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="c1"># TODO: This seems dangerous. Ask John for a better way</span>
                    <span class="k">yield</span> <span class="n">atom</span>

    <span class="k">def</span> <span class="nf">is_bonded_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether this atom is bound to another atom</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom2: openff.toolkit.topology.molecule.Atom</span>
<span class="sd">            a different atom in the same molecule</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether this atom is bound to atom2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Sanity check (check for same molecule?)</span>
        <span class="k">assert</span> <span class="bp">self</span> <span class="o">!=</span> <span class="n">atom2</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">bonded_atom</span> <span class="ow">in</span> <span class="n">bond</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom2</span> <span class="o">==</span> <span class="n">bonded_atom</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_in_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether or not this atom is in a ring(s) (of any size)</span>

<span class="sd">        This Atom is expected to be attached to a molecule (`Atom.molecule`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        toolkit_registry: openff.toolkit.utils.toolkits.ToolkitRegistry, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` to use to enumerate the tautomers.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_is_in_ring</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;atom_is_in_ring&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_is_in_ring</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecule_atom_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index of this Atom within the the list of atoms in the parent ``Molecule``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This Atom does not belong to a Molecule object&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;_molecule_atom_index&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule_atom_index</span>  <span class="c1"># type: ignore[has-type]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_molecule_atom_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule_atom_index</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Also include which molecule this atom belongs to?</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Atom(name=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2">, atomic number=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_atomic_number</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Also include which molecule this atom belongs to?</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;Atom name=&#39;</span><span class="si">{}</span><span class="s2">&#39; atomic number=&#39;</span><span class="si">{}</span><span class="s2">&#39;&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atomic_number</span>
        <span class="p">)</span>


<span class="c1"># =============================================================================================</span>
<span class="c1"># Bond Stereochemistry</span>
<span class="c1"># =============================================================================================</span>

<span class="c1"># class BondStereochemistry(Serializable):</span>
<span class="c1"># &quot;&quot;&quot;</span>
<span class="c1"># Bond stereochemistry representation</span>
<span class="c1"># &quot;&quot;&quot;</span>
<span class="c1"># def __init__(self, stereo_type, neighbor1, neighbor2):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#    Parameters</span>
<span class="c1">#    ----------</span>
<span class="c1">#    stereo_type</span>
<span class="c1">#    neighbor1</span>
<span class="c1">#    neighbor2</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    assert isinstance(neighbor1, Atom)</span>
<span class="c1">#    assert isinstance(neighbor2, Atom)</span>
<span class="c1">#    # Use stereo_type @setter to check stereo type is a permitted value</span>
<span class="c1">#    self.stereo_type = stereo_type</span>
<span class="c1">#    self._neighbor1 = neighbor1</span>
<span class="c1">#    self._neighbor2 = neighbor2</span>

<span class="c1"># def to_dict(self):</span>
<span class="c1">#    bs_dict = OrderedDict()</span>
<span class="c1">#    bs_dict[&#39;stereo_type&#39;] = self._stereo_type</span>
<span class="c1">#    bs_dict[&#39;neighbor1_index&#39;] = self._neighbor1.molecule_atom_index</span>
<span class="c1">#    bs_dict[&#39;neighbor2_index&#39;] = self._neighbor2.molecule_atom_index</span>
<span class="c1">#    return bs_dict</span>

<span class="c1"># classmethod</span>
<span class="c1"># def from_dict(cls, molecule, bs_dict):</span>
<span class="c1">#    neighbor1 = molecule.atoms[bs_dict[&#39;neighbor1_index&#39;]]</span>
<span class="c1">#    neighbor2 = molecule.atoms[bs_dict[&#39;neighbor2_index&#39;]]</span>
<span class="c1">#    return cls.__init__(bs_dict[&#39;stereo_type&#39;], neighbor1, neighbor2)</span>

<span class="c1"># @property</span>
<span class="c1"># def stereo_type(self):</span>
<span class="c1">#    return self._stereo_type</span>

<span class="c1"># @stereo_type.setter</span>
<span class="c1"># def stereo_type(self, value):</span>
<span class="c1">#    assert (value == &#39;CIS&#39;) or (value == &#39;TRANS&#39;) or (value is None)</span>
<span class="c1">#    self._stereo_type = value</span>

<span class="c1"># @property</span>
<span class="c1"># def neighbor1(self):</span>
<span class="c1">#    return self._neighbor1</span>

<span class="c1"># @property</span>
<span class="c1"># def neighbor2(self):</span>
<span class="c1">#    return self._neighbor2</span>

<span class="c1"># @property</span>
<span class="c1"># def neighbors(self):</span>
<span class="c1">#    return (self._neighbor1, self._neighbor2)</span>


<span class="k">class</span> <span class="nc">Bond</span><span class="p">(</span><span class="n">Serializable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Chemical bond representation.</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>

<span class="sd">    .. todo :: Allow bonds to have associated properties.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    atom1, atom2 : openff.toolkit.topology.Atom</span>
<span class="sd">        Atoms involved in the bond</span>
<span class="sd">    bond_order : int</span>
<span class="sd">        The (integer) bond order of this bond.</span>
<span class="sd">    is_aromatic : bool</span>
<span class="sd">        Whether or not this bond is aromatic.</span>
<span class="sd">    fractional_bond_order : float, optional</span>
<span class="sd">        The fractional bond order, or partial bond order of this bond.</span>
<span class="sd">    stereochemstry : str, optional, default=None</span>
<span class="sd">        A string representing this stereochemistry of this bond.</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atom1</span><span class="p">,</span>
        <span class="n">atom2</span><span class="p">,</span>
        <span class="n">bond_order</span><span class="p">,</span>
        <span class="n">is_aromatic</span><span class="p">,</span>
        <span class="n">fractional_bond_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">stereochemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new chemical bond.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span> <span class="o">==</span> <span class="n">Atom</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span> <span class="o">==</span> <span class="n">Atom</span>
        <span class="k">assert</span> <span class="n">atom1</span><span class="o">.</span><span class="n">molecule</span> <span class="ow">is</span> <span class="n">atom2</span><span class="o">.</span><span class="n">molecule</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">molecule</span><span class="p">,</span> <span class="n">FrozenMolecule</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">molecule</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_atom1</span> <span class="o">=</span> <span class="n">atom1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atom2</span> <span class="o">=</span> <span class="n">atom2</span>

        <span class="n">atom1</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">atom2</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># TODO: Check bondtype and fractional_bond_order are valid?</span>
        <span class="c1"># TODO: Dative bonds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fractional_bond_order</span> <span class="o">=</span> <span class="n">fractional_bond_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bond_order</span> <span class="o">=</span> <span class="n">bond_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_aromatic</span> <span class="o">=</span> <span class="n">is_aromatic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span> <span class="o">=</span> <span class="n">stereochemistry</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dict representation of the bond.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;atom1&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">,</span>
            <span class="s2">&quot;atom2&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">,</span>
            <span class="s2">&quot;bond_order&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bond_order</span><span class="p">,</span>
            <span class="s2">&quot;is_aromatic&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_aromatic</span><span class="p">,</span>
            <span class="s2">&quot;stereochemistry&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span><span class="p">,</span>
            <span class="s2">&quot;fractional_bond_order&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractional_bond_order</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">molecule</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Bond from a dict representation.&quot;&quot;&quot;</span>
        <span class="c1"># TODO</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">molecule</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;atom1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;atom1&quot;</span><span class="p">]]</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;atom2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;atom2&quot;</span><span class="p">]]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atom1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atom2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom1_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atom1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom2_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atom2</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atom1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atom2</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bond_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bond_order</span>

    <span class="nd">@bond_order</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bond_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bond_order</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidBondOrderError</span><span class="p">(</span>
                <span class="s2">&quot;Only integer bond orders may be passed to `Bond.bond_order` setter. &quot;</span>
                <span class="s2">&quot;For aromatic bonds, instead kekulize the input structure and use &quot;</span>
                <span class="s2">&quot;the resulting integer bond orders. If performing partial bond &quot;</span>
                <span class="s2">&quot;order-based parameter interpolation, consider using &quot;</span>
                <span class="s2">&quot;`Bond.fractional_bond_order`.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fractional_bond_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractional_bond_order</span>

    <span class="nd">@fractional_bond_order</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fractional_bond_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fractional_bond_order</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stereochemistry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stereochemistry</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_aromatic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_aromatic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span>

    <span class="nd">@molecule</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the Bond&#39;s parent molecule. Can not be changed after assignment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecule_bond_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index of this Bond within the the list of bonds in ``Molecules``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This Atom does not belong to a Molecule object&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_molecule</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_in_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether or not this bond is in a ring(s) (of any size)</span>

<span class="sd">        This Bond is expected to be attached to a molecule (`Bond.molecule`).</span>

<span class="sd">        Note: Bonds containing atoms that are only in separate rings, i.e. the central bond in a biphenyl,</span>
<span class="sd">            are not considered to be bonded by this criteria.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        toolkit_registry: openff.toolkit.utils.toolkits.ToolkitRegistry, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` to use to enumerate the tautomers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_in_ring: bool</span>
<span class="sd">            Whether or not this bond is in a ring.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_is_in_ring</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;bond_is_in_ring&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_is_in_ring</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Bond(atom1 index=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1_index</span><span class="si">}</span><span class="s2">, atom2 index=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atom2_index</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&lt;Bond atom1 index=&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1_index</span><span class="si">}</span><span class="s2">&#39;, atom2 index=&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atom2_index</span><span class="si">}</span><span class="s2">&#39;&gt;&quot;</span>
        <span class="p">)</span>


<span class="c1"># TODO: How do we automatically trigger invalidation of cached properties if an ``Atom`` or ``Bond`` is modified,</span>
<span class="c1">#       rather than added/deleted via the API? The simplest resolution is simply to make them immutable.</span>


<span class="k">class</span> <span class="nc">FrozenMolecule</span><span class="p">(</span><span class="n">Serializable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Immutable chemical representation of a molecule, such as a small molecule or biopolymer.</span>

<span class="sd">    .. todo :: What other API calls would be useful for supporting biopolymers</span>
<span class="sd">               as small molecules? Perhaps iterating over chains and residues?</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Create a molecule from a sdf file</span>

<span class="sd">    &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">    &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">    &gt;&gt;&gt; molecule = FrozenMolecule.from_file(sdf_filepath)</span>

<span class="sd">    Convert to OpenEye OEMol object</span>

<span class="sd">    &gt;&gt;&gt; oemol = molecule.to_openeye()</span>

<span class="sd">    Create a molecule from an OpenEye molecule</span>

<span class="sd">    &gt;&gt;&gt; molecule = FrozenMolecule.from_openeye(oemol)</span>

<span class="sd">    Convert to RDKit Mol object</span>

<span class="sd">    &gt;&gt;&gt; rdmol = molecule.to_rdkit()</span>

<span class="sd">    Create a molecule from an RDKit molecule</span>

<span class="sd">    &gt;&gt;&gt; molecule = FrozenMolecule.from_rdkit(rdmol)</span>

<span class="sd">    Create a molecule from IUPAC name (requires the OpenEye toolkit)</span>

<span class="sd">    &gt;&gt;&gt; molecule = FrozenMolecule.from_iupac(&#39;imatinib&#39;)</span>

<span class="sd">    Create a molecule from SMILES</span>

<span class="sd">    &gt;&gt;&gt; molecule = FrozenMolecule.from_smiles(&#39;Cc1ccccc1&#39;)</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">file_format</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">TKR</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new FrozenMolecule object</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * If a filename or file-like object is specified but the file</span>
<span class="sd">             contains more than one molecule, what is the proper behavior?</span>
<span class="sd">             Read just the first molecule, or raise an exception if more</span>
<span class="sd">             than one molecule is found?</span>

<span class="sd">           * Should we also support SMILES strings or IUPAC names for</span>
<span class="sd">             ``other``\ ?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : optional, default=None</span>
<span class="sd">            If specified, attempt to construct a copy of the molecule from</span>
<span class="sd">            the specified object. This can be any one of the following:</span>

<span class="sd">            * a :class:`Molecule` object</span>
<span class="sd">            * a file that can be used to construct a :class:`Molecule` object</span>
<span class="sd">            * an ``openeye.oechem.OEMol``</span>
<span class="sd">            * an ``rdkit.Chem.rdchem.Mol``</span>
<span class="sd">            * a serialized :class:`Molecule` object</span>

<span class="sd">        file_format : str, optional, default=None</span>
<span class="sd">            If providing a file-like object, you must specify the format</span>
<span class="sd">            of the data. If providing a file, the file format will attempt</span>
<span class="sd">            to be guessed from the suffix.</span>
<span class="sd">        toolkit_registry : a :class:`ToolkitRegistry` or</span>
<span class="sd">            :class:`ToolkitWrapper` object, optional,</span>
<span class="sd">            default=GLOBAL_TOOLKIT_REGISTRY :class:`ToolkitRegistry`</span>
<span class="sd">            or :class:`ToolkitWrapper` to use for I/O operations</span>
<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If loaded from a file and ``False``, raises an exception if</span>
<span class="sd">            undefined stereochemistry is detected during the molecule&#39;s</span>
<span class="sd">            construction.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create an empty molecule:</span>

<span class="sd">        &gt;&gt;&gt; empty_molecule = FrozenMolecule()</span>

<span class="sd">        Create a molecule from a file that can be used to construct a molecule,</span>
<span class="sd">        using either a filename or file-like object:</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = FrozenMolecule(sdf_filepath)</span>
<span class="sd">        &gt;&gt;&gt; molecule = FrozenMolecule(open(sdf_filepath, &#39;r&#39;), file_format=&#39;sdf&#39;)</span>

<span class="sd">        &gt;&gt;&gt; import gzip</span>
<span class="sd">        &gt;&gt;&gt; mol2_gz_filepath = get_data_file_path(&#39;molecules/toluene.mol2.gz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = FrozenMolecule(gzip.GzipFile(mol2_gz_filepath, &#39;r&#39;), file_format=&#39;mol2&#39;)</span>

<span class="sd">        Create a molecule from another molecule:</span>

<span class="sd">        &gt;&gt;&gt; molecule_copy = FrozenMolecule(molecule)</span>

<span class="sd">        Convert to OpenEye OEMol object</span>

<span class="sd">        &gt;&gt;&gt; oemol = molecule.to_openeye()</span>

<span class="sd">        Create a molecule from an OpenEye molecule:</span>

<span class="sd">        &gt;&gt;&gt; molecule = FrozenMolecule(oemol)</span>

<span class="sd">        Convert to RDKit Mol object</span>

<span class="sd">        &gt;&gt;&gt; rdmol = molecule.to_rdkit()</span>

<span class="sd">        Create a molecule from an RDKit molecule:</span>

<span class="sd">        &gt;&gt;&gt; molecule = FrozenMolecule(rdmol)</span>

<span class="sd">        Convert the molecule into a dictionary and back again:</span>

<span class="sd">        &gt;&gt;&gt; serialized_molecule = molecule.to_dict()</span>
<span class="sd">        &gt;&gt;&gt; molecule_copy = FrozenMolecule(serialized_molecule)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_smiles</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Figure out if toolkit_registry is a whole registry, or just a single wrapper</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">toolkit_registry</span> <span class="o">=</span> <span class="n">ToolkitRegistry</span><span class="p">(</span><span class="n">toolkit_precedence</span><span class="o">=</span><span class="p">[])</span>
            <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">add_toolkit</span><span class="p">(</span><span class="n">toolkit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;toolkit_registry&#39; must be either a ToolkitRegistry or a ToolkitWrapper&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loaded</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Start a list of the ValueErrors the following logic encounters, so we can print it out</span>
            <span class="c1"># if there turned out to be no way to load this input</span>
            <span class="n">value_errors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">FrozenMolecule</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">loaded</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_copy_initializer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Molecule</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">loaded</span><span class="p">:</span>
                <span class="c1"># TODO: This will need to be updated once FrozenMolecules and Molecules are significantly different</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_copy_initializer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">loaded</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_from_dict</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Check through the toolkit registry to find a compatible wrapper for loading</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">loaded</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Each ToolkitWrapper may provide a from_object method, which turns some particular type(s)</span>
                    <span class="c1"># of object into OFFMols. For example, RDKitToolkitWrapper&#39;s from_object method will</span>
                    <span class="c1"># return an OFFMol if provided with an RDMol, or raise a ValueError if it is provided</span>
                    <span class="c1"># an OEMol (or anything else). This makes the assumption that any non-ValueError errors raised</span>
                    <span class="c1"># by the toolkit _really are_ bad and should be raised immediately, which may be a bad assumption.</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                        <span class="s2">&quot;from_object&quot;</span><span class="p">,</span>
                        <span class="n">other</span><span class="p">,</span>
                        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                        <span class="n">raise_exception_types</span><span class="o">=</span><span class="p">[</span><span class="n">UndefinedStereochemistryError</span><span class="p">],</span>
                        <span class="n">_cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="c1"># NotImplementedError should never be raised... Only from_file and from_file_obj are provided</span>
                <span class="c1"># in the base ToolkitWrapper class and require overwriting, so from_object should be excluded</span>
                <span class="c1"># except NotImplementedError as e:</span>
                <span class="c1">#    raise e</span>
                <span class="c1"># The toolkit registry will aggregate all errors except UndefinedStereochemistryErrors into a single</span>
                <span class="c1"># ValueError, which we should catch and and store that here.</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">value_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_copy_initializer</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                    <span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># TODO: Make this compatible with file-like objects (I couldn&#39;t figure out how to make an oemolistream</span>
            <span class="c1"># from a fileIO object)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;read&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">loaded</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mol</span> <span class="o">=</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span>
                        <span class="n">other</span><span class="p">,</span>
                        <span class="n">file_format</span><span class="o">=</span><span class="n">file_format</span><span class="p">,</span>
                        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span><span class="p">,</span>
                        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                    <span class="p">)</span>  <span class="c1"># returns a list only if multiple molecules are found</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Specified file or file-like object must contain exactly one molecule&quot;</span>
                        <span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">value_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_copy_initializer</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
                    <span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># If none of the above methods worked, raise a ValueError summarizing the</span>
            <span class="c1"># errors from the different loading attempts</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">loaded</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot construct openff.toolkit.topology.Molecule from </span><span class="si">{</span><span class="n">other</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">value_error</span> <span class="ow">in</span> <span class="n">value_errors</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value_error</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_unique_atom_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;``True`` if the molecule has unique atom names, ``False`` otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_has_unique_atom_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generate_unique_atom_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate unique atom names from the element symbol and count.</span>

<span class="sd">        Names are generated from the elemental symbol and the number of times</span>
<span class="sd">        that element is found in the molecule. The character &#39;x&#39; is appended to</span>
<span class="sd">        these generated names to reduce the odds that they clash with an atom</span>
<span class="sd">        name or type imported from another source. For example, generated atom</span>
<span class="sd">        names might begin &#39;C1x&#39;, &#39;H1x&#39;, &#39;O1x&#39;, &#39;C2x&#39;, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_generate_unique_atom_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate the molecule, ensuring it has unique atom names</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_unique_atom_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generate_unique_atom_names</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">strip_atom_stereochemistry</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">smarts</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">TKR</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delete stereochemistry information for certain atoms, if it is present.</span>
<span class="sd">        This method can be used to &quot;normalize&quot; molecules imported from different cheminformatics</span>
<span class="sd">        toolkits, which differ in which atom centers are considered stereogenic.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        smarts: str</span>
<span class="sd">            Tagged SMARTS with a single atom with index 1. Any matches for this atom will have any assigned</span>
<span class="sd">            stereocheistry information removed.</span>
<span class="sd">        toolkit_registry : a :class:`ToolkitRegistry` or :class:`ToolkitWrapper` object, optional,</span>
<span class="sd">            default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for I/O operations</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_environment_matches</span><span class="p">(</span>
            <span class="n">smarts</span><span class="p">,</span>
            <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">matches</span><span class="p">):</span>
            <span class="n">atom_idx</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom_idx</span><span class="p">]</span><span class="o">.</span><span class="n">stereochemistry</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">####################################################################################################</span>
    <span class="c1"># Safe serialization</span>
    <span class="c1">####################################################################################################</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary representation of the molecule.</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * Document the representation standard.</span>
<span class="sd">           * How do we do version control with this standard?</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule_dict : dict</span>
<span class="sd">            A dictionary representation of the molecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openff.toolkit.utils.utils</span> <span class="kn">import</span> <span class="n">serialize_numpy</span>

        <span class="n">molecule_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

        <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">]</span>
        <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;bonds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="p">]</span>

        <span class="c1"># TODO: This assumes everything in _properties can safely be deepcopied</span>
        <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_cached_properties&quot;</span><span class="p">):</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;cached_properties&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cached_properties</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;conformers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;conformers_unit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;angstrom&quot;</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;conformers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">serialize_numpy</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charge_unit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charges&quot;</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">serialize_numpy</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charge_unit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;elementary_charge&quot;</span>

        <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;hierarchy_schemes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">iter_name</span><span class="p">,</span> <span class="n">hier_scheme</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;hierarchy_schemes&quot;</span><span class="p">][</span><span class="n">iter_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">hier_scheme</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">molecule_dict</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a hash of this molecule. Used when checking molecule uniqueness in Topology creation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_smiles</span><span class="p">())</span>

    <span class="c1"># @cached_property</span>
    <span class="k">def</span> <span class="nf">ordered_connection_table_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute an ordered hash of the atoms and bonds in the molecule&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_connection_table_hash</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_connection_table_hash</span>

        <span class="nb">id</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="nb">id</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">symbol</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">formal_charge</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">stereochemistry</span><span class="si">}</span><span class="s2">__&quot;</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="nb">id</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bond</span><span class="o">.</span><span class="n">bond_order</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">bond</span><span class="o">.</span><span class="n">stereochemistry</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1_index</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2_index</span><span class="si">}</span><span class="s2">__&quot;</span>
        <span class="c1"># return hash(id)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_connection_table_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_connection_table_hash</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">molecule_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Molecule from a dictionary representation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule_dict : dict</span>
<span class="sd">            A dictionary representation of the molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : Molecule</span>
<span class="sd">            A Molecule created from the dictionary representation</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This implementation is a compromise to let this remain as a classmethod</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">_initialize_from_dict</span><span class="p">(</span><span class="n">molecule_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span>

    <span class="k">def</span> <span class="nf">_initialize_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the molecule from a dictionary representation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule_dict : dict</span>
<span class="sd">            A dictionary representation of the molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Provide useful exception messages if there are any failures</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">atom_dict</span> <span class="ow">in</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_atom</span><span class="p">(</span><span class="o">**</span><span class="n">atom_dict</span><span class="p">,</span> <span class="n">invalidate_cache</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">bond_dict</span> <span class="ow">in</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;bonds&quot;</span><span class="p">]:</span>
            <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom1&quot;</span><span class="p">])</span>
            <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom2&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_bond</span><span class="p">(</span><span class="o">**</span><span class="n">bond_dict</span><span class="p">,</span> <span class="n">invalidate_cache</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charges&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">openff.toolkit.utils.utils</span> <span class="kn">import</span> <span class="n">deserialize_numpy</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span>
                <span class="n">deserialize_numpy</span><span class="p">(</span><span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charges&quot;</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,)),</span>
                <span class="n">unit</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;partial_charge_unit&quot;</span><span class="p">]),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;conformers&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">openff.toolkit.utils.utils</span> <span class="kn">import</span> <span class="n">deserialize_numpy</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span>
                    <span class="n">deserialize_numpy</span><span class="p">(</span><span class="n">ser_conf</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
                    <span class="n">unit</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;conformers_unit&quot;</span><span class="p">]),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">ser_conf</span> <span class="ow">in</span> <span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;conformers&quot;</span><span class="p">]</span>
            <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">molecule_dict</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">iter_name</span><span class="p">,</span> <span class="n">hierarchy_scheme_dict</span> <span class="ow">in</span> <span class="n">molecule_dict</span><span class="p">[</span>
            <span class="s2">&quot;hierarchy_schemes&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># It&#39;s important that we do NOT call `add_hierarchy_scheme` here, since we</span>
            <span class="c1"># need to deserialize these HierarchyElements exactly as they were serialized,</span>
            <span class="c1"># even if that conflicts with the current values in atom metadata.</span>
            <span class="n">new_hier_scheme</span> <span class="o">=</span> <span class="n">HierarchyScheme</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="n">hierarchy_scheme_dict</span><span class="p">[</span><span class="s2">&quot;uniqueness_criteria&quot;</span><span class="p">]),</span>
                <span class="n">iter_name</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span><span class="p">[</span><span class="n">iter_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_hier_scheme</span>

            <span class="k">for</span> <span class="n">element_dict</span> <span class="ow">in</span> <span class="n">hierarchy_scheme_dict</span><span class="p">[</span><span class="s2">&quot;hierarchy_elements&quot;</span><span class="p">]:</span>
                <span class="n">new_hier_scheme</span><span class="o">.</span><span class="n">add_hierarchy_element</span><span class="p">(</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="n">element_dict</span><span class="p">[</span><span class="s2">&quot;identifier&quot;</span><span class="p">]),</span> <span class="n">element_dict</span><span class="p">[</span><span class="s2">&quot;atom_indices&quot;</span><span class="p">]</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a summary of this molecule; SMILES if valid, Hill formula if not.&quot;&quot;&quot;</span>
        <span class="n">description</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Molecule with name &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_smiles</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">hill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_hill_formula</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">description</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; with bad SMILES and Hill formula &#39;</span><span class="si">{</span><span class="n">hill</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="k">return</span> <span class="n">description</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; and SMILES &#39;</span><span class="si">{</span><span class="n">smiles</span><span class="si">}</span><span class="s2">&#39;&quot;</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear the contents of the current molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># List of bonds between Atom objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Attached properties to be preserved</span>
        <span class="c1"># self._cached_properties = None # Cached properties (such as partial charges) can be recomputed as needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Optional conformers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hill_formula</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Cached Hill formula</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalidate_cached_properties</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_copy_initializer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy contents of the specified molecule</span>

<span class="sd">        .. todo :: Should this be a ``@staticmethod`` where we have an explicit copy constructor?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : optional</span>
<span class="sd">            Overwrite the state of this FrozenMolecule with the specified FrozenMolecule object.</span>
<span class="sd">            A deep copy is made.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_from_dict</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test two molecules for equality to see if they are the chemical species, but do not check other</span>
<span class="sd">        annotated properties.</span>

<span class="sd">        .. note ::</span>

<span class="sd">           Note that this method simply tests whether two molecules are identical chemical species using equivalence of</span>
<span class="sd">           their canonical isomeric SMILES.  No effort is made to ensure that the atoms are in the same order or that</span>
<span class="sd">           any annotated properties are preserved.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># updated to use the new isomorphic checking method, with full matching</span>
        <span class="c1"># TODO the doc string did not match the previous function what matching should this method do?</span>
        <span class="k">return</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">are_isomorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">return_atom_map</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">add_default_hierarchy_schemes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds ``chain`` and ``residue`` hierarchy schemes.</span>

<span class="sd">        The Open Force Field Toolkit has no native understanding of hierarchical</span>
<span class="sd">        atom organisation schemes common to other biomolecular software, such as</span>
<span class="sd">        &quot;residues&quot; or &quot;chains&quot; (see :ref:`userguide_hierarchy`). Hierarchy</span>
<span class="sd">        schemes allow iteration over groups of atoms according to their</span>
<span class="sd">        metadata. For more information, see</span>
<span class="sd">        :class:`~openff.toolkit.topology.molecule.HierarchyScheme`.</span>

<span class="sd">        If a ``Molecule`` with the default hierarchy schemes</span>
<span class="sd">        changes, :meth:`Molecule.update_hierarchy_schemes()` must be called before</span>
<span class="sd">        the residues or chains are iterated over again or else the iteration may</span>
<span class="sd">        be incorrect.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        overwrite_existing : bool, default=True</span>
<span class="sd">            Whether to overwrite existing instances of the `residue` and `chain`</span>
<span class="sd">            hierarchy schemes. If this is ``False`` and either of the hierarchy</span>
<span class="sd">            schemes are already defined on this molecule, an exception will be</span>
<span class="sd">            raised.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        HierarchySchemeWithIteratorNameAlreadyRegisteredException</span>
<span class="sd">            When ``overwrite_existing=False`` and either the ``chains`` or</span>
<span class="sd">            ``residues`` hierarchy scheme is already configured.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        HierarchyScheme, Molecule.add_hierarchy_scheme,</span>
<span class="sd">        Molecule.update_hierarchy_schemes, Molecule.perceive_residues,</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_chain_hierarchy_scheme</span><span class="p">(</span><span class="n">overwrite_existing</span><span class="o">=</span><span class="n">overwrite_existing</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_residue_hierarchy_scheme</span><span class="p">(</span><span class="n">overwrite_existing</span><span class="o">=</span><span class="n">overwrite_existing</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_chain_hierarchy_scheme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add ``chain`` hierarchy scheme.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">overwrite_existing</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;chains&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_hierarchy_scheme</span><span class="p">(</span><span class="s2">&quot;chains&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_hierarchy_scheme</span><span class="p">((</span><span class="s2">&quot;chain_id&quot;</span><span class="p">,),</span> <span class="s2">&quot;chains&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_residue_hierarchy_scheme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add ``residue`` hierarchy scheme.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">overwrite_existing</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;residues&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_hierarchy_scheme</span><span class="p">(</span><span class="s2">&quot;residues&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_hierarchy_scheme</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;chain_id&quot;</span><span class="p">,</span> <span class="s2">&quot;residue_number&quot;</span><span class="p">,</span> <span class="s2">&quot;insertion_code&quot;</span><span class="p">,</span> <span class="s2">&quot;residue_name&quot;</span><span class="p">),</span> <span class="s2">&quot;residues&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_hierarchy_scheme</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">uniqueness_criteria</span><span class="p">,</span>
        <span class="n">iterator_name</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use the molecule&#39;s metadata to facilitate iteration over its atoms.</span>

<span class="sd">        This method will add an attribute with the name given by the</span>
<span class="sd">        ``iterator_name`` argument that provides an iterator over groups of</span>
<span class="sd">        atoms. Atoms are grouped by the values in their ``atom.metadata``</span>
<span class="sd">        dictionary; any atoms with the same values for the keys given in the</span>
<span class="sd">        ``uniqueness_criteria`` argument will be in the same group. These groups</span>
<span class="sd">        have the type :class:`~openff.toolkit.topology.molecule.HierarchyElement`.</span>

<span class="sd">        Hierarchy schemes are not updated dynamically; if a ``Molecule`` with</span>
<span class="sd">        hierarchy schemes changes, :meth:`Molecule.update_hierarchy_schemes()` must</span>
<span class="sd">        be called before the scheme is iterated over again or else the grouping</span>
<span class="sd">        may be incorrect.</span>

<span class="sd">        Hierarchy schemes allow iteration over groups of atoms according to</span>
<span class="sd">        their metadata. For more information, see</span>
<span class="sd">        :class:`~openff.toolkit.topology.molecule.HierarchyScheme`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uniqueness_criteria : tuple of str</span>
<span class="sd">            The names of ``Atom`` metadata entries that define this scheme. An</span>
<span class="sd">            atom belongs to a ``HierarchyElement`` only if its metadata has the</span>
<span class="sd">            same values for these criteria as the other atoms in the</span>
<span class="sd">            ``HierarchyElement``.</span>

<span class="sd">        iterator_name : str</span>
<span class="sd">            Name of the iterator that will be exposed to access the hierarchy</span>
<span class="sd">            elements generated by this scheme.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_hier_scheme : openff.toolkit.topology.HierarchyScheme</span>
<span class="sd">            The newly created HierarchyScheme</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        Molecule.add_default_hierarchy_schemes, Molecule.hierarchy_schemes,</span>
<span class="sd">        Molecule.delete_hierarchy_scheme,  Molecule.update_hierarchy_schemes,</span>
<span class="sd">        HierarchyScheme,</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">iterator_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Can not add iterator with name &quot;</span><span class="si">{</span><span class="n">iterator_name</span><span class="si">}</span><span class="s1">&quot; to this topology, as iterator &#39;</span>
                <span class="sa">f</span><span class="s2">&quot;name is already used by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span><span class="p">[</span><span class="n">iterator_name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">HierarchySchemeWithIteratorNameAlreadyRegisteredException</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">new_hier_scheme</span> <span class="o">=</span> <span class="n">HierarchyScheme</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">uniqueness_criteria</span><span class="p">,</span>
            <span class="n">iterator_name</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span><span class="p">[</span><span class="n">iterator_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_hier_scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_hierarchy_schemes</span><span class="p">([</span><span class="n">iterator_name</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">new_hier_scheme</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hierarchy_schemes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;HierarchyScheme&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The hierarchy schemes available on the molecule.</span>

<span class="sd">        Hierarchy schemes allow iteration over groups of atoms according to</span>
<span class="sd">        their metadata. For more information, see</span>
<span class="sd">        :class:`~openff.toolkit.topology.molecule.HierarchyScheme`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A dict of the form {str: HierarchyScheme}</span>
<span class="sd">            The HierarchySchemes associated with the molecule.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        Molecule.add_hierarchy_scheme, Molecule.delete_hierarchy_scheme,</span>
<span class="sd">        Molecule.update_hierarchy_schemes, Topology.hierarchy_iterator,</span>
<span class="sd">        HierarchyScheme</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span>

    <span class="k">def</span> <span class="nf">delete_hierarchy_scheme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iter_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove an existing ``HierarchyScheme`` specified by its iterator name.</span>

<span class="sd">        Hierarchy schemes allow iteration over groups of atoms according to</span>
<span class="sd">        their metadata. For more information, see</span>
<span class="sd">        :class:`~openff.toolkit.topology.molecule.HierarchyScheme`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iter_name : str</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        Molecule.add_hierarchy_scheme, Molecule.update_hierarchy_schemes,</span>
<span class="sd">        Molecule.hierarchy_schemes, HierarchyScheme</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">iter_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HierarchySchemeNotFoundException</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Can not delete HierarchyScheme with name &quot;</span><span class="si">{</span><span class="n">iter_name</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
                <span class="sa">f</span><span class="s2">&quot;because no HierarchyScheme with that iterator name exists&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">iter_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_hierarchy_schemes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iter_names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer a hierarchy from atom metadata according to the existing hierarchy</span>
<span class="sd">        schemes.</span>

<span class="sd">        Hierarchy schemes allow iteration over groups of atoms according to</span>
<span class="sd">        their metadata. For more information, see</span>
<span class="sd">        :class:`~openff.toolkit.topology.molecule.HierarchyScheme`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iter_names : Iterable of str, Optional</span>
<span class="sd">            Only perceive hierarchy for HierarchySchemes that expose these</span>
<span class="sd">            iterator names. If not provided, all known hierarchies will be</span>
<span class="sd">            perceived, overwriting previous results if applicable.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        Molecule.add_hierarchy_scheme, Molecule.delete_hierarchy_schemes,</span>
<span class="sd">        Molecule.hierarchy_schemes, HierarchyScheme</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">iter_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">iter_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">iter_name</span> <span class="ow">in</span> <span class="n">iter_names</span><span class="p">:</span>
            <span class="n">hierarchy_scheme</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span><span class="p">[</span><span class="n">iter_name</span><span class="p">]</span>
            <span class="n">hierarchy_scheme</span><span class="o">.</span><span class="n">perceive_hierarchy</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;HierarchyElement&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If a requested attribute is not found, check the hierarchy schemes&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_hierarchy_schemes&quot;</span><span class="p">][</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">hierarchy_elements</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object has no attribute </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add the hierarchy scheme iterator names to dir&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy_schemes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">to_smiles</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">isomeric</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">explicit_hydrogens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mapped</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">TKR</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a canonical isomeric SMILES representation of the current molecule.</span>
<span class="sd">        A partially mapped smiles can also be generated for atoms of interest by supplying an `atom_map` to the</span>
<span class="sd">        properties dictionary.</span>

<span class="sd">        .. note :: RDKit and OpenEye versions will not necessarily return the same representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        isomeric: bool optional, default= True</span>
<span class="sd">            return an isomeric smiles</span>
<span class="sd">        explicit_hydrogens: bool optional, default=True</span>
<span class="sd">            return a smiles string containing all hydrogens explicitly</span>
<span class="sd">        mapped: bool optional, default=False</span>
<span class="sd">            return a explicit hydrogen mapped smiles, the atoms to be mapped can be controlled by supplying an</span>
<span class="sd">            atom map into the properties dictionary. If no mapping is passed all atoms will be mapped in order, else</span>
<span class="sd">            an atom map dictionary from the current atom index to the map id should be supplied with no duplicates.</span>
<span class="sd">            The map ids (values) should start from 0 or 1.</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or</span>
<span class="sd">            openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMILES conversion</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smiles : str</span>
<span class="sd">            Canonical isomeric explicit-hydrogen SMILES</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule(sdf_filepath)</span>
<span class="sd">        &gt;&gt;&gt; smiles = molecule.to_smiles()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Figure out which toolkit should be used to create the SMILES</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">to_smiles_method</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="s2">&quot;to_smiles&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">to_smiles_method</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">to_smiles</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to to_smiles. Expected ToolkitRegistry or ToolkitWrapper. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Get a string representation of the function containing the toolkit name so we can check</span>
        <span class="c1"># if a SMILES was already cached for this molecule. This will return, for example</span>
        <span class="c1"># &quot;RDKitToolkitWrapper.to_smiles&quot;</span>
        <span class="n">smiles_hash</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">to_smiles_method</span><span class="o">.</span><span class="vm">__qualname__</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">isomeric</span><span class="p">)</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">explicit_hydrogens</span><span class="p">)</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mapped</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">smiles_hash</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;atom_map&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="c1"># Check to see if a SMILES for this molecule was already cached using this method</span>
        <span class="k">if</span> <span class="n">smiles_hash</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_smiles</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_smiles</span><span class="p">[</span><span class="n">smiles_hash</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">to_smiles_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isomeric</span><span class="p">,</span> <span class="n">explicit_hydrogens</span><span class="p">,</span> <span class="n">mapped</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cached_smiles</span><span class="p">[</span><span class="n">smiles_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">smiles</span>
            <span class="k">return</span> <span class="n">smiles</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_inchi</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">inchi</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">TKR</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a Molecule from a InChI representation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inchi : str</span>
<span class="sd">            The InChI representation of the molecule.</span>

<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            Whether to accept InChI with undefined stereochemistry. If False,</span>
<span class="sd">            an exception will be raised if a InChI with undefined stereochemistry</span>
<span class="sd">            is passed into this function.</span>

<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolRegistry</span>
<span class="sd">            or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for InChI-to-molecule conversion</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Make cis-1,2-Dichloroethene:</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_inchi(&#39;InChI=1S/C2H2Cl2/c3-1-2-4/h1-2H/b2-1-&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;from_inchi&quot;</span><span class="p">,</span>
                <span class="n">inchi</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_inchi</span><span class="p">(</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="n">inchi</span><span class="p">,</span> <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to from_inchi. Expected ToolkitRegistry or ToolkitWrapper. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">molecule</span>

    <span class="k">def</span> <span class="nf">to_inchi</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fixed_hydrogens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">TKR</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an InChI string for the molecule using the requested toolkit backend.</span>
<span class="sd">        InChI is a standardised representation that does not capture tautomers unless specified using the fixed</span>
<span class="sd">        hydrogen layer.</span>

<span class="sd">        For information on InChi see here https://iupac.org/who-we-are/divisions/division-details/inchi/</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fixed_hydrogens: bool, default=False</span>
<span class="sd">            If a fixed hydrogen layer should be added to the InChI, if `True` this will produce a non standard</span>
<span class="sd">            specific InChI string of the molecule.</span>

<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolRegistry</span>
<span class="sd">            or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for molecule-to-InChI conversion</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        inchi: str</span>
<span class="sd">            The InChI string of the molecule.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        InvalidToolkitRegistryError</span>
<span class="sd">             If an invalid object is passed as the toolkit_registry parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">inchi</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;to_inchi&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">fixed_hydrogens</span><span class="o">=</span><span class="n">fixed_hydrogens</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">inchi</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">to_inchi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_hydrogens</span><span class="o">=</span><span class="n">fixed_hydrogens</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to to_inchi. Expected ToolkitRegistry or ToolkitWrapper. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">inchi</span>

    <span class="k">def</span> <span class="nf">to_inchikey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fixed_hydrogens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">TKR</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an InChIKey for the molecule using the requested toolkit backend.</span>
<span class="sd">        InChIKey is a standardised representation that does not capture tautomers unless specified</span>
<span class="sd">        using the fixed hydrogen layer.</span>

<span class="sd">        For information on InChi see here https://iupac.org/who-we-are/divisions/division-details/inchi/</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fixed_hydrogens: bool, default=False</span>
<span class="sd">            If a fixed hydrogen layer should be added to the InChI, if `True` this will produce a non standard specific</span>
<span class="sd">            InChI string of the molecule.</span>

<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolRegistry</span>
<span class="sd">            or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for molecule-to-InChIKey conversion</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        inchi_key: str</span>
<span class="sd">            The InChIKey representation of the molecule.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        InvalidToolkitRegistryError</span>
<span class="sd">             If an invalid object is passed as the toolkit_registry parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">inchi_key</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;to_inchikey&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">fixed_hydrogens</span><span class="o">=</span><span class="n">fixed_hydrogens</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">inchi_key</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">to_inchikey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_hydrogens</span><span class="o">=</span><span class="n">fixed_hydrogens</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to to_inchikey. Expected ToolkitRegistry or ToolkitWrapper. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">inchi_key</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_smiles</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">hydrogens_are_explicit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">TKR</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a ``Molecule`` from a SMILES representation</span>

<span class="sd">        The order of atoms in the ``Molecule`` is unspecified and may change</span>
<span class="sd">        from version to version or with different toolkits. SMILES atom</span>
<span class="sd">        indices (also known as atom maps) are not used to order atoms; instead,</span>
<span class="sd">        they are stored in the produced molecule&#39;s properties attribute,</span>
<span class="sd">        accessible via ``molecule.properties[&quot;atom_map&quot;]``. The atom map is</span>
<span class="sd">        stored as a dictionary mapping molecule atom indices to SMILES atom</span>
<span class="sd">        maps. To order atoms according to SMILES atom indices, see</span>
<span class="sd">        :py:meth:`Molecule.from_mapped_smiles`, which helpfully raises an</span>
<span class="sd">        exception if any atom map is missing, duplicated, or out-of-range,</span>
<span class="sd">        or else :py:meth:`Molecule.remap` for arbitrary remaps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        smiles</span>
<span class="sd">            The SMILES representation of the molecule.</span>
<span class="sd">        hydrogens_are_explicit</span>
<span class="sd">            If ``True``, forbid the cheminformatics toolkit from inferring</span>
<span class="sd">            hydrogen atoms not explicitly specified in the SMILES.</span>
<span class="sd">        toolkit_registry</span>
<span class="sd">            The cheminformatics toolkit to use to interpret the SMILES.</span>
<span class="sd">        allow_undefined_stereo</span>
<span class="sd">            Whether to accept SMILES with undefined stereochemistry. If</span>
<span class="sd">            ``False``, an exception will be raised if a SMILES with undefined</span>
<span class="sd">            stereochemistry is passed into this function.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RadicalsNotSupportedError</span>
<span class="sd">            If any atoms in the input molecule contain radical electrons.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a ``Molecule`` representing toluene from SMILES:</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;Cc1ccccc1&#39;)</span>

<span class="sd">        Create a ``Molecule`` representing phenol from SMILES with the oxygen</span>
<span class="sd">        at atom index 0 (SMILES indices begin at 1):</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;c1ccccc1[OH:1]&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = molecule.remap(</span>
<span class="sd">        ...     {k: v - 1 for k, v in molecule.properties[&quot;atom_map&quot;].items()},</span>
<span class="sd">        ...     partial=True,</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; assert molecule.atom(0).symbol == &quot;O&quot;</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_mapped_smiles, remap</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;from_smiles&quot;</span><span class="p">,</span>
                <span class="n">smiles</span><span class="p">,</span>
                <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="n">hydrogens_are_explicit</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_smiles</span><span class="p">(</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="n">smiles</span><span class="p">,</span>
                <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="n">hydrogens_are_explicit</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to from_smiles. Expected ToolkitRegistry or ToolkitWrapper. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">molecule</span>

    <span class="k">def</span> <span class="nf">_is_exactly_the_same_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">!=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">!=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">formal_charge</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">is_aromatic</span> <span class="o">!=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">is_aromatic</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">stereochemistry</span> <span class="o">!=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">stereochemistry</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">bond1</span><span class="p">,</span> <span class="n">bond2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">bonds</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">bond1</span><span class="o">.</span><span class="n">atom1_index</span> <span class="o">!=</span> <span class="n">bond2</span><span class="o">.</span><span class="n">atom1_index</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">bond1</span><span class="o">.</span><span class="n">atom2_index</span> <span class="o">!=</span> <span class="n">bond2</span><span class="o">.</span><span class="n">atom2_index</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">bond1</span><span class="o">.</span><span class="n">is_aromatic</span> <span class="o">!=</span> <span class="n">bond2</span><span class="o">.</span><span class="n">is_aromatic</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">bond1</span><span class="o">.</span><span class="n">stereochemistry</span> <span class="o">!=</span> <span class="n">bond2</span><span class="o">.</span><span class="n">stereochemistry</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">are_isomorphic</span><span class="p">(</span>
        <span class="n">mol1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;FrozenMolecule&quot;</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">],</span>
        <span class="n">mol2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;FrozenMolecule&quot;</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">],</span>
        <span class="n">return_atom_map</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">aromatic_matching</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">formal_charge_matching</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">bond_order_matching</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">atom_stereochemistry_matching</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">bond_stereochemistry_matching</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">strip_pyrimidal_n_atom_stereo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">TKR</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if ``mol1`` is isomorphic to ``mol2``.</span>

<span class="sd">        ``are_isomorphic()`` compares two molecule&#39;s graph representations and</span>
<span class="sd">        the chosen node/edge attributes. Connections and atomic numbers are</span>
<span class="sd">        always checked.</span>

<span class="sd">        If nx.Graphs() are given they must at least have ``atomic_number``</span>
<span class="sd">        attributes on nodes. Other attributes that ``are_isomorphic()`` can</span>
<span class="sd">        optionally check...</span>

<span class="sd">        -  ... in nodes are:</span>

<span class="sd">           -  ``is_aromatic``</span>
<span class="sd">           -  ``formal_charge``</span>
<span class="sd">           -  ``stereochemistry``</span>

<span class="sd">        -  ... in edges are:</span>

<span class="sd">           -  ``is_aromatic``</span>
<span class="sd">           -  ``bond_order``</span>
<span class="sd">           -  ``stereochemistry``</span>

<span class="sd">        By default, all attributes are checked, but stereochemistry around</span>
<span class="sd">        pyrimidal nitrogen is ignored.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mol1 : an openff.toolkit.topology.molecule.FrozenMolecule or nx.Graph()</span>
<span class="sd">            The first molecule to test for isomorphism.</span>

<span class="sd">        mol2 : an openff.toolkit.topology.molecule.FrozenMolecule or nx.Graph()</span>
<span class="sd">            The second molecule to test for isomorphism.</span>

<span class="sd">        return_atom_map: bool, default=False, optional</span>
<span class="sd">            Return a ``dict`` containing the atomic mapping instead of a</span>
<span class="sd">            ``bool``.</span>

<span class="sd">        aromatic_matching: bool, default=True, optional</span>
<span class="sd">            If ``False``, aromaticity of graph nodes and edges are ignored for</span>
<span class="sd">            the purpose of determining isomorphism.</span>

<span class="sd">        formal_charge_matching: bool, default=True, optional</span>
<span class="sd">            If ``False``, formal charges of graph nodes are ignored for</span>
<span class="sd">            the purpose of determining isomorphism.</span>

<span class="sd">        bond_order_matching: bool, default=True, optional</span>
<span class="sd">            If ``False``, bond orders of graph edges are ignored for</span>
<span class="sd">            the purpose of determining isomorphism.</span>

<span class="sd">        atom_stereochemistry_matching : bool, default=True, optional</span>
<span class="sd">            If ``False``, atoms&#39; stereochemistry is ignored for the</span>
<span class="sd">            purpose of determining isomorphism.</span>

<span class="sd">        bond_stereochemistry_matching : bool, default=True, optional</span>
<span class="sd">            If ``False``, bonds&#39; stereochemistry is ignored for the</span>
<span class="sd">            purpose of determining isomorphism.</span>

<span class="sd">        strip_pyrimidal_n_atom_stereo: bool, default=True, optional</span>
<span class="sd">            If ``True``, any stereochemistry defined around pyrimidal</span>
<span class="sd">            nitrogen stereocenters will be disregarded in the isomorphism</span>
<span class="sd">            check.</span>

<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry</span>
<span class="sd">            or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for</span>
<span class="sd">            removing stereochemistry from pyrimidal nitrogens.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecules_are_isomorphic : bool</span>

<span class="sd">        atom_map : default=None, Optional,</span>
<span class="sd">            [Dict[int,int]] ordered by mol1 indexing {mol1_index: mol2_index}</span>
<span class="sd">            If molecules are not isomorphic given input arguments, will return None instead of dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_object_to_n_atoms</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">FrozenMolecule</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">n_atoms</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;are_isomorphic accepts a NetworkX Graph or OpenFF &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;(Frozen)Molecule, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Quick number of atoms check. Important for large molecules</span>
        <span class="k">if</span> <span class="n">_object_to_n_atoms</span><span class="p">(</span><span class="n">mol1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_object_to_n_atoms</span><span class="p">(</span><span class="n">mol2</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># If the number of atoms match, check the Hill formula</span>
        <span class="k">if</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">_object_to_hill_formula</span><span class="p">(</span><span class="n">mol1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">_object_to_hill_formula</span><span class="p">(</span>
            <span class="n">mol2</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># Do a quick check to see whether the inputs are totally identical (including being in the same atom order)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mol1</span><span class="p">,</span> <span class="n">FrozenMolecule</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mol2</span><span class="p">,</span> <span class="n">FrozenMolecule</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mol1</span><span class="o">.</span><span class="n">_is_exactly_the_same_as</span><span class="p">(</span><span class="n">mol2</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol1</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)}</span>

        <span class="c1"># Build the user defined matching functions</span>
        <span class="k">def</span> <span class="nf">node_match_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="c1"># always match by atleast atomic number</span>
            <span class="n">is_equal</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;atomic_number&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;atomic_number&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">aromatic_matching</span><span class="p">:</span>
                <span class="n">is_equal</span> <span class="o">&amp;=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">formal_charge_matching</span><span class="p">:</span>
                <span class="n">is_equal</span> <span class="o">&amp;=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;formal_charge&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;formal_charge&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">atom_stereochemistry_matching</span><span class="p">:</span>
                <span class="n">is_equal</span> <span class="o">&amp;=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">is_equal</span>

        <span class="c1"># check if we want to do any bond matching if not the function is None</span>
        <span class="k">if</span> <span class="n">aromatic_matching</span> <span class="ow">or</span> <span class="n">bond_order_matching</span> <span class="ow">or</span> <span class="n">bond_stereochemistry_matching</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">edge_match_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="c1"># We don&#39;t need to check the exact bond order (which is 1 or 2)</span>
                <span class="c1"># if the bond is aromatic. This way we avoid missing a match only</span>
                <span class="c1"># if the alternate bond orders 1 and 2 are assigned differently.</span>
                <span class="k">if</span> <span class="n">aromatic_matching</span> <span class="ow">and</span> <span class="n">bond_order_matching</span><span class="p">:</span>
                    <span class="n">is_equal</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span>
                        <span class="n">x</span><span class="p">[</span><span class="s2">&quot;bond_order&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;bond_order&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">aromatic_matching</span><span class="p">:</span>
                    <span class="n">is_equal</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;is_aromatic&quot;</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">bond_order_matching</span><span class="p">:</span>
                    <span class="n">is_equal</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;bond_order&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;bond_order&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">is_equal</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">bond_stereochemistry_matching</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_equal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">is_equal</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">is_equal</span> <span class="o">&amp;=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;stereochemistry&quot;</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">is_equal</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_match_func</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Here we should work out what data type we have, also deal with lists?</span>
        <span class="k">def</span> <span class="nf">to_networkx</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;For the given data type, return the networkx graph&quot;&quot;&quot;</span>
            <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

            <span class="k">if</span> <span class="n">strip_pyrimidal_n_atom_stereo</span><span class="p">:</span>
                <span class="n">SMARTS</span> <span class="o">=</span> <span class="s2">&quot;[N+0X3:1](-[*])(-[*])(-[*])&quot;</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">FrozenMolecule</span><span class="p">):</span>
                <span class="c1"># Molecule class instance</span>
                <span class="k">if</span> <span class="n">strip_pyrimidal_n_atom_stereo</span><span class="p">:</span>
                    <span class="c1"># Make a copy of the molecule so we don&#39;t modify the original</span>
                    <span class="n">data</span><span class="p">:</span> <span class="n">FrozenMolecule</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">strip_atom_stereochemistry</span><span class="p">(</span>
                        <span class="n">SMARTS</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">data</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The input type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not supported,&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;please supply an openff.toolkit.topology.molecule.Molecule &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;or networkx.Graph representation of the molecule.&quot;</span>
                <span class="p">)</span>

        <span class="n">mol1_netx</span> <span class="o">=</span> <span class="n">to_networkx</span><span class="p">(</span><span class="n">mol1</span><span class="p">)</span>
        <span class="n">mol2_netx</span> <span class="o">=</span> <span class="n">to_networkx</span><span class="p">(</span><span class="n">mol2</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">networkx.algorithms.isomorphism</span> <span class="kn">import</span> <span class="n">GraphMatcher</span>  <span class="c1"># type: ignore</span>

        <span class="n">GM</span> <span class="o">=</span> <span class="n">GraphMatcher</span><span class="p">(</span>
            <span class="n">mol1_netx</span><span class="p">,</span> <span class="n">mol2_netx</span><span class="p">,</span> <span class="n">node_match</span><span class="o">=</span><span class="n">node_match_func</span><span class="p">,</span> <span class="n">edge_match</span><span class="o">=</span><span class="n">edge_match_func</span>
        <span class="p">)</span>
        <span class="n">isomorphic</span> <span class="o">=</span> <span class="n">GM</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">isomorphic</span> <span class="ow">and</span> <span class="n">return_atom_map</span><span class="p">:</span>
            <span class="n">topology_atom_map</span> <span class="o">=</span> <span class="n">GM</span><span class="o">.</span><span class="n">mapping</span>

            <span class="c1"># reorder the mapping by keys</span>
            <span class="n">sorted_mapping</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">topology_atom_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">sorted_mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">topology_atom_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">isomorphic</span><span class="p">,</span> <span class="n">sorted_mapping</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">isomorphic</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">is_isomorphic_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;FrozenMolecule&quot;</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the molecule is isomorphic with the other molecule which can be an openff.toolkit.topology.Molecule</span>
<span class="sd">        or nx.Graph(). Full matching is done using the options described bellow.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: openff.toolkit.topology.Molecule or nx.Graph()</span>

<span class="sd">        aromatic_matching: bool, default=True, optional</span>
<span class="sd">        compare the aromatic attributes of bonds and atoms.</span>

<span class="sd">        formal_charge_matching: bool, default=True, optional</span>
<span class="sd">        compare the formal charges attributes of the atoms.</span>

<span class="sd">        bond_order_matching: bool, deafult=True, optional</span>
<span class="sd">        compare the bond order on attributes of the bonds.</span>

<span class="sd">        atom_stereochemistry_matching : bool, default=True, optional</span>
<span class="sd">            If ``False``, atoms&#39; stereochemistry is ignored for the</span>
<span class="sd">            purpose of determining equality.</span>

<span class="sd">        bond_stereochemistry_matching : bool, default=True, optional</span>
<span class="sd">            If ``False``, bonds&#39; stereochemistry is ignored for the</span>
<span class="sd">            purpose of determining equality.</span>

<span class="sd">        strip_pyrimidal_n_atom_stereo: bool, default=True, optional</span>
<span class="sd">            If ``True``, any stereochemistry defined around pyrimidal</span>
<span class="sd">            nitrogen stereocenters will be disregarded in the isomorphism</span>
<span class="sd">            check.</span>

<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry</span>
<span class="sd">            or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for</span>
<span class="sd">            removing stereochemistry from pyrimidal nitrogens.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        isomorphic : bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">are_isomorphic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">return_atom_map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">aromatic_matching</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;aromatic_matching&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
            <span class="n">formal_charge_matching</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;formal_charge_matching&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
            <span class="n">bond_order_matching</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bond_order_matching&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
            <span class="n">atom_stereochemistry_matching</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;atom_stereochemistry_matching&quot;</span><span class="p">,</span> <span class="kc">True</span>
            <span class="p">),</span>
            <span class="n">bond_stereochemistry_matching</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;bond_stereochemistry_matching&quot;</span><span class="p">,</span> <span class="kc">True</span>
            <span class="p">),</span>
            <span class="n">strip_pyrimidal_n_atom_stereo</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;strip_pyrimidal_n_atom_stereo&quot;</span><span class="p">,</span> <span class="kc">True</span>
            <span class="p">),</span>
            <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;toolkit_registry&quot;</span><span class="p">,</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">),</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">generate_conformers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">TKR</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">n_conformers</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">rms_cutoff</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Quantity</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">clear_existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">make_carboxylic_acids_cis</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate conformers for this molecule using an underlying toolkit.</span>

<span class="sd">        If ``n_conformers=0``, no toolkit wrapper will be called. If ``n_conformers=0``</span>
<span class="sd">        and ``clear_existing=True``, ``molecule.conformers`` will be set to ``None``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or</span>
<span class="sd">            openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMILES-to-molecule conversion</span>
<span class="sd">        n_conformers : int, default=1</span>
<span class="sd">            The maximum number of conformers to produce</span>
<span class="sd">        rms_cutoff : openff.unit.Quantity-wrapped float, in units of distance, optional, default=None</span>
<span class="sd">            The minimum RMS value at which two conformers are considered redundant and one is deleted. Precise</span>
<span class="sd">            implementation of this cutoff may be toolkit-dependent. If ``None``, the cutoff is set to be the</span>
<span class="sd">            default value for each ``ToolkitWrapper`` (generally 1 Angstrom).</span>
<span class="sd">        clear_existing : bool, default=True</span>
<span class="sd">            Whether to overwrite existing conformers for the molecule</span>
<span class="sd">        make_carboxylic_acids_cis: bool, default=True</span>
<span class="sd">            Guarantee all conformers have exclusively cis carboxylic acid groups (COOH)</span>
<span class="sd">            by rotating the proton in any trans carboxylic acids 180 degrees around the</span>
<span class="sd">            C-O bond. Works around a bug in conformer generation by the OpenEye toolkit</span>
<span class="sd">            where trans COOH is much more common than it should be.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;CCCCCC&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule.generate_conformers()</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        InvalidToolkitRegistryError</span>
<span class="sd">            If an invalid object is passed as the toolkit_registry parameter</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no conformers are requested, do not call to a ToolkitWrapper at all</span>
        <span class="k">if</span> <span class="n">n_conformers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">clear_existing</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;generate_conformers&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">n_conformers</span><span class="o">=</span><span class="n">n_conformers</span><span class="p">,</span>
                <span class="n">rms_cutoff</span><span class="o">=</span><span class="n">rms_cutoff</span><span class="p">,</span>
                <span class="n">clear_existing</span><span class="o">=</span><span class="n">clear_existing</span><span class="p">,</span>
                <span class="n">raise_exception_types</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">make_carboxylic_acids_cis</span><span class="o">=</span><span class="n">make_carboxylic_acids_cis</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="k">return</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">generate_conformers</span><span class="p">(</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">n_conformers</span><span class="o">=</span><span class="n">n_conformers</span><span class="p">,</span>
                <span class="n">rms_cutoff</span><span class="o">=</span><span class="n">rms_cutoff</span><span class="p">,</span>
                <span class="n">clear_existing</span><span class="o">=</span><span class="n">clear_existing</span><span class="p">,</span>
                <span class="n">make_carboxylic_acids_cis</span><span class="o">=</span><span class="n">make_carboxylic_acids_cis</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to generate_conformers. Expected ToolkitRegistry or ToolkitWrapper. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_carboxylic_acids_cis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">TKR</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate dihedral angle of any conformers with trans COOH groups so they are cis</span>

<span class="sd">        Carboxylic acid groups almost always exist in nature in the cis conformation,</span>
<span class="sd">        with the hydrogen atom in between the two oxygen atoms::</span>

<span class="sd">                  O----H</span>
<span class="sd">                 /</span>
<span class="sd">                /</span>
<span class="sd">               /</span>
<span class="sd">            --C</span>
<span class="sd">               \\</span>
<span class="sd">                \\</span>
<span class="sd">                  O</span>

<span class="sd">        However, the OpenEye toolkit frequently produces carboxylic acid geometries</span>
<span class="sd">        in the unrealistic trans conformation::</span>

<span class="sd">             H----O</span>
<span class="sd">                 /</span>
<span class="sd">                /</span>
<span class="sd">               /</span>
<span class="sd">            --C</span>
<span class="sd">               \\</span>
<span class="sd">                \\</span>
<span class="sd">                  O</span>

<span class="sd">        This method converts all conformers in the molecule with the trans conformation</span>
<span class="sd">        into the corresponding cis conformer by rotating the OH bond around the CO bond</span>
<span class="sd">        by 180 degrees. Carboxylic acids that are already cis are unchanged. Carboxylic</span>
<span class="sd">        acid groups are considered cis if their O-C-O-H dihedral angle is acute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry</span>
<span class="sd">            or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMILES-to-molecule conversion</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Return early if there are no conformers</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Convert all conformers into one big array</span>
        <span class="n">conformers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">q</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span><span class="p">])</span>

        <span class="c1"># Scan the molecule for carboxylic acids</span>
        <span class="n">cooh_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_environment_matches</span><span class="p">(</span>
            <span class="s2">&quot;[C:2]([O:3][H:4])=[O:1]&quot;</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span>
        <span class="p">)</span>
        <span class="n">n_conformers</span><span class="p">,</span> <span class="n">n_cooh_groups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">conformers</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">cooh_indices</span><span class="p">)</span>
        <span class="c1"># Exit early if there are no carboxylic acids</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">n_cooh_groups</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Pull out the coordinates of all carboxylic acid groups into cooh_xyz</span>
        <span class="n">cooh_xyz</span> <span class="o">=</span> <span class="n">conformers</span><span class="p">[:,</span> <span class="n">cooh_indices</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">assert</span> <span class="n">cooh_xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_conformers</span><span class="p">,</span> <span class="n">n_cooh_groups</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Compute dot product along last axis of arrays&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Compute norm along last axis of array&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">dihedral</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Compute dihedrals of array with shape (..., 4, 3)&quot;&quot;&quot;</span>
            <span class="c1"># Praxeolitic formula</span>
            <span class="c1"># 1 sqrt, 1 cross product</span>
            <span class="c1"># from https://stackoverflow.com/q/20305272</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">p3</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>

            <span class="n">b0</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">p1</span> <span class="o">-</span> <span class="n">p0</span><span class="p">)</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">p3</span> <span class="o">-</span> <span class="n">p2</span>

            <span class="c1"># normalize b1 so that it does not influence magnitude of vector</span>
            <span class="c1"># rejections that come next</span>
            <span class="n">b1</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>

            <span class="c1"># vector rejections</span>
            <span class="c1"># v = projection of b0 onto plane perpendicular to b1</span>
            <span class="c1">#   = b0 minus component that aligns with b1</span>
            <span class="c1"># w = projection of b2 onto plane perpendicular to b1</span>
            <span class="c1">#   = b2 minus component that aligns with b1</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span> <span class="o">*</span> <span class="n">b1</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">b2</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span> <span class="o">*</span> <span class="n">b1</span>

            <span class="c1"># angle between v and w in a plane is the torsion angle</span>
            <span class="c1"># v and w may not be normalized but that&#39;s fine since tan is y/x</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">w</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">dihedral</span><span class="p">(</span><span class="n">cooh_xyz</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">dihedrals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_conformers</span><span class="p">,</span> <span class="n">n_cooh_groups</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dihedrals</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_conformers</span><span class="p">,</span> <span class="n">n_cooh_groups</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get indices of trans COOH groups</span>
        <span class="n">trans_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">((</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dihedrals</span><span class="p">,</span> <span class="n">dihedrals</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="c1"># Expand array so it can be used to index cooh_xyz</span>
        <span class="n">trans_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">trans_indices</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">trans_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">trans_indices</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># Get indices of individual atoms in trans COOH groups (except terminal O)</span>
        <span class="n">trans_indices_h</span> <span class="o">=</span> <span class="n">trans_indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">trans_indices_h</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">trans_indices_c</span> <span class="o">=</span> <span class="n">trans_indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">trans_indices_c</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">trans_indices_o</span> <span class="o">=</span> <span class="n">trans_indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">trans_indices_o</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Rotate OH around CO bond</span>
        <span class="c1"># We want to rotate H 180 degrees around the CO bond (b1)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">cooh_xyz</span><span class="p">[</span><span class="n">trans_indices_c</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">cooh_xyz</span><span class="p">[</span><span class="n">trans_indices_o</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">cooh_xyz</span><span class="p">[</span><span class="n">trans_indices_h</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># Axis is defined as the line from the origin along a unit vector, so</span>
        <span class="c1"># move C to the origin and normalize</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">h</span> <span class="o">-</span> <span class="n">c</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">o</span> <span class="o">-</span> <span class="n">c</span>
        <span class="n">axis</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="c1"># Do the rotation</span>
        <span class="c1"># https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle</span>
        <span class="n">rotated</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">*</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">point</span><span class="p">))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">point</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
        <span class="c1"># Move rotated point back to original coordinates</span>
        <span class="n">rotated</span> <span class="o">=</span> <span class="n">rotated</span> <span class="o">+</span> <span class="n">c</span>

        <span class="c1"># Update the coordinates</span>
        <span class="n">cooh_xyz</span><span class="p">[</span><span class="n">trans_indices_h</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotated</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Update conformers with rotated coordinates</span>
        <span class="n">conformers</span><span class="p">[:,</span> <span class="n">cooh_indices</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cooh_xyz</span>

        <span class="c1"># Return conformers to original type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="p">[</span><span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span> <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="n">conformers</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">apply_elf_conformer_selection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">percentage</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span><span class="n">ToolkitRegistry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select a set of diverse conformers from the molecule&#39;s conformers with ELF.</span>

<span class="sd">        Applies the `Electrostatically Least-interacting Functional groups method</span>
<span class="sd">        &lt;https://docs.eyesopen.com/toolkits/python/quacpactk/molchargetheory.html#elf-conformer-selection&gt;`_</span>
<span class="sd">        to select a set of diverse conformers which have minimal</span>
<span class="sd">        electrostatically strongly interacting functional groups from the</span>
<span class="sd">        molecule&#39;s conformers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        toolkit_registry</span>
<span class="sd">            The underlying toolkit to use to select the ELF conformers.</span>
<span class="sd">        percentage</span>
<span class="sd">            The percentage of conformers with the lowest electrostatic</span>
<span class="sd">            interaction energies to greedily select from.</span>
<span class="sd">        limit</span>
<span class="sd">            The maximum number of conformers to select.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * The input molecule should have a large set of conformers already</span>
<span class="sd">          generated to select the ELF conformers from.</span>
<span class="sd">        * The selected conformers will be retained in the `conformers` list</span>
<span class="sd">          while unselected conformers will be discarded.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        openff.toolkit.utils.toolkits.OpenEyeToolkitWrapper.apply_elf_conformer_selection</span>
<span class="sd">        openff.toolkit.utils.toolkits.RDKitToolkitWrapper.apply_elf_conformer_selection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;apply_elf_conformer_selection&quot;</span><span class="p">,</span>
                <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">percentage</span><span class="o">=</span><span class="n">percentage</span><span class="p">,</span>
                <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">toolkit</span><span class="o">.</span><span class="n">apply_elf_conformer_selection</span><span class="p">(</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentage</span><span class="o">=</span><span class="n">percentage</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid toolkit_registry passed to apply_elf_conformer_selection.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Expected ToolkitRegistry or ToolkitWrapper. Got &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">assign_partial_charges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">partial_charge_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">strict_n_conformers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_conformers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Quantity</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">TKR</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">normalize_partial_charges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate partial atomic charges and store them in the molecule.</span>

<span class="sd">        ``assign_partial_charges`` computes charges using the specified toolkit</span>
<span class="sd">        and assigns the new values to the ``partial_charges`` attribute.</span>
<span class="sd">        Supported charge methods vary from toolkit to toolkit, but some</span>
<span class="sd">        supported methods are:</span>

<span class="sd">        - ``&quot;am1bcc&quot;``</span>
<span class="sd">        - ``&quot;am1bccelf10&quot;`` (requires OpenEye Toolkits)</span>
<span class="sd">        - ``&quot;am1-mulliken&quot;``</span>
<span class="sd">        - ``&quot;mmff94&quot;``</span>
<span class="sd">        - ``&quot;gasteiger&quot;``</span>

<span class="sd">        For more supported charge methods and details, see the corresponding</span>
<span class="sd">        methods in each toolkit wrapper:</span>

<span class="sd">        - :meth:`OpenEyeToolkitWrapper.assign_partial_charges \</span>
<span class="sd">          &lt;openff.toolkit.utils.toolkits.OpenEyeToolkitWrapper.assign_partial_charges&gt;`</span>
<span class="sd">        - :meth:`RDKitToolkitWrapper.assign_partial_charges \</span>
<span class="sd">          &lt;openff.toolkit.utils.toolkits.RDKitToolkitWrapper.assign_partial_charges&gt;`</span>
<span class="sd">        - :meth:`AmberToolsToolkitWrapper.assign_partial_charges \</span>
<span class="sd">          &lt;openff.toolkit.utils.toolkits.AmberToolsToolkitWrapper.assign_partial_charges&gt;`</span>
<span class="sd">        - :meth:`BuiltInToolkitWrapper.assign_partial_charges \</span>
<span class="sd">          &lt;openff.toolkit.utils.toolkits.BuiltInToolkitWrapper.assign_partial_charges&gt;`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        partial_charge_method : string</span>
<span class="sd">            The partial charge calculation method to use for partial charge</span>
<span class="sd">            calculation.</span>
<span class="sd">        strict_n_conformers : bool, default=False</span>
<span class="sd">            Whether to raise an exception if an invalid number of conformers is</span>
<span class="sd">            provided for the given charge method. If this is False and an</span>
<span class="sd">            invalid number of conformers is found, a warning will be raised.</span>
<span class="sd">        use_conformers : iterable of openff.unit.Quantity-wrapped numpy arrays, each with shape (n_atoms, 3) and</span>
<span class="sd">            dimension of distance. Optional, default=None</span>
<span class="sd">            Coordinates to use for partial charge calculation. If None, an</span>
<span class="sd">            appropriate number of conformers will be generated.</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or</span>
<span class="sd">            openff.toolkit.utils.toolkits.ToolkitWrapper,</span>
<span class="sd">            optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for the</span>
<span class="sd">            calculation.</span>
<span class="sd">        normalize_partial_charges : bool, default=True</span>
<span class="sd">            Whether to offset partial charges so that they sum to the total</span>
<span class="sd">            formal charge of the molecule. This is used to prevent accumulation</span>
<span class="sd">            of rounding errors when the partial charge assignment method returns</span>
<span class="sd">            values at limited precision.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;CCCCCC&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule.assign_partial_charges(&#39;am1-mulliken&#39;)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        InvalidToolkitRegistryError</span>
<span class="sd">            If an invalid object is passed as the toolkit_registry parameter</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        openff.toolkit.utils.toolkits.OpenEyeToolkitWrapper.assign_partial_charges</span>
<span class="sd">        openff.toolkit.utils.toolkits.RDKitToolkitWrapper.assign_partial_charges</span>
<span class="sd">        openff.toolkit.utils.toolkits.AmberToolsToolkitWrapper.assign_partial_charges</span>
<span class="sd">        openff.toolkit.utils.toolkits.BuiltInToolkitWrapper.assign_partial_charges</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Raise a warning when users try to apply these charge methods to &quot;large&quot; molecules</span>
        <span class="n">WARN_LARGE_MOLECULES</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;am1bcc&quot;</span><span class="p">,</span>
            <span class="s2">&quot;am1bccelf10&quot;</span><span class="p">,</span>
            <span class="s2">&quot;am1-mulliken&quot;</span><span class="p">,</span>
            <span class="s2">&quot;am1bccnosymspt&quot;</span><span class="p">,</span>
            <span class="s2">&quot;am1elf10&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">partial_charge_method</span> <span class="ow">in</span> <span class="n">WARN_LARGE_MOLECULES</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">&gt;</span> <span class="mi">150</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Warning! Partial charge method &#39;</span><span class="si">{</span><span class="n">partial_charge_method</span><span class="si">}</span><span class="s2">&#39; is not designed &quot;</span>
                    <span class="s2">&quot;for use on large (i.e. &gt; 150 atoms) molecules and may crash or take hours to &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;run on this molecule (found </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="si">}</span><span class="s2"> atoms). For more, see &quot;</span>
                    <span class="s2">&quot;https://docs.openforcefield.org/projects/toolkit/en/stable/faq.html&quot;</span>
                    <span class="s2">&quot;#parameterizing-my-system-which-contains-a-large-molecule-is-taking-forever-whats-wrong&quot;</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="c1"># We may need to try several toolkitwrappers to find one</span>
            <span class="c1"># that supports the desired partial charge method, so we</span>
            <span class="c1"># tell the ToolkitRegistry to continue trying ToolkitWrappers</span>
            <span class="c1"># if one raises an error (raise_exception_types=[])</span>
            <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;assign_partial_charges&quot;</span><span class="p">,</span>
                <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">partial_charge_method</span><span class="o">=</span><span class="n">partial_charge_method</span><span class="p">,</span>
                <span class="n">use_conformers</span><span class="o">=</span><span class="n">use_conformers</span><span class="p">,</span>
                <span class="n">strict_n_conformers</span><span class="o">=</span><span class="n">strict_n_conformers</span><span class="p">,</span>
                <span class="n">normalize_partial_charges</span><span class="o">=</span><span class="n">normalize_partial_charges</span><span class="p">,</span>
                <span class="n">raise_exception_types</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit_wrapper</span><span class="p">:</span> <span class="n">ToolkitWrapper</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">toolkit_wrapper</span><span class="o">.</span><span class="n">assign_partial_charges</span><span class="p">(</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">partial_charge_method</span><span class="o">=</span><span class="n">partial_charge_method</span><span class="p">,</span>
                <span class="n">use_conformers</span><span class="o">=</span><span class="n">use_conformers</span><span class="p">,</span>
                <span class="n">strict_n_conformers</span><span class="o">=</span><span class="n">strict_n_conformers</span><span class="p">,</span>
                <span class="n">normalize_partial_charges</span><span class="o">=</span><span class="n">normalize_partial_charges</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid toolkit_registry passed to assign_partial_charges.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Expected ToolkitRegistry or ToolkitWrapper. Got  </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_normalize_partial_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add offsets to each partial charge to ensure that they sum to the formal charge of the molecule,</span>
<span class="sd">        to the limit of a python float&#39;s precision. Modifies the partial charges in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expected_charge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_charge</span>

        <span class="n">current_charge</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span>
        <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_charges</span><span class="p">:</span>
            <span class="n">current_charge</span> <span class="o">+=</span> <span class="n">pc</span>

        <span class="n">charge_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">expected_charge</span> <span class="o">-</span> <span class="n">current_charge</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">partial_charges</span> <span class="o">+=</span> <span class="n">charge_offset</span>

    <span class="k">def</span> <span class="nf">assign_fractional_bond_orders</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bond_order_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">use_conformers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update and store list of bond orders this molecule.</span>

<span class="sd">        Bond orders are stored on each bond, in the</span>
<span class="sd">        ``bond.fractional_bond_order`` attribute.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or</span>
<span class="sd">            openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMILES-to-molecule conversion</span>
<span class="sd">        bond_order_model : string, optional. Default=None</span>
<span class="sd">            The bond order model to use for fractional bond order calculation. If ``None``, ``&quot;am1-wiberg&quot;`` is used.</span>
<span class="sd">        use_conformers : iterable of openff.unit.Quantity(np.array) with shape (n_atoms, 3) and dimension of distance,</span>
<span class="sd">            optional, default=None</span>
<span class="sd">            The conformers to use for fractional bond order calculation. If ``None``, an appropriate number</span>
<span class="sd">            of conformers will be generated by an available ``ToolkitWrapper``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit import Molecule</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;CCCCCC&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule.assign_fractional_bond_orders()</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        InvalidToolkitRegistryError</span>
<span class="sd">            If an invalid object is passed as the toolkit_registry parameter</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;assign_fractional_bond_orders&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">bond_order_model</span><span class="o">=</span><span class="n">bond_order_model</span><span class="p">,</span>
                <span class="n">use_conformers</span><span class="o">=</span><span class="n">use_conformers</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="k">return</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">assign_fractional_bond_orders</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">bond_order_model</span><span class="o">=</span><span class="n">bond_order_model</span><span class="p">,</span> <span class="n">use_conformers</span><span class="o">=</span><span class="n">use_conformers</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid toolkit_registry passed to assign_fractional_bond_orders. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Expected ToolkitRegistry or ToolkitWrapper. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_invalidate_cached_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicate that the chemical entity has been altered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if hasattr(self, &#39;_cached_properties&#39;):</span>
        <span class="c1">#    delattr(self, &#39;_cached_properties&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_propers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_hill_formula</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_smiles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># TODO: Clear fractional bond orders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_connection_table_hash</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;_molecule_atom_index&quot;</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">atom</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_molecule_atom_index&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">to_networkx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a NetworkX undirected graph from the molecule.</span>

<span class="sd">        Nodes are Atoms labeled with atom indices and atomic elements (via the ``element`` node atrribute).</span>
<span class="sd">        Edges denote chemical bonds between Atoms.</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * Do we need a ``from_networkx()`` method? If so, what would the Graph be required to provide?</span>
<span class="sd">           * Should edges be labeled with discrete bond types in some aromaticity model?</span>
<span class="sd">           * Should edges be labeled with fractional bond order if a method is specified?</span>
<span class="sd">           * Should we add other per-atom and per-bond properties (e.g. partial charges) if present?</span>
<span class="sd">           * Can this encode bond/atom chirality?</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        graph : networkx.Graph</span>
<span class="sd">            The resulting graph, with nodes (atoms) labeled with atom indices, elements, stereochemistry and</span>
<span class="sd">            aromaticity flags and bonds with two atom indices, bond order, stereochemistry, and aromaticity flags</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Retrieve the bond graph for imatinib (OpenEye toolkit required)</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;imatinib&#39;)</span>
<span class="sd">        &gt;&gt;&gt; nxgraph = molecule.to_networkx()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">,</span>
                <span class="n">atomic_number</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">,</span>
                <span class="n">is_aromatic</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">is_aromatic</span><span class="p">,</span>
                <span class="n">stereochemistry</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">stereochemistry</span><span class="p">,</span>
                <span class="n">formal_charge</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">formal_charge</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># G.add_node(atom.molecule_atom_index, attr_dict={&#39;atomic_number&#39;: atom.atomic_number})</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span>
                <span class="n">bond</span><span class="o">.</span><span class="n">atom1_index</span><span class="p">,</span>
                <span class="n">bond</span><span class="o">.</span><span class="n">atom2_index</span><span class="p">,</span>
                <span class="n">bond_order</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">bond_order</span><span class="p">,</span>
                <span class="n">is_aromatic</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">is_aromatic</span><span class="p">,</span>
                <span class="n">stereochemistry</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">stereochemistry</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># G.add_edge(bond.atom1_index, bond.atom2_index, attr_dict={&#39;order&#39;:bond.bond_order})</span>

        <span class="k">return</span> <span class="n">G</span>

    <span class="k">def</span> <span class="nf">find_rotatable_bonds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ignore_functional_groups</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all bonds classed as rotatable ignoring any matched to the ``ignore_functional_groups`` list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignore_functional_groups: optional, List[str], default=None,</span>
<span class="sd">            A list of bond SMARTS patterns to be ignored when finding rotatable bonds.</span>

<span class="sd">        toolkit_registry: openff.toolkit.utils.toolkits.ToolkitRegistry</span>
<span class="sd">            or openff.toolkit.utils.toolkits.ToolkitWrapperl, optional, default=None</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMARTS matching</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bonds: List[openff.toolkit.topology.molecule.Bond]</span>
<span class="sd">            The list of openff.toolkit.topology.molecule.Bond instances which are rotatable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># general rotatable bond smarts taken from RDKit</span>
        <span class="c1"># https://github.com/rdkit/rdkit/blob/1bf6ef3d65f5c7b06b56862b3fb9116a3839b229/rdkit/Chem/Lipinski.py#L47%3E</span>
        <span class="n">rotatable_bond_smarts</span> <span class="o">=</span> <span class="s2">&quot;[!$(*#*)&amp;!D1:1]-&amp;!@[!$(*#*)&amp;!D1:2]&quot;</span>

        <span class="c1"># get all of the general matches</span>
        <span class="n">general_matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_environment_matches</span><span class="p">(</span>
            <span class="n">query</span><span class="o">=</span><span class="n">rotatable_bond_smarts</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span>
        <span class="p">)</span>

        <span class="c1"># this will give all forwards and backwards matches, so condense them down with this function</span>
        <span class="k">def</span> <span class="nf">condense_matches</span><span class="p">(</span><span class="n">matches</span><span class="p">):</span>
            <span class="n">condensed_matches</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                <span class="n">condensed_matches</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">m</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">condensed_matches</span>

        <span class="n">general_bonds</span> <span class="o">=</span> <span class="n">condense_matches</span><span class="p">(</span><span class="n">general_matches</span><span class="p">)</span>

        <span class="c1"># now refine the list using the ignore groups</span>
        <span class="k">if</span> <span class="n">ignore_functional_groups</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">matches_to_ignore</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="c1"># make ignore_functional_groups an iterable object</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ignore_functional_groups</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">ignore_functional_groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">ignore_functional_groups</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">iter</span><span class="p">(</span><span class="n">ignore_functional_groups</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">ignore_functional_groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">ignore_functional_groups</span><span class="p">]</span>

            <span class="c1"># find the functional groups to remove</span>
            <span class="k">for</span> <span class="n">functional_group</span> <span class="ow">in</span> <span class="n">ignore_functional_groups</span><span class="p">:</span>
                <span class="c1"># note I run the searches through this function so they have to be SMIRKS?</span>
                <span class="n">ignore_matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_environment_matches</span><span class="p">(</span>
                    <span class="n">query</span><span class="o">=</span><span class="n">functional_group</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span>
                <span class="p">)</span>
                <span class="n">ignore_matches</span> <span class="o">=</span> <span class="n">condense_matches</span><span class="p">(</span><span class="n">ignore_matches</span><span class="p">)</span>
                <span class="c1"># add the new matches to the matches to ignore</span>
                <span class="n">matches_to_ignore</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ignore_matches</span><span class="p">)</span>

            <span class="c1"># now remove all the matches</span>
            <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches_to_ignore</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">general_bonds</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
                <span class="c1"># if the key is not in the list, the ignore pattern was not valid</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">continue</span>

        <span class="c1"># gather a list of bond instances to return</span>
        <span class="n">rotatable_bonds</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bond_between</span><span class="p">(</span><span class="o">*</span><span class="n">bond</span><span class="p">)</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">general_bonds</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rotatable_bonds</span>

    <span class="k">def</span> <span class="nf">_add_atom</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atomic_number</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">formal_charge</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">is_aromatic</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">stereochemistry</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">invalidate_cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an atom</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atomic_number : int</span>
<span class="sd">            Atomic number of the atom</span>
<span class="sd">        formal_charge : int</span>
<span class="sd">            Formal charge of the atom</span>
<span class="sd">        is_aromatic : bool</span>
<span class="sd">            If True, atom is aromatic; if False, not aromatic</span>
<span class="sd">        stereochemistry : str, optional, default=None</span>
<span class="sd">            Either &#39;R&#39; or &#39;S&#39; for specified stereochemistry, or None if stereochemistry is irrelevant</span>
<span class="sd">        name : str, optional, default=None</span>
<span class="sd">            An optional name for the atom</span>
<span class="sd">        metadata : dict[str: (int, str)], default=None</span>
<span class="sd">            An optional dictionary where keys are strings and values are strings or ints. This is intended</span>
<span class="sd">            to record atom-level information used to inform hierarchy definition and iteration, such as</span>
<span class="sd">            grouping atom by residue and chain.</span>
<span class="sd">        invalidate_cache : bool, default=True</span>
<span class="sd">            Whether or not to invalidate the cache of the molecule upon the addition of this atom. This should</span>
<span class="sd">            be left to its default value (`True`) for safety.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the atom in the molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Define a methane molecule</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule()</span>
<span class="sd">        &gt;&gt;&gt; molecule.name = &#39;methane&#39;</span>
<span class="sd">        &gt;&gt;&gt; C = molecule.add_atom(6, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H1 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H2 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H3 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H4 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H1, False, 1)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H2, False, 1)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H3, False, 1)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H4, False, 1)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create an atom</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span>
            <span class="n">atomic_number</span><span class="p">,</span>
            <span class="n">formal_charge</span><span class="p">,</span>
            <span class="n">is_aromatic</span><span class="p">,</span>
            <span class="n">stereochemistry</span><span class="o">=</span><span class="n">stereochemistry</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">invalidate_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalidate_cached_properties</span><span class="p">()</span>

        <span class="c1"># Since we just appended it, we can just return the length - 1</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_add_bond</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atom1</span><span class="p">,</span>
        <span class="n">atom2</span><span class="p">,</span>
        <span class="n">bond_order</span><span class="p">,</span>
        <span class="n">is_aromatic</span><span class="p">,</span>
        <span class="n">stereochemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fractional_bond_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">invalidate_cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a bond between two specified atom indices</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom1 : int or openff.toolkit.topology.molecule.Atom</span>
<span class="sd">            Index of first atom or first atom</span>
<span class="sd">        atom2_index : int or openff.toolkit.topology.molecule.Atom</span>
<span class="sd">            Index of second atom or second atom</span>
<span class="sd">        bond_order : int</span>
<span class="sd">            Integral bond order of Kekulized form</span>
<span class="sd">        is_aromatic : bool</span>
<span class="sd">            True if this bond is aromatic, False otherwise</span>
<span class="sd">        stereochemistry : str, optional, default=None</span>
<span class="sd">            Either &#39;E&#39; or &#39;Z&#39; for specified stereochemistry, or None if stereochemistry is irrelevant</span>
<span class="sd">        fractional_bond_order : float, optional, default=None</span>
<span class="sd">            The fractional (eg. Wiberg) bond order</span>
<span class="sd">        invalidate_cache : bool, default=True</span>
<span class="sd">            Whether or not to invalidate the cache of the molecule upon the addition of this atom. This should</span>
<span class="sd">            be left to its default value (`True`) for safety.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the bond in the molecule</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom2</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">atom1_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom1</span><span class="p">]</span>
            <span class="n">atom2_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom2</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">atom1_atom</span> <span class="o">=</span> <span class="n">atom1</span>
            <span class="n">atom2_atom</span> <span class="o">=</span> <span class="n">atom2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Invalid inputs to molecule._add_bond. Expected ints or Atoms. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Received </span><span class="si">{</span><span class="n">atom1</span><span class="si">}</span><span class="s2"> (type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span><span class="si">}</span><span class="s2">) and </span><span class="si">{</span><span class="n">atom2</span><span class="si">}</span><span class="s2"> (type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span><span class="si">}</span><span class="s2">) &quot;</span>
            <span class="p">)</span>
        <span class="c1"># TODO: Check to make sure bond does not already exist</span>
        <span class="k">if</span> <span class="n">atom1_atom</span><span class="o">.</span><span class="n">is_bonded_to</span><span class="p">(</span><span class="n">atom2_atom</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">BondExistsError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Bond already exists between </span><span class="si">{</span><span class="n">atom1_atom</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">atom2_atom</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="n">bond</span> <span class="o">=</span> <span class="n">Bond</span><span class="p">(</span>
            <span class="n">atom1_atom</span><span class="p">,</span>
            <span class="n">atom2_atom</span><span class="p">,</span>
            <span class="n">bond_order</span><span class="p">,</span>
            <span class="n">is_aromatic</span><span class="p">,</span>
            <span class="n">stereochemistry</span><span class="o">=</span><span class="n">stereochemistry</span><span class="p">,</span>
            <span class="n">fractional_bond_order</span><span class="o">=</span><span class="n">fractional_bond_order</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">invalidate_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalidate_cached_properties</span><span class="p">()</span>

        <span class="c1"># Since we just appended it, we can just return the length - 1</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_add_conformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a conformation of the molecule</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates: openff.unit.Quantity(np.array) with shape (n_atoms, 3) and dimension of distance</span>
<span class="sd">            Coordinates of the new conformer, with the first dimension of the array corresponding to the atom index in</span>
<span class="sd">            the molecule&#39;s indexing system.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index: int</span>
<span class="sd">            The index of this conformer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InvalidConformerError</span><span class="p">(</span>
                <span class="s2">&quot;molecule.add_conformer given input of the wrong shape: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Given </span><span class="si">{</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, expected </span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">is_compatible_with</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">IncompatibleUnitError</span><span class="p">(</span>
                    <span class="s2">&quot;Coordinates passed to Molecule._add_conformer with incompatible units. &quot;</span>
                    <span class="s2">&quot;Ensure that units are dimension of length.&quot;</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">openff.units.openmm</span> <span class="kn">import</span> <span class="n">from_openmm</span>
            <span class="kn">from</span> <span class="nn">openmm</span> <span class="kn">import</span> <span class="n">unit</span> <span class="k">as</span> <span class="n">openmm_unit</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">openmm_unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">IncompatibleUnitError</span><span class="p">(</span>
                    <span class="s2">&quot;Unsupported type passed to Molecule._add_conformer setter. &quot;</span>
                    <span class="s2">&quot;Found object of type {type(other)}.&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">openmm_unit</span><span class="o">.</span><span class="n">meter</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">IncompatibleUnitError</span><span class="p">(</span>
                    <span class="s2">&quot;Coordinates passed to Molecule._add_conformer with units of incompatible dimensionality. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Adding conformers with OpenMM-style units is supported, by found units of </span><span class="si">{</span><span class="n">coordinates</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;Ensure that units are dimension of length.&quot;</span>
                <span class="p">)</span>

            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">from_openmm</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">IncompatibleUnitError</span><span class="p">(</span>
                <span class="s2">&quot;Unknown object passed to Molecule._add_conformer. Expected types include &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;openmm.unit.Quantity and openff.units.unit.Quantity, found type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="n">tmp_conf</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tmp_conf</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">coordinates</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO should we checking that the exact same conformer is not in the list already?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_conf</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">partial_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the partial charges (if present) on the molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        partial_charges : a openff.unit.Quantity - wrapped numpy array [1 x n_atoms] or None</span>
<span class="sd">            The partial charges on the molecule&#39;s atoms. Returns None if no charges have been specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span>

    <span class="nd">@partial_charges</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">partial_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">charges</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the atomic partial charges for this molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        charges : None or a openff.unit.Quantity - wrapped numpy array [1 x n_atoms]</span>
<span class="sd">            The partial charges to assign to the molecule. If not None, must be in units compatible with</span>
<span class="sd">            openff.unit.elementary_charge</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">charges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">charges</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">charges</span><span class="p">,</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">charges</span><span class="o">.</span><span class="n">units</span> <span class="ow">in</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="o">.</span><span class="n">compatible_units</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="o">=</span> <span class="n">charges</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">charges</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">openmm</span> <span class="kn">import</span> <span class="n">unit</span> <span class="k">as</span> <span class="n">openmm_unit</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">charges</span><span class="p">,</span> <span class="n">openmm_unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">IncompatibleUnitError</span><span class="p">(</span>
                        <span class="s2">&quot;Unsupported type passed to partial_charges setter. &quot;</span>
                        <span class="s2">&quot;Found object of type {type(charges)}.&quot;</span>
                    <span class="p">)</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">charges</span><span class="p">,</span> <span class="n">openmm_unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">openff.units.openmm</span> <span class="kn">import</span> <span class="n">from_openmm</span>

                    <span class="n">converted</span> <span class="o">=</span> <span class="n">from_openmm</span><span class="p">(</span><span class="n">charges</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">converted</span><span class="o">.</span><span class="n">units</span> <span class="ow">in</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="o">.</span><span class="n">compatible_units</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="o">=</span> <span class="n">converted</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_particles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. deprecated:: 0.11.0</span>
<span class="sd">            This property has been deprecated and will soon be removed. Use</span>
<span class="sd">            :meth:`Molecule.n_atoms` instead.</span>
<span class="sd">        ..</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_molecule_deprecation</span><span class="p">(</span><span class="s2">&quot;n_particles&quot;</span><span class="p">,</span> <span class="s2">&quot;n_atoms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of Atom objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of Bond objects in the molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of angles in the molecule.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_angles</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_propers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of proper torsions in the molecule.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_torsions</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_propers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;_construct_torsions always sets _propers to a set&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_propers</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of possible improper torsions in the molecule.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_torsions</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;_construct_torsions always sets _impropers to a set&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">particles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Atom</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. deprecated:: 0.11.0</span>
<span class="sd">            This property has been deprecated and will soon be removed. Use</span>
<span class="sd">            :meth:`Molecule.atoms` instead.</span>
<span class="sd">        ..</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_molecule_deprecation</span><span class="p">(</span><span class="s2">&quot;particles&quot;</span><span class="p">,</span> <span class="s2">&quot;atoms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>

    <span class="k">def</span> <span class="nf">particle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Atom</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. deprecated:: 0.11.0</span>
<span class="sd">            This method has been deprecated and will soon be removed. Use</span>
<span class="sd">            :meth:`Molecule.atom` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_molecule_deprecation</span><span class="p">(</span><span class="s2">&quot;particle&quot;</span><span class="p">,</span> <span class="s2">&quot;atom&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">particle_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. deprecated:: 0.11.0</span>
<span class="sd">            This method has been deprecated and will soon be removed. Use</span>
<span class="sd">            :meth:`Molecule.atom_index` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_molecule_deprecation</span><span class="p">(</span><span class="s2">&quot;particle_index&quot;</span><span class="p">,</span> <span class="s2">&quot;atom_index&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_index</span><span class="p">(</span><span class="n">particle</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all Atom objects in the molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span>

    <span class="k">def</span> <span class="nf">atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Atom</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the atom with the specified index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        atom : openff.toolkit.topology.Atom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">atom_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of the given atom in this molecule</span>

<span class="sd">        .. TODO: document behaviour when atom is not present in self</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : openff.toolkit.topology.Atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the given atom in this molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">atom</span><span class="o">.</span><span class="n">molecule_atom_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">conformers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of conformers for this molecule.</span>

<span class="sd">        Conformers are presented as a list of ``Quantity``-wrapped NumPy</span>
<span class="sd">        arrays, of shape (3 x n_atoms) and with dimensions of [Distance]. The</span>
<span class="sd">        return value is the actual list of conformers, and changes to the</span>
<span class="sd">        contents affect the original ``FrozenMolecule``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_conformers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of conformers for this molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Bond</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all Bond objects in the molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span>

    <span class="k">def</span> <span class="nf">bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bond</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the bond with the specified index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bond : openff.toolkit.topology.Bond</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an iterator over all i-j-k angles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_angles</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">torsions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an iterator over all i-j-k-l torsions.</span>
<span class="sd">        Note that i-j-k-i torsions (cycles) are excluded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torsions : iterable of 4-Atom tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_torsions</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_torsions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;_construct_torsions always sets _torsions to a set&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torsions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">propers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all proper torsions in the molecule</span>

<span class="sd">        .. todo::</span>

<span class="sd">           * Do we need to return a ``Torsion`` object that collects information about fractional bond orders?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_torsions</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_propers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;_construct_torsions always sets _propers to a set&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all improper torsions in the molecule.</span>

<span class="sd">        .. todo ::</span>
<span class="sd">           * Do we need to return a ``Torsion`` object that collects information about fractional bond orders?</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impropers : set of tuple</span>
<span class="sd">            An iterator of tuples, each containing the atoms making</span>
<span class="sd">            up a possible improper torsion.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        smirnoff_impropers, amber_impropers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_torsions</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;_construct_torsions always sets _impropers to a set&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">smirnoff_impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all impropers with trivalent centers, reporting the central atom second.</span>

<span class="sd">        The central atom is reported second in each torsion. This method reports</span>
<span class="sd">        an improper for each trivalent atom in the molecule, whether or not any</span>
<span class="sd">        given force field would assign it improper torsion parameters.</span>

<span class="sd">        Also note that this will return 6 possible atom orderings around each improper</span>
<span class="sd">        center. In current SMIRNOFF parameterization, three of these six</span>
<span class="sd">        orderings will be used for the actual assignment of the improper term</span>
<span class="sd">        and measurement of the angles. These three orderings capture the three unique</span>
<span class="sd">        angles that could be calculated around the improper center, therefore the sum</span>
<span class="sd">        of these three terms will always return a consistent energy.</span>

<span class="sd">        The exact three orderings that will be applied during parameterization can not be</span>
<span class="sd">        determined in this method, since it requires sorting the atom indices, and</span>
<span class="sd">        those indices may change when this molecule is added to a Topology.</span>

<span class="sd">        For more details on the use of three-fold (&#39;trefoil&#39;) impropers, see</span>
<span class="sd">        https://openforcefield.github.io/standards/standards/smirnoff/#impropertorsions</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impropers : set of tuple</span>
<span class="sd">            An iterator of tuples, each containing the indices of atoms making</span>
<span class="sd">            up a possible improper torsion. The central atom is listed second</span>
<span class="sd">            in each tuple.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        impropers, amber_impropers</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Replace with non-cheminformatics-toolkit method</span>
        <span class="c1">#       (ie. just looping over all atoms and finding ones that have 3 bonds?)</span>

        <span class="n">smirnoff_improper_smarts</span> <span class="o">=</span> <span class="s2">&quot;[*:1]~[X3:2](~[*:3])~[*:4]&quot;</span>
        <span class="n">improper_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_environment_matches</span><span class="p">(</span><span class="n">smirnoff_improper_smarts</span><span class="p">)</span>
        <span class="n">smirnoff_impropers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">imp</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">imp</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">imp</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">imp</span> <span class="ow">in</span> <span class="n">improper_idxs</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">smirnoff_impropers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">amber_impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all impropers with trivalent centers, reporting the central atom first.</span>

<span class="sd">        The central atom is reported first in each torsion. This method reports</span>
<span class="sd">        an improper for each trivalent atom in the molecule, whether or not any</span>
<span class="sd">        given force field would assign it improper torsion parameters.</span>

<span class="sd">        Also note that this will return 6 possible atom orderings around each</span>
<span class="sd">        improper center. In current AMBER parameterization, one of these six</span>
<span class="sd">        orderings will be used for the actual assignment of the improper term</span>
<span class="sd">        and measurement of the angle. This method does not encode the logic to</span>
<span class="sd">        determine which of the six orderings AMBER would use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impropers : set of tuple</span>
<span class="sd">            An iterator of tuples, each containing the indices of atoms making</span>
<span class="sd">            up a possible improper torsion. The central atom is listed first in</span>
<span class="sd">            each tuple.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        impropers, smirnoff_impropers</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Replace with non-cheminformatics-toolkit method</span>
        <span class="c1">#       (ie. just looping over all atoms and finding ones that have 3 bonds?)</span>
        <span class="n">amber_improper_smarts</span> <span class="o">=</span> <span class="s2">&quot;[X3:1](~[*:2])(~[*:3])~[*:4]&quot;</span>
        <span class="n">improper_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_environment_matches</span><span class="p">(</span><span class="n">amber_improper_smarts</span><span class="p">)</span>
        <span class="n">amber_impropers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">imp</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">imp</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">imp</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">imp</span> <span class="ow">in</span> <span class="n">improper_idxs</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">amber_impropers</span>

    <span class="k">def</span> <span class="nf">nth_degree_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_degrees</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return canonicalized pairs of atoms whose shortest separation is `exactly` n bonds.</span>
<span class="sd">        Only pairs with increasing atom indices are returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n: int</span>
<span class="sd">            The number of bonds separating atoms in each pair</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        neighbors: iterator of tuple of Atom</span>
<span class="sd">            Tuples (len 2) of atom that are separated by ``n`` bonds.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        The criteria used here relies on minimum distances; when there are multiple valid</span>
<span class="sd">        paths between atoms, such as atoms in rings, the shortest path is considered.</span>
<span class="sd">        For example, two atoms in &quot;meta&quot; positions with respect to each other in a benzene</span>
<span class="sd">        are separated by two paths, one length 2 bonds and the other length 4 bonds. This</span>
<span class="sd">        function would consider them to be 2 apart and would not include them if ``n=4`` was</span>
<span class="sd">        passed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_degrees</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot consider neighbors separated by 0 or fewer atoms. Asked to consider &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;path lengths of </span><span class="si">{</span><span class="n">n_degrees</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_nth_degree_neighbors_from_graphlike</span><span class="p">(</span>
                <span class="n">graphlike</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_degrees</span><span class="o">=</span><span class="n">n_degrees</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">total_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total charge on the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">charge_sum</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">charge_sum</span> <span class="o">+=</span> <span class="n">atom</span><span class="o">.</span><span class="n">formal_charge</span>
        <span class="k">return</span> <span class="n">charge_sum</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name (or title) of the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the name of this molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Molecule name must be a string&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The properties dictionary of the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hill_formula</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the Hill formula of the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_hill_formula</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_hill_formula</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the Hill formula of this molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        formula : the Hill formula of the molecule</span>

<span class="sd">        Raises</span>
<span class="sd">        -----------</span>
<span class="sd">        NotImplementedError : if the molecule is not of one of the specified types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hill_formula</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atom_nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">atomic_number</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hill_formula</span> <span class="o">=</span> <span class="n">_atom_nums_to_hill_formula</span><span class="p">(</span><span class="n">atom_nums</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hill_formula</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_object_to_hill_formula</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Molecule&quot;</span><span class="p">,</span> <span class="s2">&quot;nx.Graph&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Take a Molecule or NetworkX graph and generate its Hill formula.</span>
<span class="sd">        This provides a backdoor to the old functionality of Molecule.to_hill_formula, which</span>
<span class="sd">        was a static method that duck-typed inputs of Molecule or graph objects.&quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">FrozenMolecule</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">to_hill_formula</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_networkx_graph_to_hill_formula</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;_object_to_hill_formula accepts a NetworkX Graph or OpenFF &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;(Frozen)Molecule, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">chemical_environment_matches</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find matches in the molecule for a SMARTS string</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        query : str</span>
<span class="sd">            SMARTS string (with one or more tagged atoms).</span>
<span class="sd">        unique : bool, default=False</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry</span>
<span class="sd">            or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for chemical environment matches</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matches : list of atom index tuples</span>
<span class="sd">            A list of tuples, containing the indices of the matching atoms.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Retrieve all the carbon-carbon bond matches in a molecule</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;imatinib&#39;)</span>
<span class="sd">        &gt;&gt;&gt; matches = molecule.chemical_environment_matches(&#39;[#6X3:1]~[#6X3:2]&#39;)</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * Do we want to generalize ``query`` to allow other kinds of queries,</span>
<span class="sd">             such as mdtraj DSL, pymol selections, atom index slices, etc? We</span>
<span class="sd">             could call it ``topology.matches(query)`` instead of</span>
<span class="sd">             ``chemical_environment_matches``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">smirks</span> <span class="o">=</span> <span class="n">query</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;query&#39; must be a SMARTS/SMIRKS string&quot;</span><span class="p">)</span>

        <span class="c1"># Use specified cheminformatics toolkit to determine matches with specified aromaticity model</span>
        <span class="c1"># TODO: Simplify this by requiring a toolkit registry for the molecule?</span>
        <span class="c1"># TODO: Do we have to pass along an aromaticity model?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;find_smarts_matches&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">smirks</span><span class="p">,</span>
                <span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">find_smarts_matches</span><span class="p">(</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">smirks</span><span class="p">,</span>
                <span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;toolkit_registry&#39; must be either a ToolkitRegistry or a ToolkitWrapper&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">matches</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_iupac</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">iupac_name</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a molecule from IUPAC or common name</span>

<span class="sd">        .. note :: This method requires the OpenEye toolkit to be installed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iupac_name : str</span>
<span class="sd">            IUPAC name of molecule to be generated</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry</span>
<span class="sd">            or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for chemical environment matches</span>
<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If false, raises an exception if molecule contains undefined stereochemistry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : Molecule</span>
<span class="sd">            The resulting molecule with position</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a molecule from an IUPAC name</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;4-[(4-methylpiperazin-1-yl)methyl]-N-(4-methyl-3-{[4-(pyridin-3-yl)pyrimidin-2-yl]amino}phenyl)benzamide&#39;)  # noqa</span>

<span class="sd">        Create a molecule from a common name</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;imatinib&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;from_iupac&quot;</span><span class="p">,</span>
                <span class="n">iupac_name</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_iupac</span><span class="p">(</span>
                <span class="n">iupac_name</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to from_iupac. Expected ToolkitRegistry or ToolkitWrapper. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">molecule</span>

    <span class="k">def</span> <span class="nf">to_iupac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate IUPAC name from Molecule</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iupac_name : str</span>
<span class="sd">            IUPAC name of the molecule</span>

<span class="sd">        .. note :: This method requires the OpenEye toolkit to be installed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule(sdf_filepath)</span>
<span class="sd">        &gt;&gt;&gt; iupac_name = molecule.to_iupac()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">to_iupac_method</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="s2">&quot;to_iupac&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">to_iupac_method</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">to_iupac</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to to_iupac. Expected ToolkitRegistry or ToolkitWrapper. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># TODO: Can `to_iupac` fail if given a well-behaved OFFMol/OEMol?</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">to_iupac_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_topology</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">topology</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Molecule representation of an OpenFF Topology containing a single Molecule object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        topology : openff.toolkit.topology.Topology</span>
<span class="sd">            The :class:`Topology` object containing a single :class:`Molecule` object.</span>
<span class="sd">            Note that OpenMM and MDTraj ``Topology`` objects are not supported.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>
<span class="sd">            The Molecule object in the topology</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the topology does not contain exactly one molecule.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a molecule from a Topology object that contains exactly one molecule</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit import Molecule, Topology</span>
<span class="sd">        &gt;&gt;&gt; topology = Topology.from_molecules(Molecule.from_smiles(&#39;[CH4]&#39;))</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_topology(topology)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Ensure we are dealing with an OpenFF Topology object</span>
        <span class="k">if</span> <span class="n">topology</span><span class="o">.</span><span class="n">n_molecules</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Topology must contain exactly one molecule&quot;</span><span class="p">)</span>
        <span class="n">molecule</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">molecules</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an OpenFF Topology representation containing one copy of this molecule</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology : openff.toolkit.topology.Topology</span>
<span class="sd">            A Topology representation of this molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit import Molecule</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;imatinib&#39;)</span>
<span class="sd">        &gt;&gt;&gt; topology = molecule.to_topology()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openff.toolkit.topology</span> <span class="kn">import</span> <span class="n">Topology</span>

        <span class="k">return</span> <span class="n">Topology</span><span class="o">.</span><span class="n">from_molecules</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">file_path</span><span class="p">,</span>
        <span class="n">file_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create one or more molecules from a file</span>

<span class="sd">        .. todo::</span>

<span class="sd">           * Extend this to also include some form of .offmol Open Force Field Molecule format?</span>
<span class="sd">           * Generalize this to also include file-like objects?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path : str or file-like object</span>
<span class="sd">            The path to the file or file-like object to stream one or more molecules from.</span>
<span class="sd">        file_format : str, optional, default=None</span>
<span class="sd">            Format specifier, usually file suffix (eg. &#39;MOL2&#39;, &#39;SMI&#39;)</span>
<span class="sd">            Note that not all toolkits support all formats. Check ToolkitWrapper.toolkit_file_read_formats for your</span>
<span class="sd">            loaded toolkits for details.</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or</span>
<span class="sd">            openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for file loading. If a Toolkit is passed, only</span>
<span class="sd">            the highest-precedence toolkit is used</span>
<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If false, raises an exception if oemol contains undefined stereochemistry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecules : Molecule or list of Molecules</span>
<span class="sd">            If there is a single molecule in the file, a Molecule is returned;</span>
<span class="sd">            otherwise, a list of Molecule objects is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit import Molecule</span>
<span class="sd">        &gt;&gt;&gt; from openff.toolkit.utils.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; sdf_file_path = get_data_file_path(&quot;molecules/toluene.sdf&quot;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_file(sdf_file_path)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">file_format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">):</span>
                <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">file_path</span><span class="o">.</span><span class="n">as_posix</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;If providing a file-like object for reading molecules, the format must be specified&quot;</span>
                <span class="p">)</span>
            <span class="c1"># Assume that files ending in &quot;.gz&quot; should use their second-to-last suffix for compatibility check</span>
            <span class="c1"># TODO: Will all cheminformatics packages be OK with gzipped files?</span>
            <span class="k">if</span> <span class="n">file_path</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;.gz&quot;</span><span class="p">:</span>
                <span class="n">file_format</span> <span class="o">=</span> <span class="n">file_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">file_format</span> <span class="o">=</span> <span class="n">file_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">file_format</span> <span class="o">=</span> <span class="n">file_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;XYZ&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedFileTypeError</span><span class="p">(</span>
                <span class="s2">&quot;Parsing `.xyz` files is not currently supported because they lack sufficient &quot;</span>
                <span class="s2">&quot;chemical information to be used with SMIRNOFF force fields. For more information, &quot;</span>
                <span class="s2">&quot;see https://open-forcefield-toolkit.readthedocs.io/en/latest/faq.html or to provide &quot;</span>
                <span class="s2">&quot;feedback please visit https://github.com/openforcefield/openff-toolkit/issues/1145.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Determine which toolkit to use (highest priority that&#39;s compatible with input type)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="c1"># TODO: Encapsulate this logic into ToolkitRegistry.call()?</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">supported_read_formats</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">query_toolkit</span> <span class="ow">in</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">registered_toolkits</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">file_format</span> <span class="ow">in</span> <span class="n">query_toolkit</span><span class="o">.</span><span class="n">toolkit_file_read_formats</span><span class="p">:</span>
                    <span class="n">toolkit</span> <span class="o">=</span> <span class="n">query_toolkit</span>
                    <span class="k">break</span>
                <span class="n">supported_read_formats</span><span class="p">[</span>
                    <span class="n">query_toolkit</span><span class="o">.</span><span class="n">toolkit_name</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">query_toolkit</span><span class="o">.</span><span class="n">toolkit_file_read_formats</span>
            <span class="k">if</span> <span class="n">toolkit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No toolkits in registry can read file </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2"> (format </span><span class="si">{</span><span class="n">file_format</span><span class="si">}</span><span class="s2">). Supported &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;formats in the provided ToolkitRegistry are </span><span class="si">{</span><span class="n">supported_read_formats</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="p">)</span>
                <span class="c1"># Per issue #407, not allowing RDKit to read mol2 has confused a lot of people. Here we add text</span>
                <span class="c1"># to the error message that will hopefully reduce this confusion.</span>
                <span class="k">if</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;MOL2&quot;</span> <span class="ow">and</span> <span class="n">RDKitToolkitWrapper</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="s2">&quot;RDKit does not fully support input of molecules from mol2 format unless they &quot;</span>
                        <span class="s2">&quot;have Corina atom types, and this is not common in the simulation community. For this &quot;</span>
                        <span class="s2">&quot;reason, the Open Force Field Toolkit does not use &quot;</span>
                        <span class="s2">&quot;RDKit to read .mol2. Consider reading from SDF instead. If you would like to attempt &quot;</span>
                        <span class="s2">&quot;to use RDKit to read mol2 anyway, you can load the molecule of interest into an RDKit &quot;</span>
                        <span class="s2">&quot;molecule and use openff.toolkit.topology.Molecule.from_rdkit, but we do not recommend this.&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;PDB&quot;</span> <span class="ow">and</span> <span class="n">RDKitToolkitWrapper</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="s2">&quot;RDKit can not safely read PDBs on their own. Information about bond order and aromaticity &quot;</span>
                        <span class="s2">&quot;is likely to be lost. PDBs can be used along with a valid smiles string with RDKit using &quot;</span>
                        <span class="s2">&quot;the constructor Molecule.from_pdb_and_smiles(file_path, smiles)&quot;</span>
                    <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="c1"># TODO: Encapsulate this logic in ToolkitWrapper?</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="k">if</span> <span class="n">file_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">toolkit_file_read_formats</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Toolkit </span><span class="si">{</span><span class="n">toolkit</span><span class="o">.</span><span class="n">toolkit_name</span><span class="si">}</span><span class="s2"> can not read file </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2"> (format </span><span class="si">{</span><span class="n">file_format</span><span class="si">}</span><span class="s2">). Supported &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;formats for this toolkit are </span><span class="si">{</span><span class="n">toolkit</span><span class="o">.</span><span class="n">toolkit_file_read_formats</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">toolkit_name</span> <span class="o">==</span> <span class="s2">&quot;The RDKit&quot;</span> <span class="ow">and</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;PDB&quot;</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="s2">&quot;RDKit can however read PDBs with a valid smiles string using the &quot;</span>
                        <span class="s2">&quot;Molecule.from_pdb_and_smiles(file_path, smiles) constructor&quot;</span>
                    <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;toolkit_registry&#39; must be either a ToolkitRegistry or a ToolkitWrapper&quot;</span>
            <span class="p">)</span>

        <span class="n">mols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">mols</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span>
                <span class="n">file_path</span><span class="p">,</span>
                <span class="n">file_format</span><span class="o">=</span><span class="n">file_format</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;read&quot;</span><span class="p">):</span>
            <span class="n">file_obj</span> <span class="o">=</span> <span class="n">file_path</span>
            <span class="n">mols</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_file_obj</span><span class="p">(</span>
                <span class="n">file_obj</span><span class="p">,</span>
                <span class="n">file_format</span><span class="o">=</span><span class="n">file_format</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to read molecule from file: </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">mols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">mols</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@requires_package</span><span class="p">(</span><span class="s2">&quot;openmm&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">from_polymer_pdb</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">file_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TextIO</span><span class="p">],</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads a polymer from a PDB file.</span>

<span class="sd">        Currently only supports proteins with canonical amino acids that are</span>
<span class="sd">        either uncapped or capped by ACE/NME groups, but may later be extended</span>
<span class="sd">        to handle other common polymers, or accept user-defined polymer</span>
<span class="sd">        templates. Only one polymer chain may be present in the PDB file, and it</span>
<span class="sd">        must be the only molecule present.</span>

<span class="sd">        Connectivity and bond orders are assigned by matching SMARTS codes for</span>
<span class="sd">        the supported residues against atom names. The PDB file must include</span>
<span class="sd">        all atoms with the correct standard atom names described in the</span>
<span class="sd">        `PDB Chemical Component Dictionary &lt;https://www.wwpdb.org/data/ccd&gt;`_.</span>
<span class="sd">        Residue names are used to assist trouble-shooting failed assignments,</span>
<span class="sd">        but are not used in the actual assignment process.</span>

<span class="sd">        Metadata such as residues, chains, and atom names are recorded in the</span>
<span class="sd">        ``Atom.metadata`` attribute, which is a dictionary mapping from</span>
<span class="sd">        strings like &quot;residue_name&quot; to the appropriate value. ``from_polymer_pdb``</span>
<span class="sd">        returns a molecule that can be iterated over with the ``.residues`` and</span>
<span class="sd">        ``.chains`` attributes, as well as the usual ``.atoms``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path : str or file object</span>
<span class="sd">            PDB information to be passed to OpenMM PDBFile object for loading</span>
<span class="sd">        toolkit_registry = ToolkitWrapper or ToolkitRegistry. Default = None</span>
<span class="sd">            Either a ToolkitRegistry, ToolkitWrapper</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>

<span class="sd">        UnassignedChemistryInPDBError</span>
<span class="sd">            If an atom or bond could not be assigned; the exception will</span>
<span class="sd">            provide a detailed diagnostic of what went wrong.</span>

<span class="sd">        MultipleMoleculesInPDBError</span>
<span class="sd">            If all atoms and bonds could be assigned, but the PDB includes</span>
<span class="sd">            multiple chains or molecules.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">openmm.unit</span> <span class="k">as</span> <span class="nn">openmm_unit</span>
        <span class="kn">from</span> <span class="nn">openmm.app</span> <span class="kn">import</span> <span class="n">PDBFile</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit_registry</span> <span class="o">=</span> <span class="n">ToolkitRegistry</span><span class="p">([</span><span class="n">toolkit_registry</span><span class="p">])</span>

        <span class="n">pdb</span> <span class="o">=</span> <span class="n">PDBFile</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>

        <span class="n">substructure_file_path</span> <span class="o">=</span> <span class="n">get_data_file_path</span><span class="p">(</span>
            <span class="s2">&quot;proteins/aa_residues_substructures_explicit_bond_orders_with_caps.json&quot;</span>
        <span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">substructure_file_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">subfile</span><span class="p">:</span>
            <span class="n">substructure_dictionary</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">subfile</span><span class="p">)</span>

        <span class="n">offmol</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
            <span class="s2">&quot;_polymer_openmm_topology_to_offmol&quot;</span><span class="p">,</span> <span class="n">pdb</span><span class="o">.</span><span class="n">topology</span><span class="p">,</span> <span class="n">substructure_dictionary</span>
        <span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">[</span><span class="o">*</span><span class="n">vec3</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">openmm_unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="n">vec3</span> <span class="ow">in</span> <span class="n">pdb</span><span class="o">.</span><span class="n">getPositions</span><span class="p">()</span>
                <span class="p">]</span>
            <span class="p">),</span>
            <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">offmol</span><span class="o">.</span><span class="n">add_conformer</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">offmol</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;_assign_aromaticity_and_stereo_from_3d&quot;</span><span class="p">,</span> <span class="n">offmol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">atoms</span><span class="p">()):</span>
            <span class="n">offmol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span>
            <span class="n">offmol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;residue_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span>
            <span class="n">offmol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;residue_number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">id</span>
            <span class="n">offmol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;insertion_code&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">insertionCode</span>
            <span class="n">offmol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;chain_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">id</span>
        <span class="n">offmol</span><span class="o">.</span><span class="n">add_default_hierarchy_schemes</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">offmol</span><span class="o">.</span><span class="n">_has_multiple_molecules</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">MultipleMoleculesInPDBError</span><span class="p">(</span>
                <span class="s2">&quot;This PDB has multiple molecules. The OpenFF Toolkit requires &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;that only one molecule is present in a PDB. Try splitting &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;each molecule into its own PDB with another tool, and &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;load any small molecules with Molecule.from_pdb_and_smiles.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">offmol</span>

    <span class="k">def</span> <span class="nf">_has_multiple_molecules</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>
        <span class="n">num_disconnected_subgraphs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">num_disconnected_subgraphs</span> <span class="o">&gt;</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_to_xyz_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the current molecule and its conformers to a multiframe xyz file, if the molecule</span>
<span class="sd">        has no current coordinates all atoms will be set to 0,0,0 in keeping with the behaviour of the</span>
<span class="sd">        backend toolkits.</span>

<span class="sd">        Information on the type of XYZ file written can be found here &lt;http://openbabel.org/wiki/XYZ_(format)&gt;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path : str or file-like object</span>
<span class="sd">            A file-like object or the path to the file to be written.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If we do not have a conformer make one with all zeros</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_conformers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">conformers</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">conformers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conformers</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conformers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">frame</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">hill_formula</span><span class="si">}{</span><span class="n">frame</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">frame</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">hill_formula</span><span class="si">}</span><span class="s1"> Frame </span><span class="si">{</span><span class="n">frame</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="c1"># check if we have a file path or an open file object</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">xyz_data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xyz_data</span> <span class="o">=</span> <span class="n">file_path</span>

        <span class="c1"># add the data to the xyz_data list</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">geometry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conformers</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">xyz_data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">title</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">atom_coords</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">atom_coords</span>
                <span class="n">xyz_data</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">SYMBOLS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">]</span><span class="si">}</span><span class="s2">       </span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2"> .10f</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">y</span><span class="si">:</span><span class="s2"> .10f</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">z</span><span class="si">:</span><span class="s2"> .10f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="c1"># now we up the frame count</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># now close the file</span>
        <span class="n">xyz_data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">file_format</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the current molecule to a file or file-like object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path : str or file-like object</span>
<span class="sd">            A file-like object or the path to the file to be written.</span>
<span class="sd">        file_format : str</span>
<span class="sd">            Format specifier, one of [&#39;MOL2&#39;, &#39;MOL2H&#39;, &#39;SDF&#39;, &#39;PDB&#39;, &#39;SMI&#39;, &#39;CAN&#39;, &#39;TDT&#39;]</span>
<span class="sd">            Note that not all toolkits support all formats</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry</span>
<span class="sd">            or openff.toolkit.utils.toolkits.ToolkitWrapper, optional, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for file writing. If a Toolkit is passed,</span>
<span class="sd">            only the highest-precedence toolkit is used</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the requested file_format is not supported by one of the installed cheminformatics toolkits</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;imatinib&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule.to_file(&#39;imatinib.mol2&#39;, file_format=&#39;mol2&#39;)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; molecule.to_file(&#39;imatinib.sdf&#39;, file_format=&#39;sdf&#39;)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; molecule.to_file(&#39;imatinib.pdb&#39;, file_format=&#39;pdb&#39;)  # doctest: +SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="n">toolkit_registry</span> <span class="o">=</span> <span class="n">ToolkitRegistry</span><span class="p">(</span><span class="n">toolkit_precedence</span><span class="o">=</span><span class="p">[])</span>
            <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">add_toolkit</span><span class="p">(</span><span class="n">toolkit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;toolkit_registry&#39; must be either a ToolkitRegistry or a ToolkitWrapper&quot;</span>
            <span class="p">)</span>

        <span class="n">file_format</span> <span class="o">=</span> <span class="n">file_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="c1"># check if xyz, use the toolkit independent method.</span>
        <span class="k">if</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;XYZ&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_xyz_file</span><span class="p">(</span><span class="n">file_path</span><span class="o">=</span><span class="n">file_path</span><span class="p">)</span>

        <span class="c1"># Take the first toolkit that can write the desired output format</span>
        <span class="n">toolkit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">query_toolkit</span> <span class="ow">in</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">registered_toolkits</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">file_format</span> <span class="ow">in</span> <span class="n">query_toolkit</span><span class="o">.</span><span class="n">toolkit_file_write_formats</span><span class="p">:</span>
                <span class="n">toolkit</span> <span class="o">=</span> <span class="n">query_toolkit</span>
                <span class="k">break</span>

        <span class="c1"># Raise an exception if no toolkit was found to provide the requested file_format</span>
        <span class="k">if</span> <span class="n">toolkit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">supported_formats</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">toolkit</span> <span class="ow">in</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">registered_toolkits</span><span class="p">:</span>
                <span class="n">supported_formats</span><span class="p">[</span>
                    <span class="n">toolkit</span><span class="o">.</span><span class="n">toolkit_name</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">toolkit_file_write_formats</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The requested file format (</span><span class="si">{</span><span class="n">file_format</span><span class="si">}</span><span class="s2">) is not available from any of the installed toolkits &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(supported formats: </span><span class="si">{</span><span class="n">supported_formats</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Write file</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1"># Open file for writing</span>
            <span class="n">toolkit</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">file_format</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">toolkit</span><span class="o">.</span><span class="n">to_file_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">file_format</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">enumerate_tautomers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">max_states</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enumerate the possible tautomers of the current molecule</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_states: int optional, default=20</span>
<span class="sd">            The maximum amount of molecules that should be returned</span>

<span class="sd">        toolkit_registry: openff.toolkit.utils.toolkits.ToolkitRegistry</span>
<span class="sd">            or openff.toolkit.utils.toolkits.ToolkitWrapper, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use to enumerate the tautomers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecules: List[openff.toolkit.topology.Molecule]</span>
<span class="sd">            A list of openff.toolkit.topology.Molecule instances not including the input molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">molecules</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;enumerate_tautomers&quot;</span><span class="p">,</span> <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_states</span><span class="o">=</span><span class="n">max_states</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">molecules</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">enumerate_tautomers</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">max_states</span><span class="o">=</span><span class="n">max_states</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;toolkit_registry&#39; must be either a ToolkitRegistry or a ToolkitWrapper&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">molecules</span>

    <span class="k">def</span> <span class="nf">enumerate_stereoisomers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">undefined_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_isomers</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">rationalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enumerate the stereocenters and bonds of the current molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        undefined_only: bool optional, default=False</span>
<span class="sd">            If we should enumerate all stereocenters and bonds or only those with undefined stereochemistry</span>

<span class="sd">        max_isomers: int optional, default=20</span>
<span class="sd">            The maximum amount of molecules that should be returned</span>

<span class="sd">        rationalise: bool optional, default=True</span>
<span class="sd">            If we should try to build and rationalise the molecule to ensure it can exist</span>

<span class="sd">        toolkit_registry: openff.toolkit.utils.toolkits.ToolkitRegistry or</span>
<span class="sd">            lopenff.toolkit.utils.toolkits.ToolkitWrapper, default=GLOBAL_TOOLKIT_REGISTRY</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use to enumerate the stereoisomers.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        molecules: List[openff.toolkit.topology.Molecule]</span>
<span class="sd">            A list of :class:`Molecule` instances not including the input molecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="n">molecules</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;enumerate_stereoisomers&quot;</span><span class="p">,</span>
                <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">undefined_only</span><span class="o">=</span><span class="n">undefined_only</span><span class="p">,</span>
                <span class="n">max_isomers</span><span class="o">=</span><span class="n">max_isomers</span><span class="p">,</span>
                <span class="n">rationalise</span><span class="o">=</span><span class="n">rationalise</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">molecules</span> <span class="o">=</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">enumerate_stereoisomers</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">undefined_only</span><span class="o">=</span><span class="n">undefined_only</span><span class="p">,</span>
                <span class="n">max_isomers</span><span class="o">=</span><span class="n">max_isomers</span><span class="p">,</span>
                <span class="n">rationalise</span><span class="o">=</span><span class="n">rationalise</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;toolkit_registry&#39; must be either a ToolkitRegistry or a ToolkitWrapper&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">molecules</span>

    <span class="nd">@OpenEyeToolkitWrapper</span><span class="o">.</span><span class="n">requires_toolkit</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">enumerate_protomers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_states</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enumerate the formal charges of a molecule to generate different protomoers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_states: int optional, default=10,</span>
<span class="sd">            The maximum number of protomer states to be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecules: List[openff.toolkit.topology.Molecule],</span>
<span class="sd">            A list of the protomers of the input molecules not including the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">toolkit</span> <span class="o">=</span> <span class="n">OpenEyeToolkitWrapper</span><span class="p">()</span>
        <span class="n">molecules</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">enumerate_protomers</span><span class="p">(</span><span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_states</span><span class="o">=</span><span class="n">max_states</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">molecules</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@RDKitToolkitWrapper</span><span class="o">.</span><span class="n">requires_toolkit</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">from_rdkit</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">rdmol</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Molecule from an RDKit molecule.</span>

<span class="sd">        Requires the RDKit to be installed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rdmol : rkit.RDMol</span>
<span class="sd">            An RDKit molecule</span>
<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If ``False``, raises an exception if ``rdmol`` contains undefined stereochemistry.</span>
<span class="sd">        hydrogens_are_explicit : bool, default=False</span>
<span class="sd">            If ``False``, RDKit will perform hydrogen addition using ``Chem.AddHs``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>
<span class="sd">            An OpenFF molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a molecule from an RDKit molecule</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit import Molecule</span>
<span class="sd">        &gt;&gt;&gt; from rdkit import Chem</span>
<span class="sd">        &gt;&gt;&gt; rdmol = Chem.MolFromSmiles(&quot;CCO&quot;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_rdkit(rdmol)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">toolkit</span> <span class="o">=</span> <span class="n">RDKitToolkitWrapper</span><span class="p">()</span>
        <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span>
            <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
            <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="n">hydrogens_are_explicit</span><span class="p">,</span>
            <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">molecule</span>

    <span class="k">def</span> <span class="nf">to_rdkit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">aromaticity_model</span><span class="o">=</span><span class="n">DEFAULT_AROMATICITY_MODEL</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an RDKit molecule</span>

<span class="sd">        Requires the RDKit to be installed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        aromaticity_model : str, optional, default=&quot;OEAroModel_MDL&quot;</span>
<span class="sd">            The aromaticity model to use. Only OEAroModel_MDL is supported.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rdmol : rdkit.RDMol</span>
<span class="sd">            An RDKit molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Convert a molecule to RDKit</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule(sdf_filepath)</span>
<span class="sd">        &gt;&gt;&gt; rdmol = molecule.to_rdkit()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># toolkit = RDKitToolkitWrapper()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aromaticity_model</span><span class="o">=</span><span class="n">aromaticity_model</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;to_rdkit&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aromaticity_model</span><span class="o">=</span><span class="n">aromaticity_model</span>
            <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@OpenEyeToolkitWrapper</span><span class="o">.</span><span class="n">requires_toolkit</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">from_openeye</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">oemol</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a ``Molecule`` from an OpenEye molecule.</span>

<span class="sd">        Requires the OpenEye toolkit to be installed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        oemol : openeye.oechem.OEMol</span>
<span class="sd">            An OpenEye molecule</span>
<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If ``False``, raises an exception if oemol contains undefined stereochemistry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>
<span class="sd">            An OpenFF molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a ``Molecule`` from an OpenEye OEMol</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit import Molecule</span>
<span class="sd">        &gt;&gt;&gt; from openeye import oechem</span>
<span class="sd">        &gt;&gt;&gt; oemol = oechem.OEMol()</span>
<span class="sd">        &gt;&gt;&gt; oechem.OESmilesToMol(oemol, &#39;[H]C([H])([H])C([H])([H])O[H]&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_openeye(oemol)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">toolkit</span> <span class="o">=</span> <span class="n">OpenEyeToolkitWrapper</span><span class="p">()</span>
        <span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_openeye</span><span class="p">(</span>
            <span class="n">oemol</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span> <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">molecule</span>

    <span class="nd">@requires_package</span><span class="p">(</span><span class="s2">&quot;qcelemental&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_qcschema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplicity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">extras</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a QCElemental Molecule.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        multiplicity : int, default=1,</span>
<span class="sd">            The multiplicity of the molecule;</span>
<span class="sd">            sets ``molecular_multiplicity`` field for QCElemental Molecule.</span>

<span class="sd">        conformer : int, default=0,</span>
<span class="sd">            The index of the conformer to use for the QCElemental Molecule geometry.</span>

<span class="sd">        extras : dict, default=None</span>
<span class="sd">            A dictionary that should be included in the ``extras`` field on the QCElemental Molecule.</span>
<span class="sd">            This can be used to include extra information, such as a smiles representation.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------</span>
<span class="sd">        qcelemental.models.Molecule</span>
<span class="sd">            A validated QCElemental Molecule.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a QCElemental Molecule:</span>

<span class="sd">        &gt;&gt;&gt; import qcelemental as qcel</span>
<span class="sd">        &gt;&gt;&gt; mol = Molecule.from_smiles(&#39;CC&#39;)</span>
<span class="sd">        &gt;&gt;&gt; mol.generate_conformers(n_conformers=1)</span>
<span class="sd">        &gt;&gt;&gt; qcemol = mol.to_qcschema()</span>

<span class="sd">        Raises</span>
<span class="sd">        --------</span>
<span class="sd">        MissingOptionalDependencyError</span>
<span class="sd">            If qcelemental is not installed, the qcschema can not be validated.</span>
<span class="sd">        InvalidConformerError</span>
<span class="sd">            No conformer found at the given index.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">qcelemental</span> <span class="k">as</span> <span class="nn">qcel</span>

        <span class="c1"># get/ check the geometry</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformers</span><span class="p">[</span><span class="n">conformer</span><span class="p">]</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">bohr</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InvalidConformerError</span><span class="p">(</span>
                <span class="s2">&quot;The molecule must have a conformation to produce a valid qcschema; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;no conformer was found at index </span><span class="si">{</span><span class="n">conformer</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Gather the required qcschema data</span>
        <span class="n">charge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_charge</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="p">)</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1_index</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom2_index</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">bond_order</span><span class="p">)</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span>
        <span class="p">]</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">SYMBOLS</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">]</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">extras</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extras</span><span class="p">[</span>
                <span class="s2">&quot;canonical_isomeric_explicit_hydrogen_mapped_smiles&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_smiles</span><span class="p">(</span><span class="n">mapped</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extras</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;canonical_isomeric_explicit_hydrogen_mapped_smiles&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_smiles</span><span class="p">(</span>
                    <span class="n">mapped</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="p">}</span>

        <span class="n">schema_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;symbols&quot;</span><span class="p">:</span> <span class="n">symbols</span><span class="p">,</span>
            <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">geometry</span><span class="p">,</span>
            <span class="c1"># If we have no bonds we must supply None</span>
            <span class="s2">&quot;connectivity&quot;</span><span class="p">:</span> <span class="n">connectivity</span> <span class="k">if</span> <span class="n">connectivity</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;molecular_charge&quot;</span><span class="p">:</span> <span class="n">charge</span><span class="p">,</span>
            <span class="s2">&quot;molecular_multiplicity&quot;</span><span class="p">:</span> <span class="n">multiplicity</span><span class="p">,</span>
            <span class="s2">&quot;extras&quot;</span><span class="p">:</span> <span class="n">extras</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">qcel</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="n">schema_dict</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_mapped_smiles</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">mapped_smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">ToolkitRegistry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a ``Molecule`` from a SMILES string, ordering atoms from mappings</span>

<span class="sd">        SMILES strings support mapping integer indices to each atom by ending a</span>
<span class="sd">        bracketed atom declaration with a colon followed by a 1-indexed</span>
<span class="sd">        integer:</span>

<span class="sd">        .. code:</span>
<span class="sd">            &quot;[H:3][C:1](=[O:2])[H:4]&quot;</span>

<span class="sd">        This method creates a ``Molecule`` from such a SMILES string whose atoms</span>
<span class="sd">        are ordered according to the mapping. Each atom must be mapped exactly</span>
<span class="sd">        once; any duplicate, missing, or out-of-range mappings will cause the</span>
<span class="sd">        method to fail.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapped_smiles: str</span>
<span class="sd">            A mapped SMILES string with explicit hydrogens.</span>
<span class="sd">        toolkit_registry</span>
<span class="sd">            Cheminformatics toolkit to use for SMILES-to-molecule conversion</span>
<span class="sd">        allow_undefined_stereo</span>
<span class="sd">            If false, raise an exception if the SMILES contains undefined</span>
<span class="sd">            stereochemistry.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        offmol</span>
<span class="sd">            An OpenFF molecule instance.</span>

<span class="sd">        Raises</span>
<span class="sd">        --------</span>
<span class="sd">        SmilesParsingError</span>
<span class="sd">            If the given SMILES had no indexing picked up by the toolkits, or if</span>
<span class="sd">            the indexing is missing indices.</span>
<span class="sd">        RemapIndexError</span>
<span class="sd">            If the mapping has duplicate or out-of-range indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a mapped chlorofluoroiodomethane molecule and check the atoms</span>
<span class="sd">        are placed accordingly:</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_mapped_smiles(</span>
<span class="sd">        ...     &quot;[Cl:2][C@:1]([F:3])([I:4])[H:5]&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; assert molecule.atom(0).symbol == &quot;C&quot;</span>
<span class="sd">        &gt;&gt;&gt; assert molecule.atom(1).symbol == &quot;Cl&quot;</span>
<span class="sd">        &gt;&gt;&gt; assert molecule.atom(2).symbol == &quot;F&quot;</span>
<span class="sd">        &gt;&gt;&gt; assert molecule.atom(3).symbol == &quot;I&quot;</span>
<span class="sd">        &gt;&gt;&gt; assert molecule.atom(4).symbol == &quot;H&quot;</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_smiles, remap</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create the molecule from the smiles and check we have the right number of indexes</span>
        <span class="c1"># in the mapped SMILES</span>
        <span class="n">offmol</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_smiles</span><span class="p">(</span>
            <span class="n">mapped_smiles</span><span class="p">,</span>
            <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span><span class="p">,</span>
            <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># check we found some mapping and remove it as we do not want to expose atom maps</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">offmol</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;atom_map&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SmilesParsingError</span><span class="p">(</span>
                <span class="s2">&quot;The given SMILES has no indexing, please generate a valid explicit hydrogen &quot;</span>
                <span class="s2">&quot;mapped SMILES using cmiles.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="o">!=</span> <span class="n">offmol</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SmilesParsingError</span><span class="p">(</span>
                <span class="s2">&quot;The mapped smiles does not contain enough indexes to remap the molecule.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># remap the molecule using the atom map found in the smiles</span>
        <span class="c1"># the order is mapping = Dict[current_index: new_index]</span>
        <span class="c1"># first renumber the mapping dict indexed from 0, currently from 1 as 0 indicates no mapping in toolkits</span>
        <span class="n">adjusted_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">current</span><span class="p">,</span> <span class="n">new</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">current</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">offmol</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="n">adjusted_mapping</span><span class="p">,</span> <span class="n">current_to_new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@requires_package</span><span class="p">(</span><span class="s2">&quot;qcelemental&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">from_qcschema</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">qca_record</span><span class="p">,</span>
        <span class="n">client</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Molecule from a QCArchive molecule record or dataset entry</span>
<span class="sd">        based on attached cmiles information.</span>

<span class="sd">        For a molecule record, a conformer will be set from its geometry.</span>

<span class="sd">        For a dataset entry, if a corresponding client instance is provided,</span>
<span class="sd">        the starting geometry for that entry will be used as a conformer.</span>

<span class="sd">        A QCElemental Molecule produced from ``Molecule.to_qcschema`` can be round-tripped</span>
<span class="sd">        through this method to produce a new, valid Molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qca_record : dict</span>
<span class="sd">            A QCArchive molecule record or dataset entry.</span>

<span class="sd">        client : optional, default=None,</span>
<span class="sd">            A qcportal.FractalClient instance to use for fetching an initial geometry.</span>
<span class="sd">            Only used if ``qca_record`` is a dataset entry.</span>

<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or</span>
<span class="sd">            openff.toolkit.utils.toolkits.ToolkitWrapper, optional</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for SMILES-to-molecule conversion</span>

<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If false, raises an exception if qca_record contains undefined stereochemistry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>
<span class="sd">            An OpenFF molecule instance.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Get Molecule from a QCArchive molecule record:</span>

<span class="sd">        &gt;&gt;&gt; from qcportal import FractalClient</span>
<span class="sd">        &gt;&gt;&gt; client = FractalClient()</span>
<span class="sd">        &gt;&gt;&gt; offmol = Molecule.from_qcschema(</span>
<span class="sd">        ...     client.query_molecules(molecular_formula=&quot;C16H20N3O5&quot;)[0]</span>
<span class="sd">        ... )</span>

<span class="sd">        Get Molecule from a QCArchive optimization entry:</span>

<span class="sd">        &gt;&gt;&gt; from qcportal import FractalClient</span>
<span class="sd">        &gt;&gt;&gt; client = FractalClient()</span>
<span class="sd">        &gt;&gt;&gt; optds = client.get_collection(</span>
<span class="sd">        ...     &quot;OptimizationDataset&quot;,</span>
<span class="sd">        ...     &quot;SMIRNOFF Coverage Set 1&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; offmol = Molecule.from_qcschema(optds.get_entry(&#39;coc(o)oc-0&#39;))</span>

<span class="sd">        Same as above, but with conformer(s) from initial molecule(s) by</span>
<span class="sd">        providing client to database:</span>

<span class="sd">        &gt;&gt;&gt; offmol = Molecule.from_qcschema(</span>
<span class="sd">        ...     optds.get_entry(&#39;coc(o)oc-0&#39;),</span>
<span class="sd">        ...     client=client</span>
<span class="sd">        ... )</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If the record dict can not be made from ``qca_record``, or if the</span>
<span class="sd">            provided ``client`` could not retrieve the initial molecule.</span>
<span class="sd">        KeyError</span>
<span class="sd">            If the record does not contain the</span>
<span class="sd">            ``canonical_isomeric_explicit_hydrogen_mapped_smiles``.</span>
<span class="sd">        InvalidConformerError</span>
<span class="sd">            Silent error, if the conformer could not be attached.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We can accept the Dataset entry record or the dict with JSON encoding</span>
        <span class="c1"># lets get it all in the dict rep</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qca_record</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">qca_record</span> <span class="o">=</span> <span class="n">qca_record</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;json&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="s2">&quot;The object passed could not be converted to a dict with json encoding&quot;</span>
                <span class="p">)</span>

        <span class="c1"># identify if this is a dataset entry</span>
        <span class="k">if</span> <span class="s2">&quot;attributes&quot;</span> <span class="ow">in</span> <span class="n">qca_record</span><span class="p">:</span>
            <span class="n">mapped_smiles</span> <span class="o">=</span> <span class="n">qca_record</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">][</span>
                <span class="s2">&quot;canonical_isomeric_explicit_hydrogen_mapped_smiles&quot;</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">client</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># try and find the initial molecule conformations and attach them</span>
                <span class="c1"># collect the input molecules</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">input_mols</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">query_molecules</span><span class="p">(</span>
                        <span class="nb">id</span><span class="o">=</span><span class="n">qca_record</span><span class="p">[</span><span class="s2">&quot;initial_molecules&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># this must be an optimisation record</span>
                    <span class="n">input_mols</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">query_molecules</span><span class="p">(</span>
                        <span class="nb">id</span><span class="o">=</span><span class="n">qca_record</span><span class="p">[</span><span class="s2">&quot;initial_molecule&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="s2">&quot;The provided client can not query molecules, make sure it is an instance of&quot;</span>
                        <span class="s2">&quot;qcportal.client.FractalClient() with the correct address.&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">input_mols</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># identify if this is a molecule record</span>
        <span class="k">elif</span> <span class="s2">&quot;extras&quot;</span> <span class="ow">in</span> <span class="n">qca_record</span><span class="p">:</span>
            <span class="n">mapped_smiles</span> <span class="o">=</span> <span class="n">qca_record</span><span class="p">[</span><span class="s2">&quot;extras&quot;</span><span class="p">][</span>
                <span class="s2">&quot;canonical_isomeric_explicit_hydrogen_mapped_smiles&quot;</span>
            <span class="p">]</span>
            <span class="n">input_mols</span> <span class="o">=</span> <span class="p">[</span><span class="n">qca_record</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;The record must contain the hydrogen mapped smiles to be safely made from the archive. &quot;</span>
                <span class="s2">&quot;It is not present in either &#39;attributes&#39; or &#39;extras&#39; on the provided `qca_record`&quot;</span>
            <span class="p">)</span>

        <span class="c1"># make a new molecule that has been reordered to match the cmiles mapping</span>
        <span class="n">offmol</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_mapped_smiles</span><span class="p">(</span>
            <span class="n">mapped_smiles</span><span class="p">,</span>
            <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">toolkit_registry</span><span class="p">,</span>
            <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># now for each molecule convert and attach the input geometry</span>
        <span class="n">initial_ids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">molecule</span> <span class="ow">in</span> <span class="n">input_mols</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">mol</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;json&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mol</span> <span class="o">=</span> <span class="n">molecule</span>

            <span class="n">geometry</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mol</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">unit</span><span class="o">.</span><span class="n">bohr</span>
            <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">offmol</span><span class="o">.</span><span class="n">_add_conformer</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">))</span>
                <span class="c1"># in case this molecule didn&#39;t come from a server at all</span>
                <span class="k">if</span> <span class="s2">&quot;id&quot;</span> <span class="ow">in</span> <span class="n">mol</span><span class="p">:</span>
                    <span class="n">initial_ids</span><span class="p">[</span><span class="n">mol</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">offmol</span><span class="o">.</span><span class="n">n_conformers</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="n">InvalidConformerError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid conformer for this molecule, the geometry could not be attached.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># attach a dict that has the initial molecule ids and the number of the conformer it is stored in</span>
        <span class="c1"># if it&#39;s empty, don&#39;t bother</span>
        <span class="k">if</span> <span class="n">initial_ids</span><span class="p">:</span>
            <span class="n">offmol</span><span class="o">.</span><span class="n">_properties</span><span class="p">[</span><span class="s2">&quot;initial_molecules&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_ids</span>

        <span class="k">return</span> <span class="n">offmol</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@RDKitToolkitWrapper</span><span class="o">.</span><span class="n">requires_toolkit</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">from_pdb_and_smiles</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">smiles</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Molecule from a pdb file and a SMILES string using RDKit.</span>

<span class="sd">        Requires RDKit to be installed.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        The molecule is created and sanitised based on the SMILES string, we then find a mapping</span>
<span class="sd">        between this molecule and one from the PDB based only on atomic number and connections.</span>
<span class="sd">        The SMILES molecule is then reindexed to match the PDB, the conformer is attached, and the</span>
<span class="sd">        molecule returned.</span>

<span class="sd">        Note that any stereochemistry in the molecule is set by the SMILES, and not the coordinates</span>
<span class="sd">        of the PDB.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path: str</span>
<span class="sd">            PDB file path</span>
<span class="sd">        smiles : str</span>
<span class="sd">            a valid smiles string for the pdb, used for stereochemistry, formal charges, and bond order</span>
<span class="sd">        allow_undefined_stereo : bool, default=False</span>
<span class="sd">            If false, raises an exception if SMILES contains undefined stereochemistry.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        molecule : openff.toolkit.Molecule</span>
<span class="sd">            An OFFMol instance with ordering the same as used in the PDB file.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        InvalidConformerError</span>
<span class="sd">            If the SMILES and PDB molecules are not isomorphic.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">toolkit</span> <span class="o">=</span> <span class="n">RDKitToolkitWrapper</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_pdb_and_smiles</span><span class="p">(</span>
            <span class="n">file_path</span><span class="p">,</span> <span class="n">smiles</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="p">,</span> <span class="n">_cls</span><span class="o">=</span><span class="bp">cls</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">canonical_order_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce a copy of the molecule with the atoms reordered canonically.</span>

<span class="sd">        Each toolkit defines its own canonical ordering of atoms. The canonical</span>
<span class="sd">        order may change from toolkit version to toolkit version or between</span>
<span class="sd">        toolkits.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        toolkit_registry : openff.toolkit.utils.toolkits.ToolkitRegistry or</span>
<span class="sd">            openff.toolkit.utils.toolkits.ToolkitWrapper, optional</span>
<span class="sd">            :class:`ToolkitRegistry` or :class:`ToolkitWrapper` to use for</span>
<span class="sd">            SMILES-to-molecule conversion</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule : openff.toolkit.topology.Molecule</span>
<span class="sd">            An new OpenFF style molecule with atoms in the canonical order.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitRegistry</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;canonical_order_atoms&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="n">toolkit</span> <span class="o">=</span> <span class="n">toolkit_registry</span>
            <span class="k">return</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">canonical_order_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidToolkitRegistryError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid toolkit_registry passed to from_smiles. Expected ToolkitRegistry or ToolkitWrapper. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">remap</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapping_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">current_to_new</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorder the atoms in the molecule according to the given mapping dict.</span>

<span class="sd">        The mapping dict must be a dictionary mapping atom indices to atom</span>
<span class="sd">        indices. Each atom index must be an integer in the half-open interval</span>
<span class="sd">        ``[0, n_atoms)``; ie, it must be a valid index into the ``self.atoms``</span>
<span class="sd">        list. All atom indices in the molecule must be mapped from and to</span>
<span class="sd">        exactly once unless ``partial=True`` is given, in which case they must</span>
<span class="sd">        be mapped no more than once. Missing (unless ``partial=True``),</span>
<span class="sd">        out-of-range (including non-integer), or duplicate indices are not</span>
<span class="sd">        allowed in the ``mapping_dict`` and will lead to an exception.</span>

<span class="sd">        By default, the mapping dict&#39;s keys are the source indices and its</span>
<span class="sd">        values are destination indices, but this can be changed with the</span>
<span class="sd">        ``current_to_new`` argument.</span>

<span class="sd">        The keys of the ``self.properties[&quot;atom_map&quot;]`` property are updated for</span>
<span class="sd">        the new ordering. Other values of the properties dictionary are</span>
<span class="sd">        transferred unchanged.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapping_dict</span>
<span class="sd">            A dictionary of the mapping between indices. The mapping should be</span>
<span class="sd">            indexed starting from 0 for both the source and destination; note</span>
<span class="sd">            that SMILES atom mapping is typically 1-based.</span>
<span class="sd">        current_to_new</span>
<span class="sd">            If this is ``True``, then ``mapping_dict`` is of the form</span>
<span class="sd">            ``{current_index: new_index}``; otherwise, it is of the form</span>
<span class="sd">            ``{new_index: current_index}``.</span>
<span class="sd">        partial</span>
<span class="sd">            If ``False`` (the default), an exception will be raised if any atom</span>
<span class="sd">            is lacking a destination in the atom map. Note that if this is</span>
<span class="sd">            ``True``, atoms without entries in the mapping dict may be moved in</span>
<span class="sd">            addition to those in the dictionary. Note that partial maps must</span>
<span class="sd">            still be in-range and not include duplicates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_molecule :  openff.toolkit.topology.molecule.Molecule</span>
<span class="sd">            A copy of the molecule in the new order.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RemapIndexError</span>
<span class="sd">            When an out-of-range, duplicate, or missing index is found in the</span>
<span class="sd">            ``mapping_dict``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_mapped_smiles</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make sure the size of the mapping matches the current molecule</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">partial</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">RemapIndexError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The number of mapping indices (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;match the number of atoms in this molecule (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># make two mapping dicts we need new to old for atoms</span>
        <span class="c1"># and old to new for bonds</span>
        <span class="k">if</span> <span class="n">current_to_new</span><span class="p">:</span>
            <span class="n">cur_to_new</span> <span class="o">=</span> <span class="n">mapping_dict</span>
            <span class="n">new_to_cur</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">mapping_dict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">mapping_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_to_cur</span> <span class="o">=</span> <span class="n">mapping_dict</span>
            <span class="n">cur_to_new</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">mapping_dict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">mapping_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c1"># Make sure that there were no duplicate indices</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_to_cur</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_to_new</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">RemapIndexError</span><span class="p">(</span>
                <span class="s2">&quot;There must be no duplicate source or destination indices in&quot;</span>
                <span class="o">+</span> <span class="s2">&quot; mapping_dict&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">new_to_cur</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="o">*</span><span class="n">cur_to_new</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">RemapIndexError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;All indices in a mapping_dict for a molecule with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; atoms must be integers between 0 and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If a partial map is allowed, complete it</span>
        <span class="k">if</span> <span class="n">partial</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">:</span>
            <span class="c1"># Get a set of all the unspecified destination indices</span>
            <span class="n">available_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_to_cur</span><span class="p">}</span>
            <span class="c1"># Find the atoms that can be left unmoved and don&#39;t move them</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cur_to_new</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_to_cur</span><span class="p">:</span>
                    <span class="n">available_indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">cur_to_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">new_to_cur</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="c1"># Fill in the remaining indices</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cur_to_new</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">available_indices</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">cur_to_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">new_to_cur</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">new_molecule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        <span class="n">new_molecule</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># add the atoms list</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">):</span>
                <span class="c1"># get the old atom info</span>
                <span class="n">old_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="n">new_to_cur</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">new_molecule</span><span class="o">.</span><span class="n">_add_atom</span><span class="p">(</span><span class="o">**</span><span class="n">old_atom</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
        <span class="c1"># this is the first time we access the mapping; catch an index error</span>
        <span class="c1"># here corresponding to mapping that starts from 0 or higher</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">RemapIndexError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The mapping supplied is missing a destination index for atom </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># add the bonds but with atom indexes in a sorted ascending order</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">cur_to_new</span><span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1_index</span><span class="p">],</span> <span class="n">cur_to_new</span><span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2_index</span><span class="p">]])</span>
            <span class="n">bond_dict</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">bond_dict</span><span class="p">[</span><span class="s2">&quot;atom2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">new_molecule</span><span class="o">.</span><span class="n">_add_bond</span><span class="p">(</span><span class="o">**</span><span class="n">bond_dict</span><span class="p">)</span>

        <span class="c1"># we can now resort the bonds</span>
        <span class="n">sorted_bonds</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">new_molecule</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;atom1_index&quot;</span><span class="p">,</span> <span class="s2">&quot;atom2_index&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">new_molecule</span><span class="o">.</span><span class="n">_bonds</span> <span class="o">=</span> <span class="n">sorted_bonds</span>

        <span class="c1"># remap the charges</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_charges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">):</span>
                <span class="n">new_charges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_charges</span><span class="p">[</span><span class="n">new_to_cur</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span>
                    <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span>
                <span class="p">)</span>
            <span class="n">new_molecule</span><span class="o">.</span><span class="n">partial_charges</span> <span class="o">=</span> <span class="n">new_charges</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span>

        <span class="c1"># remap the conformers, there can be more than one</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">conformer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformers</span><span class="p">:</span>
                <span class="n">new_conformer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">):</span>
                    <span class="n">new_conformer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">conformer</span><span class="p">[</span><span class="n">new_to_cur</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>
                <span class="n">new_molecule</span><span class="o">.</span><span class="n">_add_conformer</span><span class="p">(</span><span class="n">new_conformer</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>

        <span class="c1"># move any properties across</span>
        <span class="n">new_molecule</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>

        <span class="c1"># remap the atom map</span>
        <span class="k">if</span> <span class="s2">&quot;atom_map&quot;</span> <span class="ow">in</span> <span class="n">new_molecule</span><span class="o">.</span><span class="n">properties</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">new_molecule</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;atom_map&quot;</span><span class="p">],</span> <span class="nb">dict</span>
        <span class="p">):</span>
            <span class="n">new_molecule</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;atom_map&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">cur_to_new</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_molecule</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;atom_map&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="n">new_molecule</span>

    <span class="k">def</span> <span class="nf">to_openeye</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">toolkit_registry</span><span class="o">=</span><span class="n">GLOBAL_TOOLKIT_REGISTRY</span><span class="p">,</span>
        <span class="n">aromaticity_model</span><span class="o">=</span><span class="n">DEFAULT_AROMATICITY_MODEL</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an OpenEye molecule</span>

<span class="sd">        Requires the OpenEye toolkit to be installed.</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * Use stored conformer positions instead of an argument.</span>
<span class="sd">           * Should the aromaticity model be specified in some other way?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        aromaticity_model : str, optional, default=&quot;OEAroModel_MDL&quot;</span>
<span class="sd">            The aromaticity model to use. Only OEAroModel_MDL is supported.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        oemol : openeye.oechem.OEMol</span>
<span class="sd">            An OpenEye molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create an OpenEye molecule from a Molecule</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;CC&#39;)</span>
<span class="sd">        &gt;&gt;&gt; oemol = molecule.to_openeye()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># toolkit = OpenEyeToolkitWrapper()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="p">,</span> <span class="n">ToolkitWrapper</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">to_openeye</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">aromaticity_model</span><span class="o">=</span><span class="n">aromaticity_model</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">toolkit_registry</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
                <span class="s2">&quot;to_openeye&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aromaticity_model</span><span class="o">=</span><span class="n">aromaticity_model</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an iterator over all i-j-k angles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Build Angle objects instead of tuple of atoms.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_angles&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_construct_bonded_atoms_list</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom1</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">atom3</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom2</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">atom1</span> <span class="o">==</span> <span class="n">atom3</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="c1"># TODO: Encapsulate this logic into an Angle class.</span>
                        <span class="k">if</span> <span class="n">atom1</span><span class="o">.</span><span class="n">molecule_atom_index</span> <span class="o">&lt;</span> <span class="n">atom3</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">atom3</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">atom3</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">atom1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_construct_torsions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct sets containing the atoms improper and proper torsions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Build Proper/ImproperTorsion objects instead of tuple of atoms.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_torsions&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_construct_bonded_atoms_list</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_propers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom1</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">atom3</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom2</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">atom1</span> <span class="o">==</span> <span class="n">atom3</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">for</span> <span class="n">atom4</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom3</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">atom4</span> <span class="o">==</span> <span class="n">atom2</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="c1"># Exclude i-j-k-i</span>
                            <span class="k">if</span> <span class="n">atom1</span> <span class="o">==</span> <span class="n">atom4</span><span class="p">:</span>
                                <span class="k">continue</span>

                            <span class="k">if</span> <span class="n">atom1</span><span class="o">.</span><span class="n">molecule_atom_index</span> <span class="o">&lt;</span> <span class="n">atom4</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">:</span>
                                <span class="n">torsion</span> <span class="o">=</span> <span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">atom3</span><span class="p">,</span> <span class="n">atom4</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">torsion</span> <span class="o">=</span> <span class="p">(</span><span class="n">atom4</span><span class="p">,</span> <span class="n">atom3</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">atom1</span><span class="p">)</span>

                            <span class="bp">self</span><span class="o">.</span><span class="n">_propers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">atom3i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom2</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">atom3i</span> <span class="o">==</span> <span class="n">atom3</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="k">if</span> <span class="n">atom3i</span> <span class="o">==</span> <span class="n">atom1</span><span class="p">:</span>
                                <span class="k">continue</span>

                            <span class="n">improper</span> <span class="o">=</span> <span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">atom3</span><span class="p">,</span> <span class="n">atom3i</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">improper</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_torsions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propers</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impropers</span>

    <span class="k">def</span> <span class="nf">_construct_bonded_atoms_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct list of all atoms each atom is bonded to.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add this to cached_properties</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_bondedAtoms&quot;</span><span class="p">):</span>
            <span class="c1"># self._atoms = [ atom for atom in self.atoms() ]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="p">:</span>
                <span class="n">atom1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1_index</span><span class="p">]</span>
                <span class="n">atom2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">atom2_index</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom2</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_bonded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_index_1</span><span class="p">,</span> <span class="n">atom_index_2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if atoms are bonded, False if not.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom_index_1 : int</span>
<span class="sd">        atom_index_2 : int</span>
<span class="sd">            Atom indices</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_bonded : bool</span>
<span class="sd">            True if atoms are bonded, False otherwise</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_bonded_atoms_list</span><span class="p">()</span>
        <span class="n">atom1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="n">atom_index_1</span><span class="p">]</span>
        <span class="n">atom2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="n">atom_index_2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondedAtoms</span><span class="p">[</span><span class="n">atom1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_bond_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;Atom&quot;</span><span class="p">],</span> <span class="n">j</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;Atom&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Bond&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the bond between two atoms</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i, j : int or Atom</span>
<span class="sd">            Atoms or atom indices to check</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bond : Bond</span>
<span class="sd">            The bond between i and j.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">atom_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">atom_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">atom_i</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">atom_j</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid input passed to get_bond_between(). Expected ints or Atoms, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">atom_i</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">bond</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom</span> <span class="o">==</span> <span class="n">atom_i</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">atom</span> <span class="o">==</span> <span class="n">atom_j</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">bond</span>

        <span class="kn">from</span> <span class="nn">openff.toolkit.topology</span> <span class="kn">import</span> <span class="n">NotBondedError</span>

        <span class="k">raise</span> <span class="n">NotBondedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No bond between atom </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Molecule"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule">[docs]</a><span class="k">class</span> <span class="nc">Molecule</span><span class="p">(</span><span class="n">FrozenMolecule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mutable chemical representation of a molecule, such as a small molecule or biopolymer.</span>

<span class="sd">    .. todo :: What other API calls would be useful for supporting biopolymers as small molecules? Perhaps iterating</span>
<span class="sd">        over chains and residues?</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Create a molecule from an sdf file</span>

<span class="sd">    &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">    &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">    &gt;&gt;&gt; molecule = Molecule(sdf_filepath)</span>

<span class="sd">    Convert to OpenEye OEMol object</span>

<span class="sd">    &gt;&gt;&gt; oemol = molecule.to_openeye()</span>

<span class="sd">    Create a molecule from an OpenEye molecule</span>

<span class="sd">    &gt;&gt;&gt; molecule = Molecule.from_openeye(oemol)</span>

<span class="sd">    Convert to RDKit Mol object</span>

<span class="sd">    &gt;&gt;&gt; rdmol = molecule.to_rdkit()</span>

<span class="sd">    Create a molecule from an RDKit molecule</span>

<span class="sd">    &gt;&gt;&gt; molecule = Molecule.from_rdkit(rdmol)</span>

<span class="sd">    Create a molecule from IUPAC name (requires the OpenEye toolkit)</span>

<span class="sd">    &gt;&gt;&gt; molecule = Molecule.from_iupac(&#39;imatinib&#39;)</span>

<span class="sd">    Create a molecule from SMILES</span>

<span class="sd">    &gt;&gt;&gt; molecule = Molecule.from_smiles(&#39;Cc1ccccc1&#39;)</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Molecule.__init__"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Molecule object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : optional, default=None</span>
<span class="sd">            If specified, attempt to construct a copy of the molecule from the</span>
<span class="sd">            specified object. This can be any one of the following:</span>

<span class="sd">            * a :class:`Molecule` object</span>
<span class="sd">            * a file that can be used to construct a :class:`Molecule` object</span>
<span class="sd">            * an ``openeye.oechem.OEMol``</span>
<span class="sd">            * an ``rdkit.Chem.rdchem.Mol``</span>
<span class="sd">            * a serialized :class:`Molecule` object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create an empty molecule:</span>

<span class="sd">        &gt;&gt;&gt; empty_molecule = Molecule()</span>

<span class="sd">        Create a molecule from a file that can be used to construct a molecule,</span>
<span class="sd">        using either a filename or file-like object:</span>

<span class="sd">        &gt;&gt;&gt; from openff.toolkit.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; sdf_filepath = get_data_file_path(&#39;molecules/ethanol.sdf&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule(sdf_filepath)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule(open(sdf_filepath, &#39;r&#39;), file_format=&#39;sdf&#39;)</span>

<span class="sd">        &gt;&gt;&gt; import gzip</span>
<span class="sd">        &gt;&gt;&gt; mol2_gz_filepath = get_data_file_path(&#39;molecules/toluene.mol2.gz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; molecule = Molecule(gzip.GzipFile(mol2_gz_filepath, &#39;r&#39;), file_format=&#39;mol2&#39;)</span>

<span class="sd">        Create a molecule from another molecule:</span>

<span class="sd">        &gt;&gt;&gt; molecule_copy = Molecule(molecule)</span>

<span class="sd">        Convert to OpenEye OEMol object</span>

<span class="sd">        &gt;&gt;&gt; oemol = molecule.to_openeye()</span>

<span class="sd">        Create a molecule from an OpenEye molecule:</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule(oemol)</span>

<span class="sd">        Convert to RDKit Mol object</span>

<span class="sd">        &gt;&gt;&gt; rdmol = molecule.to_rdkit()</span>

<span class="sd">        Create a molecule from an RDKit molecule:</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule(rdmol)</span>

<span class="sd">        Convert the molecule into a dictionary and back again:</span>

<span class="sd">        &gt;&gt;&gt; serialized_molecule = molecule.to_dict()</span>
<span class="sd">        &gt;&gt;&gt; molecule_copy = Molecule(serialized_molecule)</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * If a filename or file-like object is specified but the file</span>
<span class="sd">             contains more than one molecule, what is the proper behavior?</span>
<span class="sd">             Read just the first molecule, or raise an exception if more</span>
<span class="sd">             than one molecule is found?</span>

<span class="sd">           * Should we also support SMILES strings or IUPAC names for</span>
<span class="sd">             ``other``?</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Molecule</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># TODO: Change this to add_atom(Atom) to improve encapsulation and extensibility?</span>
<div class="viewcode-block" id="Molecule.add_atom"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.add_atom">[docs]</a>    <span class="k">def</span> <span class="nf">add_atom</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atomic_number</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">formal_charge</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">is_aromatic</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">stereochemistry</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an atom to the molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atomic_number : int</span>
<span class="sd">            Atomic number of the atom</span>
<span class="sd">        formal_charge : int</span>
<span class="sd">            Formal charge of the atom</span>
<span class="sd">        is_aromatic : bool</span>
<span class="sd">            If ``True``, atom is aromatic; if ``False``, not aromatic</span>
<span class="sd">        stereochemistry : str, optional, default=None</span>
<span class="sd">            Either ``&#39;R&#39;`` or ``&#39;S&#39;`` for specified stereochemistry, or ``None`` if stereochemistry is irrelevant</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            An optional name for the atom</span>
<span class="sd">        metadata : dict[str: (int, str)], default=None</span>
<span class="sd">            An optional dictionary where keys are strings and values are strings or ints. This is intended</span>
<span class="sd">            to record atom-level information used to inform hierarchy definition and iteration, such as</span>
<span class="sd">            grouping atom by residue and chain.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the atom in the molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Define a methane molecule</span>

<span class="sd">        &gt;&gt;&gt; molecule = Molecule()</span>
<span class="sd">        &gt;&gt;&gt; molecule.name = &#39;methane&#39;</span>
<span class="sd">        &gt;&gt;&gt; C = molecule.add_atom(6, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H1 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H2 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H3 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; H4 = molecule.add_atom(1, 0, False)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H1, 1, False)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H2, 1, False)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H3, 1, False)</span>
<span class="sd">        &gt;&gt;&gt; bond_idx = molecule.add_bond(C, H4, 1, False)</span>
<span class="sd">        &gt;&gt;&gt; molecule.to_smiles(explicit_hydrogens=False)</span>
<span class="sd">        &#39;C&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atom_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_atom</span><span class="p">(</span>
            <span class="n">atomic_number</span><span class="p">,</span>
            <span class="n">formal_charge</span><span class="p">,</span>
            <span class="n">is_aromatic</span><span class="p">,</span>
            <span class="n">stereochemistry</span><span class="o">=</span><span class="n">stereochemistry</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">atom_index</span></div>

<div class="viewcode-block" id="Molecule.add_bond"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.add_bond">[docs]</a>    <span class="k">def</span> <span class="nf">add_bond</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atom1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;Atom&quot;</span><span class="p">],</span>
        <span class="n">atom2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;Atom&quot;</span><span class="p">],</span>
        <span class="n">bond_order</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">is_aromatic</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">stereochemistry</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fractional_bond_order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a bond between two specified atom indices</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom1 : int or openff.toolkit.topology.molecule.Atom</span>
<span class="sd">            Index of first atom</span>
<span class="sd">        atom2 : int or openff.toolkit.topology.molecule.Atom</span>
<span class="sd">            Index of second atom</span>
<span class="sd">        bond_order : int</span>
<span class="sd">            Integral bond order of Kekulized form</span>
<span class="sd">        is_aromatic : bool</span>
<span class="sd">            True if this bond is aromatic, False otherwise</span>
<span class="sd">        stereochemistry : str, optional, default=None</span>
<span class="sd">            Either ``&#39;E&#39;`` or ``&#39;Z&#39;`` for specified stereochemistry, or ``None`` if stereochemistry is irrelevant</span>
<span class="sd">        fractional_bond_order : float, optional, default=None</span>
<span class="sd">            The fractional (eg. Wiberg) bond order</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index: int</span>
<span class="sd">            Index of the bond in this molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        For an example of use, see :py:meth:`add_atom`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bond_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_bond</span><span class="p">(</span>
            <span class="n">atom1</span><span class="p">,</span>
            <span class="n">atom2</span><span class="p">,</span>
            <span class="n">bond_order</span><span class="p">,</span>
            <span class="n">is_aromatic</span><span class="p">,</span>
            <span class="n">stereochemistry</span><span class="o">=</span><span class="n">stereochemistry</span><span class="p">,</span>
            <span class="n">fractional_bond_order</span><span class="o">=</span><span class="n">fractional_bond_order</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">bond_index</span></div>

<div class="viewcode-block" id="Molecule.add_conformer"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.add_conformer">[docs]</a>    <span class="k">def</span> <span class="nf">add_conformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a conformation of the molecule</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates: unit-wrapped np.array with shape (n_atoms, 3) and dimension of distance</span>
<span class="sd">            Coordinates of the new conformer, with the first dimension of the array corresponding to the atom index in</span>
<span class="sd">            the molecule&#39;s indexing system.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index: int</span>
<span class="sd">            The index of this conformer</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO how can be check that a set of coords and no connections</span>
        <span class="c1">#   is a conformation that does not change connectivity?</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_conformer</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.visualize"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.visualize">[docs]</a>    <span class="k">def</span> <span class="nf">visualize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">backend</span><span class="o">=</span><span class="s2">&quot;rdkit&quot;</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_all_hydrogens</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render a visualization of the molecule in Jupyter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        backend : str, optional, default=&#39;rdkit&#39;</span>
<span class="sd">            The visualization engine to use. Choose from:</span>

<span class="sd">            - ``&quot;rdkit&quot;``</span>
<span class="sd">            - ``&quot;openeye&quot;``</span>
<span class="sd">            - ``&quot;nglview&quot;`` (requires conformers)</span>

<span class="sd">        width : int, optional, default=500</span>
<span class="sd">            Width of the generated representation (only applicable to</span>
<span class="sd">            ``backend=openeye`` or ``backend=rdkit``)</span>
<span class="sd">        height : int, optional, default=300</span>
<span class="sd">            Width of the generated representation (only applicable to</span>
<span class="sd">            ``backend=openeye`` or ``backend=rdkit``)</span>
<span class="sd">        show_all_hydrogens : bool, optional, default=True</span>
<span class="sd">            Whether to explicitly depict all hydrogen atoms. (only applicable to</span>
<span class="sd">            ``backend=openeye`` or ``backend=rdkit``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            Depending on the backend chosen:</span>

<span class="sd">            - rdkit → IPython.display.SVG</span>
<span class="sd">            - openeye → IPython.display.Image</span>
<span class="sd">            - nglview → nglview.NGLWidget</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openff.toolkit.utils.toolkits</span> <span class="kn">import</span> <span class="n">OPENEYE_AVAILABLE</span><span class="p">,</span> <span class="n">RDKIT_AVAILABLE</span>

        <span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;nglview&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">nglview</span> <span class="k">as</span> <span class="nn">nv</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MissingOptionalDependencyError</span><span class="p">(</span><span class="s2">&quot;nglview&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">height</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># TODO: More specific exception</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The width, height, and show_all_hydrogens arguments do not apply to the nglview backend.&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">show_all_hydrogens</span><span class="p">:</span>
                <span class="c1"># TODO: More specific exception</span>
                <span class="c1"># TODO: Implement this? Should be able to just strip hydrogens from the PDB</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;show_all_hydrogens=False is not supported by the nglview backend&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformers</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">openff.toolkit.utils.viz</span> <span class="kn">import</span> <span class="n">_OFFTrajectoryNGLView</span>

                <span class="n">trajectory_like</span> <span class="o">=</span> <span class="n">_OFFTrajectoryNGLView</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">widget</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">NGLWidget</span><span class="p">(</span><span class="n">trajectory_like</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">widget</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: More specific exception</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Visualizing with NGLview requires that the molecule has &quot;</span>
                    <span class="s2">&quot;conformers.&quot;</span>
                <span class="p">)</span>

        <span class="n">width</span> <span class="o">=</span> <span class="mi">500</span> <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">width</span>
        <span class="n">height</span> <span class="o">=</span> <span class="mi">300</span> <span class="k">if</span> <span class="n">height</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">height</span>
        <span class="n">show_all_hydrogens</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">show_all_hydrogens</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">show_all_hydrogens</span>

        <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;rdkit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">RDKIT_AVAILABLE</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">SVG</span>
                <span class="kn">from</span> <span class="nn">rdkit.Chem.Draw</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># type: ignore[import]</span>
                    <span class="n">rdDepictor</span><span class="p">,</span>
                    <span class="n">rdMolDraw2D</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="kn">from</span> <span class="nn">rdkit.Chem.rdmolops</span> <span class="kn">import</span> <span class="n">RemoveHs</span>  <span class="c1"># type: ignore[import]</span>

                <span class="n">rdmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">()</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">show_all_hydrogens</span><span class="p">:</span>
                    <span class="c1"># updateExplicitCount: Keep a record of the hydrogens we remove.</span>
                    <span class="c1"># This is used in visualization to distinguish eg radicals from normal species</span>
                    <span class="n">rdmol</span> <span class="o">=</span> <span class="n">RemoveHs</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">updateExplicitCount</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">rdDepictor</span><span class="o">.</span><span class="n">SetPreferCoordGen</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">rdDepictor</span><span class="o">.</span><span class="n">Compute2DCoords</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
                <span class="n">rdmol</span> <span class="o">=</span> <span class="n">rdMolDraw2D</span><span class="o">.</span><span class="n">PrepareMolForDrawing</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

                <span class="n">drawer</span> <span class="o">=</span> <span class="n">rdMolDraw2D</span><span class="o">.</span><span class="n">MolDraw2DSVG</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
                <span class="n">drawer</span><span class="o">.</span><span class="n">DrawMolecule</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
                <span class="n">drawer</span><span class="o">.</span><span class="n">FinishDrawing</span><span class="p">()</span>

                <span class="k">return</span> <span class="n">SVG</span><span class="p">(</span><span class="n">drawer</span><span class="o">.</span><span class="n">GetDrawingText</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;RDKit was requested as a visualization backend but &quot;</span>
                    <span class="s2">&quot;it was not found to be installed. Falling back to &quot;</span>
                    <span class="s2">&quot;trying to use OpenEye for visualization.&quot;</span>
                <span class="p">)</span>
                <span class="n">backend</span> <span class="o">=</span> <span class="s2">&quot;openeye&quot;</span>
        <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;openeye&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">OPENEYE_AVAILABLE</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">Image</span>
                <span class="kn">from</span> <span class="nn">openeye</span> <span class="kn">import</span> <span class="n">oedepict</span>

                <span class="n">oemol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_openeye</span><span class="p">()</span>

                <span class="n">opts</span> <span class="o">=</span> <span class="n">oedepict</span><span class="o">.</span><span class="n">OE2DMolDisplayOptions</span><span class="p">(</span>
                    <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">oedepict</span><span class="o">.</span><span class="n">OEScale_AutoScale</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">show_all_hydrogens</span><span class="p">:</span>
                    <span class="n">opts</span><span class="o">.</span><span class="n">SetHydrogenStyle</span><span class="p">(</span><span class="n">oedepict</span><span class="o">.</span><span class="n">OEHydrogenStyle_ImplicitAll</span><span class="p">)</span>

                <span class="n">oedepict</span><span class="o">.</span><span class="n">OEPrepareDepiction</span><span class="p">(</span><span class="n">oemol</span><span class="p">)</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">oedepict</span><span class="o">.</span><span class="n">OEImage</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
                <span class="n">display</span> <span class="o">=</span> <span class="n">oedepict</span><span class="o">.</span><span class="n">OE2DMolDisplay</span><span class="p">(</span><span class="n">oemol</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>
                <span class="n">oedepict</span><span class="o">.</span><span class="n">OERenderMolecule</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">display</span><span class="p">)</span>
                <span class="n">png</span> <span class="o">=</span> <span class="n">oedepict</span><span class="o">.</span><span class="n">OEWriteImageToString</span><span class="p">(</span><span class="s2">&quot;png&quot;</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">png</span><span class="p">)</span>

        <span class="c1"># TODO: More specific exception</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find an appropriate backend&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.perceive_residues"><a class="viewcode-back" href="../../../../generated/openff.toolkit.topology.Molecule.html#openff.toolkit.topology.Molecule.perceive_residues">[docs]</a>    <span class="k">def</span> <span class="nf">perceive_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">substructure_file_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict_chirality</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perceive a polymer&#39;s residues and permit iterating over them.</span>

<span class="sd">        Perceives residues by matching substructures in the current molecule</span>
<span class="sd">        with a substructure dictionary file, using SMARTS, and assigns residue</span>
<span class="sd">        names and numbers to atom metadata. It then constructs a residue hierarchy</span>
<span class="sd">        scheme to allow iterating over residues.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        substructure_file_path : str, optional, default=None</span>
<span class="sd">            Path to substructure library file in JSON format. Defaults to using</span>
<span class="sd">            built-in substructure file.</span>
<span class="sd">        strict_chirality: bool, optional, default=True</span>
<span class="sd">            Whether to use strict chirality symbols (stereomarks) for</span>
<span class="sd">            substructure matchings with SMARTS.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read substructure dictionary file</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">substructure_file_path</span><span class="p">:</span>
            <span class="n">substructure_file_path</span> <span class="o">=</span> <span class="n">get_data_file_path</span><span class="p">(</span>
                <span class="s2">&quot;proteins/aa_residues_substructures_with_caps.json&quot;</span>
            <span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">substructure_file_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">subfile</span><span class="p">:</span>
            <span class="n">substructure_dictionary</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">subfile</span><span class="p">)</span>

        <span class="c1"># TODO: Think of a better way to deal with no strict chirality case</span>
        <span class="c1"># if ignoring strict chirality, remove/update keys in inner dictionary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">strict_chirality</span><span class="p">:</span>
            <span class="c1"># make a copy of substructure dict</span>
            <span class="n">substructure_dictionary_no_chirality</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">substructure_dictionary</span><span class="p">)</span>
            <span class="c1"># Update inner key (SMARTS) maintaining its value</span>
            <span class="k">for</span> <span class="n">res_name</span><span class="p">,</span> <span class="n">inner_dict</span> <span class="ow">in</span> <span class="n">substructure_dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">smarts</span> <span class="ow">in</span> <span class="n">inner_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">smarts_no_chirality</span> <span class="o">=</span> <span class="n">smarts</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>  <span class="c1"># remove @ in smarts</span>
                    <span class="n">substructure_dictionary_no_chirality</span><span class="p">[</span><span class="n">res_name</span><span class="p">][</span>
                        <span class="n">smarts_no_chirality</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">substructure_dictionary_no_chirality</span><span class="p">[</span><span class="n">res_name</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
                        <span class="n">smarts</span>
                    <span class="p">)</span>  <span class="c1"># update key</span>
            <span class="c1"># replace with the new substructure dictionary</span>
            <span class="n">substructure_dictionary</span> <span class="o">=</span> <span class="n">substructure_dictionary_no_chirality</span>

        <span class="n">all_matches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">residue_name</span><span class="p">,</span> <span class="n">smarts_dict</span> <span class="ow">in</span> <span class="n">substructure_dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">smarts</span> <span class="ow">in</span> <span class="n">smarts_dict</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_environment_matches</span><span class="p">(</span><span class="n">smarts</span><span class="p">):</span>
                    <span class="n">matches</span><span class="p">[</span><span class="n">match</span><span class="p">]</span> <span class="o">=</span> <span class="n">smarts</span>
                    <span class="n">all_matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">{</span>
                            <span class="s2">&quot;atom_idxs&quot;</span><span class="p">:</span> <span class="n">match</span><span class="p">,</span>
                            <span class="s2">&quot;atom_idxs_set&quot;</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="n">match</span><span class="p">),</span>
                            <span class="s2">&quot;smarts&quot;</span><span class="p">:</span> <span class="n">smarts</span><span class="p">,</span>
                            <span class="s2">&quot;residue_name&quot;</span><span class="p">:</span> <span class="n">residue_name</span><span class="p">,</span>
                            <span class="s2">&quot;atom_names&quot;</span><span class="p">:</span> <span class="n">smarts_dict</span><span class="p">[</span><span class="n">smarts</span><span class="p">],</span>
                        <span class="p">}</span>
                    <span class="p">)</span>

        <span class="c1"># Remove matches that are subsets of other matches</span>
        <span class="c1"># give precedence to the SMARTS defined at the end of the file</span>
        <span class="n">match_idxs_to_delete</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">match_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_matches</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">this_match_set</span> <span class="o">=</span> <span class="n">all_matches</span><span class="p">[</span><span class="n">match_idx</span><span class="p">][</span><span class="s2">&quot;atom_idxs_set&quot;</span><span class="p">]</span>
            <span class="n">this_match_set_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_match_set</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">match_before_this_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">match_idx</span><span class="p">):</span>
                <span class="n">match_before_this_set</span> <span class="o">=</span> <span class="n">all_matches</span><span class="p">[</span><span class="n">match_before_this_idx</span><span class="p">][</span>
                    <span class="s2">&quot;atom_idxs_set&quot;</span>
                <span class="p">]</span>
                <span class="n">match_before_this_set_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_before_this_set</span><span class="p">)</span>
                <span class="n">n_overlapping_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">this_match_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">match_before_this_set</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">n_overlapping_atoms</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">match_before_this_set_size</span> <span class="o">&lt;</span> <span class="n">this_match_set_size</span><span class="p">:</span>
                        <span class="n">match_idxs_to_delete</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">match_before_this_idx</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">match_idxs_to_delete</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">match_idx</span><span class="p">)</span>

        <span class="n">match_idxs_to_delete_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">match_idxs_to_delete</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">match_idx</span> <span class="ow">in</span> <span class="n">match_idxs_to_delete_list</span><span class="p">:</span>
            <span class="n">all_matches</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">match_idx</span><span class="p">)</span>

        <span class="n">all_matches</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;atom_idxs&quot;</span><span class="p">]))</span>

        <span class="c1"># Now the matches have been deduplicated and de-subsetted</span>
        <span class="k">for</span> <span class="n">residue_num</span><span class="p">,</span> <span class="n">match_dict</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_matches</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">smarts_idx</span><span class="p">,</span> <span class="n">atom_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">match_dict</span><span class="p">[</span><span class="s2">&quot;atom_idxs&quot;</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom_idx</span><span class="p">]</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;residue_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_dict</span><span class="p">[</span>
                    <span class="s2">&quot;residue_name&quot;</span>
                <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom_idx</span><span class="p">]</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;residue_number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">residue_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom_idx</span><span class="p">]</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;insertion_code&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom_idx</span><span class="p">]</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;atom_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_dict</span><span class="p">[</span><span class="s2">&quot;atom_names&quot;</span><span class="p">][</span>
                    <span class="n">smarts_idx</span>
                <span class="p">]</span>

        <span class="c1"># Now add the residue hierarchy scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_residue_hierarchy_scheme</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_ipython_display_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;nglview&quot;</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;rdkit&quot;</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;openeye&quot;</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span></div>


<span class="k">def</span> <span class="nf">_networkx_graph_to_hill_formula</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="s2">&quot;nx.Graph&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a NetworkX graph to a Hill formula.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : nx.Graph</span>
<span class="sd">        The graph to convert.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        The Hill formula corresponding to the graph.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The graph must be a NetworkX graph.&quot;</span><span class="p">)</span>

    <span class="n">atom_nums</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;atomic_number&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">_atom_nums_to_hill_formula</span><span class="p">(</span><span class="n">atom_nums</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_atom_nums_to_hill_formula</span><span class="p">(</span><span class="n">atom_nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a `Counter` object of atom counts by atomic number, generate the corresponding</span>
<span class="sd">    Hill formula. See https://en.wikipedia.org/wiki/Chemical_formula#Hill_system&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

    <span class="n">SYMBOLS_</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">SYMBOLS</span><span class="p">)</span>
    <span class="n">SYMBOLS_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span>

    <span class="n">atom_symbol_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">SYMBOLS_</span><span class="p">[</span><span class="n">atom_num</span><span class="p">]</span> <span class="k">for</span> <span class="n">atom_num</span> <span class="ow">in</span> <span class="n">atom_nums</span><span class="p">)</span>

    <span class="n">formula</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Check for C and H first, to make a correct hill formula</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">atom_symbol_counts</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">atom_symbol_counts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
            <span class="n">formula</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">formula</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>

    <span class="c1"># now get the rest of the elements in alphabetical ordering</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">atom_symbol_counts</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">atom_symbol_counts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
        <span class="n">formula</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">formula</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_nth_degree_neighbors_from_graphlike</span><span class="p">(</span>
    <span class="n">graphlike</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Molecule</span><span class="p">,</span> <span class="s2">&quot;_SimpleMolecule&quot;</span><span class="p">],</span> <span class="n">n_degrees</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span>
    <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;_SimpleAtom&quot;</span><span class="p">,</span> <span class="s2">&quot;_SimpleAtom&quot;</span><span class="p">]],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a graph-like object, return a tuple of the nth degree neighbors of each atom.</span>

<span class="sd">    The input `graphlike` object must provide a .to_networkx() method and an</span>
<span class="sd">    `atoms` property that can be indexed.</span>

<span class="sd">    See Molecule.nth_degree_neighbors for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graphlike : Union[Molecule, _SimpleMolecule]</span>
<span class="sd">        The graph-like object to get the neighbors of.</span>
<span class="sd">    n: int</span>
<span class="sd">        The number of bonds separating atoms in each pair</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    neighbors: iterator of tuple of Atom</span>
<span class="sd">        Tuples (len 2) of atom that are separated by ``n`` bonds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">graphlike</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">node_i</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">node_j</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node_i</span> <span class="o">==</span> <span class="n">node_j</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">path_length</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node_i</span><span class="p">,</span> <span class="n">node_j</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">path_length</span> <span class="o">==</span> <span class="n">n_degrees</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node_i</span> <span class="o">&gt;</span> <span class="n">node_j</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">graphlike</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">node_i</span><span class="p">],</span> <span class="n">graphlike</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">node_j</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">HierarchyScheme</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perceives hierarchy elements from the metadata of atoms in a ``Molecule``.</span>

<span class="sd">    The Open Force Field Toolkit has no native understanding of hierarchical</span>
<span class="sd">    atom organisation schemes common to other biomolecular software, such as</span>
<span class="sd">    &quot;residues&quot; or &quot;chains&quot; (see :ref:`userguide_hierarchy`). To facilitate</span>
<span class="sd">    iterating over groups of atoms, a ``HierarchyScheme`` can be used to collect</span>
<span class="sd">    atoms into ``HierarchyElements``, groups of atoms that share the same</span>
<span class="sd">    values for certain metadata elements. Metadata elements are stored in the</span>
<span class="sd">    ``Atom.properties`` attribute.</span>

<span class="sd">    Hierarchy schemes are not updated dynamically; if a ``Molecule`` with</span>
<span class="sd">    hierarchy schemes changes, :meth:`Molecule.update_hierarchy_schemes()` must</span>
<span class="sd">    be called before the scheme is iterated over again or else the grouping</span>
<span class="sd">    may be incorrect.</span>

<span class="sd">    A ``HierarchyScheme`` contains the information needed to perceive</span>
<span class="sd">    ``HierarchyElement`` objects from a ``Molecule`` containing atoms with</span>
<span class="sd">    metadata.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    Molecule.add_default_hierarchy_schemes, Molecule.add_hierarchy_scheme,</span>
<span class="sd">    Molecule.hierarchy_schemes, Molecule.delete_hierarchy_scheme,</span>
<span class="sd">    Molecule.update_hierarchy_schemes, Molecule.perceive_residues,</span>
<span class="sd">    Topology.hierarchy_iterator, HierarchyElement</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">FrozenMolecule</span><span class="p">,</span>
        <span class="n">uniqueness_criteria</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">iterator_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new hierarchy scheme for iterating over groups of atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        parent</span>
<span class="sd">            The ``Molecule`` to which this scheme belongs.</span>
<span class="sd">        uniqueness_criteria</span>
<span class="sd">            The names of ``Atom`` metadata entries that define this scheme. An</span>
<span class="sd">            atom belongs to a ``HierarchyElement`` only if its metadata has the</span>
<span class="sd">            same values for these criteria as the other atoms in the</span>
<span class="sd">            ``HierarchyElement``.</span>
<span class="sd">        iterator_name</span>
<span class="sd">            The name of the iterator that will be exposed to access the hierarchy</span>
<span class="sd">            elements generated by this scheme</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">uniqueness_criteria</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">uniqueness_criteria</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;uniqueness_criteria&#39; kwarg must be a list or a tuple of strings,&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; received </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">uniqueness_criteria</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">uniqueness_criteria</span><span class="p">)</span><span class="si">}</span><span class="s2">) instead.&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">criterion</span> <span class="ow">in</span> <span class="n">uniqueness_criteria</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Each item in the &#39;uniqueness_criteria&#39; kwarg must be a string,&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; received </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span><span class="si">}</span><span class="s2">) instead.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">iterator_name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;iterator_name&#39; kwarg must be a string, received </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">iterator_name</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">iterator_name</span><span class="p">)</span><span class="si">}</span><span class="s2">) instead.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uniqueness_criteria</span> <span class="o">=</span> <span class="n">uniqueness_criteria</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterator_name</span> <span class="o">=</span> <span class="n">iterator_name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy_elements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">HierarchyElement</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Serialize this object to a basic dict of strings, ints, and floats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">return_dict</span><span class="p">[</span><span class="s2">&quot;uniqueness_criteria&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniqueness_criteria</span>
        <span class="n">return_dict</span><span class="p">[</span><span class="s2">&quot;iterator_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterator_name</span>
        <span class="n">return_dict</span><span class="p">[</span><span class="s2">&quot;hierarchy_elements&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">e</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy_elements</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">return_dict</span>

    <span class="k">def</span> <span class="nf">perceive_hierarchy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare the parent ``Molecule`` for iteration according to this scheme.</span>

<span class="sd">        Groups the atoms of the parent of this ``HierarchyScheme`` according to</span>
<span class="sd">        their metadata, and creates ``HierarchyElement`` objects suitable for</span>
<span class="sd">        iteration over the parent. Atoms missing the metadata fields in</span>
<span class="sd">        this object&#39;s ``uniqueness_criteria`` tuple will have those spots</span>
<span class="sd">        populated with the string ``&#39;None&#39;``.</span>

<span class="sd">        This method overwrites the scheme&#39;s ``hierarchy_elements`` attribute in</span>
<span class="sd">        place. Each ``HierarchyElement`` in the scheme&#39;s `hierarchy_elements`</span>
<span class="sd">        attribute is `static` --- that is, it is updated only when</span>
<span class="sd">        `perceive_hierarchy()` is called, and `not` on-the-fly when atom</span>
<span class="sd">        metadata is modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy_elements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># Determine which atoms should get added to which HierarchyElements</span>
        <span class="n">hier_eles_to_add</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">atom_key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">field_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniqueness_criteria</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">field_key</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
                    <span class="n">atom_key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="n">field_key</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">atom_key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">)</span>

            <span class="n">hier_eles_to_add</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">atom_key</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

        <span class="c1"># Create the actual HierarchyElements</span>
        <span class="k">for</span> <span class="n">atom_key</span><span class="p">,</span> <span class="n">atoms_to_add</span> <span class="ow">in</span> <span class="n">hier_eles_to_add</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">atom_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">molecule_atom_index</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">atoms_to_add</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_hierarchy_element</span><span class="p">(</span><span class="n">atom_key</span><span class="p">,</span> <span class="n">atom_indices</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sort_hierarchy_elements</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_hierarchy_element</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">identifier</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
        <span class="n">atom_indices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiate a new HierarchyElement belonging to this HierarchyScheme.</span>

<span class="sd">        This is the main way to instantiate new HierarchyElements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        identifier : tuple of str and int</span>
<span class="sd">            Tuple of metadata values (not keys) that define the uniqueness</span>
<span class="sd">            criteria for this element</span>
<span class="sd">        atom_indices : sequence of int</span>
<span class="sd">            The indices of atoms in ``scheme.parent`` that are in this</span>
<span class="sd">            element</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_hier_ele</span> <span class="o">=</span> <span class="n">HierarchyElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">atom_indices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy_elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hier_ele</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_hier_ele</span>

    <span class="k">def</span> <span class="nf">sort_hierarchy_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Semantically sort the HierarchyElements belonging to this object, according to</span>
<span class="sd">        their identifiers.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">compare_hier_identifiers</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;A comparison function which can compare hierarchy elements.</span>
<span class="sd">            Expects identifiers to be tuples of string and int.</span>
<span class="sd">            Attempts to cast strings to int. Assumes that ints are &quot;greater than&quot; strings.</span>

<span class="sd">            Returns -1 if a &lt; b, 0 if a==b, and 1 if a&gt;b.</span>

<span class="sd">            See https://docs.python.org/3/howto/sorting.html#comparison-functions</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Iterate over identifier components for comparison</span>
            <span class="k">for</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">identifier</span><span class="p">):</span>
                <span class="c1"># Try converting any strings to ints</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">val1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val1</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">val2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val2</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="c1"># If val1 and val2 are the same type, use built-in comparison</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val1</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">val2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">val1</span> <span class="o">&lt;</span> <span class="n">val2</span><span class="p">:</span>
                        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">val1</span> <span class="o">&gt;</span> <span class="n">val2</span><span class="p">:</span>
                        <span class="k">return</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="c1"># Otherwise, assume that ints are &quot;greater than&quot; strings.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val1</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                        <span class="k">return</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">val2</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c1"># If we&#39;ve finished comparing the values in the identifiers without</span>
            <span class="c1"># finding one to be greater than the other, then these two identifiers</span>
            <span class="c1"># must be equal.</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy_elements</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">cmp_to_key</span><span class="p">(</span><span class="n">compare_hier_identifiers</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;HierarchyScheme with uniqueness_criteria &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">uniqueness_criteria</span><span class="si">}</span><span class="s2">&#39;, iterator_name &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">iterator_name</span><span class="si">}</span><span class="s2">&#39;, and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hierarchy_elements</span><span class="p">)</span><span class="si">}</span><span class="s2"> elements&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">HierarchyElement</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An element in a metadata hierarchy scheme, such as a residue or chain.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scheme</span><span class="p">:</span> <span class="n">HierarchyScheme</span><span class="p">,</span>
        <span class="n">identifier</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
        <span class="n">atom_indices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new hierarchy element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        scheme : HierarchyScheme</span>
<span class="sd">            The scheme to which this ``HierarchyElement`` belongs</span>
<span class="sd">        identifier : tuple of str and int</span>
<span class="sd">            Tuple of metadata values (not keys) that define the uniqueness</span>
<span class="sd">            criteria for this element</span>
<span class="sd">        atom_indices : sequence of int</span>
<span class="sd">            The indices of particles in ``scheme.parent`` that are in this</span>
<span class="sd">            element</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">=</span> <span class="n">scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="n">identifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atom_indices</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">atom_indices</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">id_component</span><span class="p">,</span> <span class="n">uniqueness_component</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">identifier</span><span class="p">,</span> <span class="n">scheme</span><span class="o">.</span><span class="n">uniqueness_criteria</span>
        <span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uniqueness_component</span><span class="p">,</span> <span class="n">id_component</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Serialize this object to a basic dict of strings and lists of ints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;identifier&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span>
            <span class="s2">&quot;atom_indices&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_indices</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of atoms in this hierarchy element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_indices</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;Atom&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over the atoms in this hierarchy element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">atom_index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_indices</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom_index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Atom</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the atom with the specified index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_indices</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrozenMolecule</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The parent molecule for this hierarchy element</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span><span class="o">.</span><span class="n">parent</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;HierarchyElement </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2"> of iterator &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scheme</span><span class="o">.</span><span class="n">iterator_name</span><span class="si">}</span><span class="s2">&#39; containing &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_indices</span><span class="p">)</span><span class="si">}</span><span class="s2"> atom(s)&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_unique_atom_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;``True`` if the element has unique atom names, ``False`` otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_has_unique_atom_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generate_unique_atom_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate unique atom names from the element symbol and count.</span>

<span class="sd">        Names are generated from the elemental symbol and the number of times</span>
<span class="sd">        that element is found in the hierarchy element. The character &#39;x&#39; is</span>
<span class="sd">        appended to these generated names to reduce the odds that they clash</span>
<span class="sd">        with an atom name or type imported from another source. For example,</span>
<span class="sd">        generated atom names might begin &#39;C1x&#39;, &#39;H1x&#39;, &#39;O1x&#39;, &#39;C2x&#39;, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_generate_unique_atom_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_has_unique_atom_names</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">FrozenMolecule</span><span class="p">,</span> <span class="n">HierarchyElement</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;``True`` if the object has unique atom names, ``False`` otherwise.&quot;&quot;&quot;</span>
    <span class="n">unique_atom_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_atom_names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_generate_unique_atom_names</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">FrozenMolecule</span><span class="p">,</span> <span class="n">HierarchyElement</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate unique atom names from the element symbol and count.</span>

<span class="sd">    Names are generated from the elemental symbol and the number of times that</span>
<span class="sd">    element is found in the hierarchy element or molecule. The character &#39;x&#39; is</span>
<span class="sd">    appended to these generated names to reduce the odds that they clash with</span>
<span class="sd">    an atom name or type imported from another source. For example, generated</span>
<span class="sd">    atom names might begin &#39;C1x&#39;, &#39;H1x&#39;, &#39;O1x&#39;, &#39;C2x&#39;, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

    <span class="n">element_counts</span><span class="p">:</span> <span class="n">DefaultDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">symbol</span>
        <span class="n">element_counts</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># TODO: It may be worth exposing this as a user option, i.e. to avoid multiple ligands</span>
        <span class="c1"># parameterized with OpenFF clashing because they have atom names like O1x, H3x, etc.</span>
        <span class="c1"># i.e. an optional argument could enable a user to `generate_unique_atom_names(blah=&quot;y&quot;)</span>
        <span class="c1"># to have one ligand be O1y, etc.</span>
        <span class="c1"># https://github.com/openforcefield/openff-toolkit/pull/1096#pullrequestreview-767227391</span>
        <span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">symbol</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">element_counts</span><span class="p">[</span><span class="n">symbol</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;x&quot;</span>
</pre></div>

          </article>
        </div>

        <aside class="column is-hidden-touch is-2">
          
        </aside>
      </div>
  </main>
  <footer class="footer">
  <div class="footer-content">
    <div class="columns">
      <div class="fineprint column">
          <div class="copyright">
              &#169; Copyright 2021, Open Force Field Initiative.
              
          </div>
          Last updated on
            Apr 12, 2023.
          <br/>
          Created using
          <a href="http://www.sphinx-doc.org/">Sphinx</a> 6.1.3.
           and
          <a href="https://github.com/openforcefield/openff-sphinx-theme/">the Open Force Field Sphinx theme</a>
      </div>
      <div class="socials column">
        <p class="pb-3">An <a href="https://openforcefield.org/" class="has-text-white">Open Force Field Initiative</a> project.</p>
        <div>
          
            
              
                <a href="https://zenodo.org/communities/openforcefield/" class="icon has-text-light is-medium" title="OpenFF on Zenodo">
                  <i class="fa-lg ai-lg ai ai-zenodo"></i>
                </a>
              
            
              
                <a href="https://www.youtube.com/channel/UCh0aJSUm_sYr7nuTzhW806g" class="icon has-text-light is-medium" title="OpenFF on YouTube">
                  <i class="fa-lg ai-lg fab fa-youtube"></i>
                </a>
              
            
              
                <a href="https://github.com/openforcefield" class="icon has-text-light is-medium" title="OpenFF on GitHub">
                  <i class="fa-lg ai-lg fab fa-github"></i>
                </a>
              
            
              
                <a href="https://twitter.com/openforcefield" class="icon has-text-light is-medium" title="OpenFF on Twitter">
                  <i class="fa-lg ai-lg fab fa-twitter"></i>
                </a>
              
            
              
                <a href="https://www.linkedin.com/company/openforcefield/" class="icon has-text-light is-medium" title="OpenFF on LinkedIn">
                  <i class="fa-lg ai-lg fab fa-linkedin"></i>
                </a>
              
            
          
        </div>

      </div>
    </div>
  </div>
</footer>
  </body>
</html>